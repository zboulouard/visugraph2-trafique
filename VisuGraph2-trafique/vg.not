import java.awt.Color;
import java.awt.Point;
import java.awt.Graphics;
import java.awt.geom.*;
import java.awt.*;
import java.util.*;
import java.lang.Double;
/**
 * Represente une arete dans un graphe non oriente et un arc dans 
 * un graphe oriente. On utilise deux sommets pour representer les 
 * extremites de l'arete. Toutefois, un troisieme point est necessaire 
 * dans certains cas, afin de pouvoir representer les aretes paralleles 
 * d'un graphe non simple. Si les deux sommets sont egaux, l'affichage 
 * va generer une boucle.
 */
public class Arete
{
    public static final double PI = 4.0*Math.atan(1.0);
    private Sommet e1; // Les extremites de l'arete
    private Sommet e2;
    private int x;
    private int y;
    private Color couleur;
    private String nom;
    private int id;
    private double valeur = 0;
 
    public double[] Instances = new double[10];
    private boolean visible = true;
    public Color couleurEtiquette = Color.red;
    protected double longueur;
    public boolean marked = false;

    Arete(Sommet e1, Sommet e2 ) {
	if (e1 == null || e2 == null) throw new NullPointerException();
	this.e1 = e1;
	this.e2 = e2;
	
    }
    Arete(Sommet e1, Sommet e2, int x, int y, Color couleur, String nom, int id) {
	if (e1 == null || e2 == null) throw new NullPointerException();
	this.e1 = e1;
	this.e2 = e2;
	this.x = x;
	this.y = y;
	this.couleur = (couleur == null)? Color.black : couleur;
	this.nom = nom;
	this.id = id;
	this.Instances[0] = 0;
    }

    Arete( Sommet e1, Sommet e2, int x, int y, Color couleur, double valeur, int id ) {
	if ( e1 == null || e2 == null ) throw new NullPointerException();
	this.e1 = e1;
	this.e2 = e2;
	this.x = x;
	this.y = y;
	this.couleur = (couleur == null)? Color.black : couleur;
	this.valeur = valeur;
	this.id = id;
    }

    public Sommet getE1() { return e1; }
    public Sommet getE2() { return e2; }
    public void setE1(Sommet ne1) { e1 = ne1; }
    public void setE2(Sommet ne2) { e2 = ne2; }
    public int getX() { return x; }
    public int getY() { return y; }
    public void setXY(int nx, int ny) { x = nx; y = ny; }
   
    public String getNom() { return this.nom; }
    public void setNom(String nom) {  this.nom = nom; }
    public int getID() { return id; }

    public double getVal() { return valeur; }
    public double getValInstance(int i) { 
	return Instances[i];
    }
    public void addVal(double valeur) { this.valeur += valeur; }
    public void setVal(double valeur) { this.valeur  = valeur; }
    public void setValInstance( double val , int i ) {  
	if ( i < Instances.length )  // Instances.insertElementAt(new Double(val), i);      
	    Instances[i] = val;
    }

    public void setInvisible() { this.visible = false; }
    public void setVisible()   { this.visible = true; }
    public boolean getVisible() {  return this.visible; }

    public void setCouleur(Color cl) { this.couleur = cl;}
    public Color getCouleur() { return this.couleur; }

    public final double longueurCourante() {
	double dx =  e1.getX() - e2.getX();
	double dy =  e1.getY() - e2.getY();
	
	return Math.sqrt( dx*dx + dy*dy);

    }
    public final void updateLongueur() {
	longueur = longueurCourante();
    }
    public final double length() {
	return longueur;
    }
    
    /**
       Convertit un objet Arete en chaine affichable.
       @return chaine representant l'objet
    */
    public String toString()
    {
	return "Arete: (Extremite initiale: " + e1 + ", Extremite finale: " + e2 + 
	    ", point de reference=(" + x + "," + y + "), Couleur=" + couleur + 
	    ", nom=" + nom + ")";
    }

    /**
       Affiche l'arete sur la zone d'affichage que represente le contexte 
       graphique passe en parametre. On utilise des parametres additionnels pour 
       cette methode afin de pouvoir stocker ces variables une seule fois pour 
       toutes les aretes, dans l'objet Graphe, et pouvoir les changer facilement.
       @param g contexte graphique a utiliser
       @param grapheComplexe indique a la methode si elle dessine une arete dans un 
       graphe complexe. Si le graphe est complexe, la methode tiendra compte du 
       point de reference (x,y) afin de tracer un arc par lequel passe les 
       deux extremites ainsi que le point de reference. Ce point est calcule par l'objet 
       Graphe de facon a ce que les aretes ne se touchent pas. Dans le cas d'un graphe 
       oriente simple, il faudra activer grapheComplexe si on a une arete 
       reliant e1 a e2 et une autre reliant e2 a e1.
       @param grapheOriente indique si l'ordre des sommets importe. Dans ce cas, 
       il faudra dessiner une pointe de fleche vers le sommet final.
       @param couleur indique la couleur (qui dependera du facteur intensite)
     */
    public synchronized void afficher( Graphics g, 
				       boolean grapheComplexe,
				       boolean grapheOriente, 
				       Color couleur) {
	Graphics2D g2 = (Graphics2D)g;
	
	Color old = g.getColor();
	double cl = 0.0;
	/* On détermine par BasicStroke, la taille des aretes (au niveau épaisseur des traits */
	g2.setStroke(new BasicStroke(0.0F));
	if (this.visible) {
	   
	    int textPtX = x;
	    int textPtY = y;
	
	    if ( e1.equals(e2) ) {
		g.drawOval( e1.getX()-3*Sommet.RAYON,
			    e1.getY()-6*Sommet.RAYON,
			    6*Sommet.RAYON-1, 
			    6*Sommet.RAYON-1 );
		textPtX = e1.getX();
		textPtY = e1.getY() - 6*Sommet.RAYON;
		if (grapheOriente)
		    afficherFleche( g, new Droite( 1.0, 0.0, textPtX, textPtY, false ) );
	    }
	    else   {
		g.setColor(this.couleur);
		g.drawLine(e1.getX(), e1.getY(), e2.getX(), e2.getY()); 
		textPtX = (e1.getX() + e2.getX())/2; 
		textPtY = (e1.getY() + e2.getY())/2; 
		int mx = (e1.getX() + e2.getX())/2; 
		int my = (e1.getY() + e2.getY())/2; 
		if (grapheOriente) 
		    afficherFleche(g, new Droite((double)e2.getX()-e1.getX(), 
						 (double)e2.getY()-e1.getY(), 
						 mx, my, true)); 
	    } 
	    g2.setStroke(new BasicStroke(0.0F));
	    g.setColor(old);
	}
    }
    
    /**
     * Affiche la valeur d'une arete. 
     @param g le contexte d'affichage utilise
     @param valeur la valeur a afficher
    */
    public synchronized void afficherValeur(Graphics g )
    {
	Graphics2D g2 = (Graphics2D)g;
	
	Color old = g.getColor();
	
	if ( this.visible ) {
	    g2.setStroke(new BasicStroke(1.3F));
	    int textPtX = (e1.getX() + e2.getX())/2; 
	    int textPtY = (e1.getY() + e2.getY())/2; 
	    
	    if ( nom != null ) {
		g.setColor(couleurEtiquette);
		g.drawString(nom, textPtX, textPtY);
	    }
	    g2.setStroke(new BasicStroke(0.0F));
	    g.setColor(old);
	}
    }

    public void afficherFleche(Graphics g, Droite d)
    {
	Point pt = d.resoudre(-Sommet.RAYON);
	Droite perp = new Droite(-d.getDY(), d.getDX(), (int)pt.getX(), (int)pt.getY(), true);
	Point pt0 = perp.resoudre(-Sommet.RAYON);
	Point pt1 = perp.resoudre(Sommet.RAYON);
	pt = new Point((int)d.getX0(),(int)d.getY0());
	g.drawLine(pt0.x,pt0.y,pt.x,pt.y);
	g.drawLine(pt.x,pt.y,pt1.x,pt1.y);
    }

    /**
     * Teste si trois objets Point sont colineaires, c'est-a-dire que les trois 
     * points se trouvent sur la meme droite. Pour ce faire, la methode 
     * cree des vecteurs a partir de ces points et verifie si ces deux vecteurs 
     * sont paralleles.
     @param p1 premier point
     @param p2 second point
     @param p3 troisieme point
     @return indique si les trois points sont colineaires
     */
    private boolean pointsColineaires(Point p1, Point p2, Point p3)
    {
	int v1x = (int)(p2.getX() - p1.getX());
	int v1y = (int)(p2.getY() - p1.getY());
	int v2x = (int)(p3.getX() - p2.getX());
	int v2y = (int)(p3.getY() - p2.getY());
	return vecteursParalleles(new Point(v1x, v1y), new Point(v2x,v2y));
    }

    /**
     * Verifie si deux vecteurs sont paralleles. Les vecteurs sont specitifies 
     * comme des objets Point.
     @param v1 premier vecteur
     @param v2 second vecteur
     @return resultat du test de parallelisme
     */
    private boolean vecteursParalleles(Point v1, Point v2 )
    {
	// Pour effectuer un test de parallelisme fiable dans tous les cas,
	// il suffit de normaliser les deux vecteurs. Cela evitera des divisions par zero,
	// a moins que l'un des deux vecteurs soit de longueur nulle, ce qui n'est pas normal.
	double v1length = Math.sqrt(v1.getX()*v1.getX() + v1.getY()*v1.getY());
	double v2length = Math.sqrt(v2.getX()*v2.getX() + v2.getY()*v2.getY());
	double v1x = v1.getX()/v1length;
	double v1y = v1.getY()/v1length;
	double v2x = v2.getX()/v2length;
	double v2y = v2.getY()/v2length;
	return v1x == v2x && v1y == v2y;
    }

    /**
     * Affiche une arete sous la forme d'un arc passant par trois points. 
     * La methode calcule tout d'abord un cercle passant par les points 
     * e1, (x,y) et e2, puis les angles de coupe dans le but de tracer un 
     * arc partant du point e1 ou e2 vers le point e2 ou e1, selon la position 
     * de ces points.
     @param g contexte d'affichage utilise
     @param grapheOriente indique si le graphe a tracer est oriente ou non
     */
    private void afficherArc(Graphics g, boolean grapheOriente)
    {
	Droite med1 = mediatrice(new Point(e1.getX(),e1.getY()), new Point(x,y));
	Droite med2 = mediatrice(new Point(x,y), new Point(e2.getX(),e2.getY()));
	Point centre = intersection(med1, med2);
	double rayon = (int)Math.sqrt(Math.pow(centre.getX()-e1.getX(),2.0)+
				   Math.pow(centre.getY()-e1.getY(),2.0));
	int irayon = (int)rayon;
	int i2rayon = (int)(2*rayon);
	System.out.println(rayon);
	double theta1 = Math.atan2(centre.getY()-e1.getY(),e1.getX()-centre.getX());
	double theta2 = Math.atan2(centre.getY()-e2.getY(),e2.getX()-centre.getX());
	double thetamin = theta1 < theta2 ? theta1 : theta2;
	double deltatheta = Math.abs(theta2-theta1);
	g.drawArc((int)centre.getX()-irayon,(int)centre.getY()-irayon,
		  i2rayon-1,i2rayon-1,
		  (int)(thetamin*180./Math.PI),
		  (int)(deltatheta*180./Math.PI));
	// On obtient la pente de la tangente au cercle en utilisant la derivation 
	// implicite de l'equation du cercle.
	if (grapheOriente)
	    {
		double dy = -(x-centre.getX());
		double dx = y-centre.getY();
		afficherFleche(g, new Droite(dx, dy, x, y, true));
	    }
    }

    /**
     * Calcule la mediatrice d'une droite passant par deux points, 
     * retournant l'equation parametrique de cette mediatrice.
     @param p1 premier point
     @param p2 second point
     @return objet Droite contenant les equations parametriques de la mediatrice
     */
    private Droite mediatrice(Point p1, Point p2)
    {
	// On ne calcule pas la pente directement, on calcule plutot le vecteur directeur 
	// (dx,dy). La pente serait dy/dx, mais si dx=0, cela ne fonctionne pas.
	double dx = p1.getX()-p2.getX();
	double dy = p1.getY()-p2.getY();

	// Construction du vecteur perpendiculaire (dy,-dx)
	double temp = dx;
	dx = -dy;
	dy = temp;

	// Calcul du point milieu, qui deviendra le point initial de la droite
	double mx = (p1.getX()+p2.getX())/2;
	double my = (p1.getY()+p2.getY())/2;

	return new Droite(dx,dy,(int)mx,(int)my,false);
    }

    /**
     * Calcul le point d'intersection entre deux droites. Les droites ne 
     * doivent pas etre paralleles.
     @param d1 premiere droite
     @param d2 seconde droite
     @return objet Point contenant le point d'intersection, null si les droites sont paralleles
     */
    private Point intersection(Droite d1, Droite d2)
    {
	if (vecteursParalleles(new Point((int)d1.getDX(),(int)d1.getDY()),
			       new Point((int)d2.getDX(),(int)d2.getDY())))
	    return null;

	double t;
	if (d1.getDX() != d2.getDX())
	    t = ((double)(d2.getX0()-d1.getX0()))/(d1.getDX()-d2.getDX());
	else
	    t = ((double)(d2.getY0()-d1.getY0()))/(d1.getDY()-d2.getDY());

	return d1.resoudre(t);
    }

    /**
       Deux aretes sont egales si et seulement si leurs deux extermites 
       sont egales et qu'elles ont le meme identificateur.
     */
    public boolean equals(Arete autre)
    {
	return ((e1.equals(autre.getE1()) && e2.equals(autre.getE2())) ||
		(e1.equals(autre.getE2()) && e2.equals(autre.getE1()))) &&
	    id == autre.getID();
    }

    /**
       Test d'egalite pour les graphes orientes.
     */
    public boolean equalsOriented(Arete autre)
    {
	return (e1.equals(autre.getE1()) && e2.equals(autre.getE2())) &&
	    id == autre.getID();
    }

    /**
     * indique si deux aretes sont paralleles. Cela correspond au test 
     * d'egalite sans les ID.
     @param autre autre arete a tester
     @param oriente indique si on effectue le test pour un graphe oriente
     */
    public boolean paralleleA(Arete autre, boolean oriente)
    {
	boolean eq = getE1().equals(autre.getE1()) && getE2().equals(autre.getE2());
	return ((!oriente && eq) ||
		(oriente && eq && 
		 getE1().equals(autre.getE2()) && getE2().equals(autre.getE1())));
    }


}

/**
 * Represente une droite parametrique utilisee dans le calcul de l'arc 
 * a afficher. On represente la droite par les deux fonctions suivantes.
 * 
 * x = dx*t+x0
 * y = dy*t+y0
 * ou t varie entre 0 et 1
 */
class Droite
{
    private double dx;
    private double dy;
    private double x0;
    private double y0;
    
    Droite(double dx, double dy, double x0, double y0, boolean unit)
    {
	double length = unit ? Math.sqrt(dx*dx+dy*dy) : 1.0;
	this.dx = dx/length;
	this.dy = dy/length;
	this.x0 = x0;
	this.y0 = y0;
    }
    
    public double getDX() { return dx; }
    public double getDY() { return dy; }
    public double getX0() { return x0; }
    public double getY0() { return y0; }
    
    /**
     * Calcule la position sur la droite. 
     @param t la valeur de la variable t
     @return un objet Point contenant la solution aux deux equations de la droite
     */
    public Point resoudre(double t)
    {
	return new Point((int)(dx*t+x0),(int)(dy*t+y0));
    }

    /**
     * Convertit l'objet Droite en une chaine affichable
     @return objet String contenant la chaine
     */
    public String toString()
    {
	return "Droite: (x=" + dx + "t+" + x0 + ",y=" + dy + "t+" + y0 + ")";
    }
    
}


import javax.swing.*;
import javax.swing.event.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;


class ControlWindow extends JPanel implements ActionListener {
    
    JFrame fenetre   = new JFrame("Paramètres");
    JFrame vitesse   = new JFrame("Vitesse du morphing");

    /* echelle de valeurs selectionnables pour les différentes catégories*/
    JSlider slider1  = new JSlider();
    JSlider slider2  = new JSlider();
    JSlider slider3  = new JSlider();
    JSlider slider4  = new JSlider();
    JSlider slider5  = null;
    JSlider slider6  = new JSlider();

    Image imageRelache;
    Image imageEnfonce;
    JPanel panel, panel2;

    /* déclaration des boutons pour le morphing, permettant de passer d'une instance à l'autre.*/
    JButton avance, recule, reset;
    Icon icon1, icon2, icon3;
    Color b = new Color (128,191,212);

    ControlWindow(int instance) {

	JPanel panel = new JPanel(new GridLayout(0, 1) );
	add("Center", panel );
	fenetre.setSize(205, (instance > 1)?350:400);
	fenetre.setResizable(false);
	fenetre.setBackground(b);
	vitesse.setBackground(Color.lightGray);


	// slider pour la force d'attraction entre sommets
	panel.add( new JLabel("    Force de répulsion"), BorderLayout.CENTER );
	// couleur du panneau
	panel.setBackground(b);
	// valeur minimale du slider
	slider2.setMinimum(1);
	slider2.setValue(5);
	// Graduation maximale du slider
	slider2.setMaximum(9);
	// pour afficher les graduations du slider
	slider2.setPaintTicks(true);
	slider2.setPaintLabels(true);
	// espacement entre deux graduations du slider
	slider2.setMinorTickSpacing(1);
	// couleur du label
	slider2.setBackground(Color.lightGray);
	// fixage du slider sur le panneau
	panel.add(slider2);

		// slider pour la force d'attraction entre sommets
	panel.add( new JLabel("    Force d'attraction"), BorderLayout.CENTER );
	// couleur du panneau
	panel.setBackground(b);
	// valeur minimale du slider
	slider6.setMinimum(1);
	slider6.setValue(5);
	// Graduation maximale du slider
	slider6.setMaximum(9);
	// pour afficher les graduations du slider
	slider6.setPaintTicks(true);
	slider6.setPaintLabels(true);
	// espacement entre deux graduations du slider
	slider6.setMinorTickSpacing(1);
	// couleur du label
	slider6.setBackground(Color.lightGray);
	// fixage du slider sur le panneau
	panel.add(slider6);
	

	// slider pour le filtrage des arêtes
	panel.add( new JLabel("    Filtrage  "), BorderLayout.CENTER );
	slider1.setPaintTicks(true);
	slider1.setPaintLabels(true);
	slider1.setBackground(Color.lightGray);
	panel.add(slider1);

	// slider pour l'intensité des arêtes
 	panel.add( new JLabel("    Intensité des liens"), BorderLayout.CENTER );
	slider3.setValue(3);
	slider3.setMaximum(6);
	slider3.setMinorTickSpacing(1);
	slider3.setSnapToTicks(true);
	slider3.setPaintTicks(true);
	slider3.setPaintTrack(true);
	slider3.setPaintLabels(true);
	slider3.setBackground(Color.lightGray);
	panel.add(slider3);

	// slider pour le clustering
	panel.add(new JLabel("   Densité de clustering"), BorderLayout.CENTER );
	slider4.setMinimum(2);
	slider4.setValue(4);
	slider4.setMaximum(10);
	slider4.setMinorTickSpacing(1);
	slider4.setSnapToTicks(true);
	slider4.setPaintTicks(true);
	slider4.setPaintTrack(true);
	slider4.setPaintLabels(true);
	slider4.setBackground(Color.lightGray);
	panel.add(slider4);

	if ( instance > 1 ) {

	    panel.add(new JLabel("   Choix d'instances"), BorderLayout.CENTER );
	    slider5 = new JSlider();
	    slider5.setMinimum(0);
	    slider5.setValue(0);
	    slider5.setMaximum(instance);
	    slider5.setMinorTickSpacing(1);
	    slider5.setSnapToTicks(true);
	    slider5.setPaintTicks(true);
	    //slider5.setPaintTrack(true);
	    slider5.setPaintLabels(true);
	    slider5.setBackground(Color.lightGray);
	    panel.add(slider5);

	    /* recours à un FlowLayout pour permettre d'afficher les deux flèches sur la même ligne et non pas l'une sous l'autre.*/
	    panel2 = new JPanel(new FlowLayout(FlowLayout.CENTER, 5, 1));
	    panel2.setBackground(Color.lightGray);
	    add("Center", panel2);

	    /* Chemins d'accès pour atteindre l'image de la flèche : à modifier si on installe cette version sur une autre machine!!!*/
	    icon2 = new ImageIcon("/home/Tetra/VisuGraph/reset.gif");
	    reset = new JButton(icon2);
	    Dimension d = new Dimension( icon2.getIconWidth(), icon2.getIconHeight()  );
	    reset.setPreferredSize(d);
	   //panel2.add(reset);

	    icon3 = new ImageIcon("/home/Tetra/VisuGraph/Previous.gif");
	    recule = new JButton(icon3);
	    d = new Dimension(icon3.getIconWidth(), icon3.getIconHeight() );
	    recule.setPreferredSize(d);
	    panel2.add(recule);

	    icon1 = new ImageIcon("/home/Tetra/VisuGraph/Next.gif");
	    avance = new JButton(icon1);
	    d = new Dimension( icon1.getIconWidth(), icon1.getIconHeight()  ); 
	    avance.setPreferredSize(d);  
	    panel2.add(avance ); 

	    avance.addActionListener(this);
	    recule.addActionListener(this);
	    add("Center", new JPanel());
	    recule.setEnabled(false);
	    reset.setEnabled(false);
	    JPanel pvitesse = new JPanel();
	    pvitesse.setBackground(Color.lightGray);
	    JSlider jvitesse =  new JSlider();
	    vitesse.setBackground(Color.lightGray);
	    jvitesse.setInverted(true);
	    jvitesse.setMinimum(100);
	    jvitesse.setValue(500);
	    jvitesse.setMaximum(1000);
	    jvitesse.setPaintTicks(true);
	    jvitesse.setPaintLabels(true);
	    jvitesse.setMinorTickSpacing(10);
	   
	    pvitesse.add(jvitesse);
	    vitesse.setSize(210,100);
	    vitesse.setResizable(false);
	    vitesse.getContentPane().add(pvitesse);
	    //vitesse.setVisible(true);

	}
	fenetre.getContentPane().add(this, BorderLayout.CENTER );

    }
    
    public void actionPerformed(ActionEvent e) {}

	/*if ( e.getSource() == avance && slider5.getValue() < slider5.getMaximum() ) {
	    avance.setEnabled(false); 
	    recule.setEnabled(false);
	}	
	if ( e.getSource() == recule  ) {
	    recule.setEnabled(false);
	    avance.setEnabled(false); 
	}
    }*/

}
/*
 * DocumentViewer.java  1.0
 * 
 * Copyright (c) 1999 Emmanuel PUYBARET - eTeks.
 * All Rights Reserved.
 *
 */

import javax.swing.*;
import javax.swing.event.*;
import javax.swing.text.*;
import javax.swing.text.html.*;

import java.awt.*;
import java.awt.event.*;
import java.net.URL;
import java.io.IOException;

// Classe de fenetre Swing permettant de visualiser un
// document (HTML ou texte)
public class DocumentViewer extends JFrame  implements HyperlinkListener, ActionListener
{
    // Composant Swing permettant de visualiser un document
    
    JEditorPane viewer       = new JEditorPane ();
    
    // Champ de saisie de l'URL a visualiser
    JTextField  urlTextField = new JTextField ();
    
    public DocumentViewer (String titre) 
    {     
	setTitle(titre);
	// Construction de l'Interface Graphique
	// Panel en haut avec un label et le champ de saisie
	JPanel inputPanel = new JPanel (new BorderLayout ());
	JLabel label = new JLabel ("   Sources : ");    
	inputPanel.add (label, BorderLayout.WEST);
	inputPanel.add (urlTextField, BorderLayout.CENTER);
	// Zone scrollee au centre avec le document    
	JScrollPane scrollPane = new JScrollPane (viewer);
	// Ajout des composants a la fenetre
	getContentPane ().add (inputPanel, BorderLayout.NORTH);
	getContentPane ().add (scrollPane, BorderLayout.CENTER);
	
	// Mode non editable pour recevoir les clics sur les 
	// liens hypertexte
	viewer.setEditable (false);
	// Ajout du listener de clic sur lien
	viewer.addHyperlinkListener (this);
	// Ajout du listener de modification de la saisie
	urlTextField.addActionListener (this);
    }
    
    // Methode appelee apres un clic sur un lien hyper texte
    public void hyperlinkUpdate (HyperlinkEvent event) 
    {
	if (event.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
	    // Modification du champ de saisie
	    urlTextField.setText (event.getURL ().toString ());
	    if (event instanceof HTMLFrameHyperlinkEvent) {
		// Evenement special en cas d'utilisation de Frame HTML
		HTMLDocument doc = (HTMLDocument)viewer.getDocument ();
		doc.processHTMLFrameHyperlinkEvent ((HTMLFrameHyperlinkEvent)event);
	    }
	    else
		// Chargement de la page
		loadPage (urlTextField.getText ());
	}
    }
    
    // Methode appelee apres une modification de la saisie
    public void actionPerformed (ActionEvent event) {
	loadPage (urlTextField.getText ());
    }
    
    public void loadPage (String urlText) {
	try {
	    // Modification du document visualise
	    viewer.setPage (new URL (urlText));
	} 
	catch (Exception ex) {
	    System.err.println ("Accès impossible à : " + urlText);
	}
    }

    public void TextToHtml(String fileText, String fileHtml) {
	
    }

    // Methode main () d'exemple de mise en oeuvre.
    // 
    public static void main (String [] args) {
	DocumentViewer viewerFrame = new DocumentViewer ("Retour aux notices");
	viewerFrame.setSize (600, 800);
	viewerFrame.loadPage(args[0]);
	viewerFrame.urlTextField.setText (args[0]);
	viewerFrame.addWindowListener( new WindowAdapter() {
	    public void windowClosing(WindowEvent evt) {
		System.exit(0);
	    }
	});
	viewerFrame.show ();
    }
}
import java.awt.*;
import java.awt.font.*;
import java.awt.event.*;
import java.util.*;
import java.net.*;
import javax.swing.*;
import javax.swing.event.*;


/* Classes gérant le menu sommet, avec une indexation par nom. */

public class FishEyeMenu extends JMenu implements MenuListener {
    FishEyeWindow fishEyeWindow = null;
    
    public FishEyeMenu(String title) {
	super(title);
	addMenuListener(this);
	
	fishEyeWindow = new FishEyeWindow(this);
    }
    
    public JMenuItem add(JMenuItem item) {
	fishEyeWindow.add(item);
	return item;
    }
    
    public void setDesiredMaxFontSize(int desiredMaxFontSize) {
	fishEyeWindow.setDesiredMaxFontSize(desiredMaxFontSize);
    }

    public void setDesiredFocusLength(int desiredFocusLength) {
	fishEyeWindow.setDesiredFocusLength(desiredFocusLength);
    }

    public void menuSelected(MenuEvent e) {
	Point location = getLocationOnScreen();
	fishEyeWindow.setLocation(location.x+30, location.y + getSize().height);
	fishEyeWindow.setVisible(true);
	fishEyeWindow.requestFocus();
    }

    public void menuCanceled(MenuEvent e) {
	fishEyeWindow.setVisible(false);
    }

    public void menuDeselected(MenuEvent e) {
	fishEyeWindow.setVisible(false);
    }

    protected void fireMenuCanceled() {
	super.fireMenuCanceled();
    }
}

class Item {
    JMenuItem menuItem;
    String label;
    int size;
    int space;
}

class FishEyeWindow extends JWindow implements MouseListener, MouseMotionListener,
					       KeyListener, ItemListener {
    static final int MAX_ANTIALIAS_SIZE = 50;
    static Image up = null;
    static Image down = null;

    FishEyeMenu menu = null;
    Item items[];
    int numItems = 0;
    Font fonts[];
    Font boldFonts[];
    int desiredFocusLength = 10;
    int desiredMaxFontSize = 12;
    int focusLength = desiredFocusLength;
    int maxFontSize = desiredMaxFontSize;
    int minFontSize = desiredMaxFontSize;
    float desiredSpacing = 0.5f;     // Percentage of font size
    float minDesiredSpacing = 0.1f;  // Percentage of font size
    int desiredSpace = (int)(maxFontSize * desiredSpacing);
    int minSpace;
    int borderLeft = desiredMaxFontSize + 5;
    int borderRight = 1;
    int labelBorderLeft = 5;
    int borderY = 10;
    int mouseY = 0;
    Image backBuffer = null;
    Graphics gb = null;
    //Color backgroundColor = new Color(207, 207, 207); //Color.white;
    Color backgroundColor = Color.lightGray;/* new Color(0,0,0); // couleur noire*/
    /* couleur de la ligne selectionnée dans le menu sommets */
    Color hilightColor = Color.white; //new Color(144, 151, 207);
    Color labelColor = Color.black;
    int selectionIndex = 0;    // The index of the item that is currently selected
    int focusIndex = 0;        // The index of the item that is centered in the focus
    int focusIndexLUT[];
    String labelLUT[];
    int labelPosLUT[];
    int sizeLUT[][];
    int spaceLUT[][];
    int flFocusPosition;
    int flSizeLUT[];
    int flSpaceLUT[];
    int numLabels = 0;
    boolean focusLock = false;

    public FishEyeWindow(FishEyeMenu menu) {
	super();
	
	int i;
	this.menu = menu;
	
	items = new Item[20];
	for (i=0; i<items.length; i++) {
	    items[i] = new Item();
	}

	fonts = new Font[maxFontSize + 1];
	for (i=1; i <= maxFontSize; i++) {
	    fonts[i] = new Font(null, Font.PLAIN, i);
	}

	boldFonts = new Font[maxFontSize + 1];
	for (i=1; i<=maxFontSize; i++) {
	    boldFonts[i] = new Font(null, Font.BOLD, i);
	}

	addMouseListener(this);
	addMouseMotionListener(this);
	addKeyListener(this);
	
	/*if (up == null) {
	    URL resource = this.getClass().getClassLoader().getResource("arrow-up.gif");
	    up = Toolkit.getDefaultToolkit().createImage(resource);
	    resource = this.getClass().getClassLoader().getResource("arrow-down.gif");
	    down = Toolkit.getDefaultToolkit().createImage(resource);
	}*/
    }
    
    public void setDesiredMaxFontSize(int desiredMaxFontSize) {
	if (desiredMaxFontSize > this.desiredMaxFontSize) {
	    int i;
	    Font newFonts[] = new Font[desiredMaxFontSize + 1];
	    Font newBoldFonts[] = new Font[desiredMaxFontSize + 1];
	    for (i=1; i<=this.desiredMaxFontSize; i++) {
		newFonts[i] = fonts[i];
		newBoldFonts[i] = boldFonts[i];
	    }
	    for (i=this.desiredMaxFontSize+1; i<=desiredMaxFontSize; i++) {
		newFonts[i] = new Font(null, Font.PLAIN, i);
		newBoldFonts[i] = new Font(null, Font.BOLD, i);
	    }
	    fonts = newFonts;
	    boldFonts = newBoldFonts;
	}
	this.desiredMaxFontSize = desiredMaxFontSize;
	desiredSpace = (int)(desiredMaxFontSize * desiredSpacing);
	borderLeft = desiredMaxFontSize + 5;
    }
    
    public void setDesiredFocusLength(int desiredFocusLength) {
	this.desiredFocusLength = desiredFocusLength;
	calculateSizes();
    }
    
    public void setVisible(boolean visible) {
	if (visible) {
	    calculateSizes();
	    focusIndex = 0;
	    selectionIndex = 0;
	    mouseY = 0;
	    focusLock = false;
	    labelColor = Color.black;
	}
	super.setVisible(visible);
    }

    public void mouseMoved(MouseEvent e) {
	// Determine if we are in focus lock mode
	if (e.getX() < getSize().width/2) {
	    if (focusLock) {
		repaint();
	    }
	    focusLock = false;
	} else {
	    if (!focusLock) {
		// Just entered focus lock mode, so update look up tables, and calculate focus item position
		flFocusPosition = borderY;
		for (int i=0; i<numItems; i++) {
		    flSizeLUT[i] = sizeLUT[focusIndex][i];
		    flSpaceLUT[i] = spaceLUT[focusIndex][i];
		    if (i < focusIndex) {
			flFocusPosition += flSizeLUT[i] + flSpaceLUT[i];
		    }
		}
	    }
	    focusLock = true;
	}
	
	mouseY = e.getY();
	
	if (focusLock) {
	    // FOCUS LOCK mode
	    boolean focusIncreased = false;
	    if (mouseY > flFocusPosition) {
		int i;
		int y = flFocusPosition;
		selectionIndex = focusIndex;
		// First, set the items between the focus and the cursor to full size
		for (i=focusIndex; i<numItems; i++) {
		    if (flSizeLUT[i] < maxFontSize) {
			flSizeLUT[i] = maxFontSize;
			flSpaceLUT[i] = desiredSpace;
			focusIncreased = true;
		    }
		    y += flSizeLUT[i] + flSpaceLUT[i];
		    selectionIndex = i;
		    if (mouseY < y) {
			break;
		    }
		}
		i++;
		// Then, add the fisheye size decrease
		if ((i < numItems) && (flSizeLUT[i] < maxFontSize)) {
		    boolean done = false;
		    while ((i < numItems) && !done) {
			if (flSizeLUT[i] == minFontSize) {
			    done = true;
			}
			if (flSizeLUT[i] < maxFontSize) {
			    flSizeLUT[i]++;
			    if (flSizeLUT[i] == maxFontSize) {
				flSpaceLUT[i] = desiredSpace;
				focusIncreased = true;
			    }
			}
			i++;
		    }
		}
	    } else if (focusIndex > 0) {
		int i;
		int y = flFocusPosition - flSizeLUT[focusIndex-1] - flSpaceLUT[focusIndex-1];
		selectionIndex = focusIndex;
		for (i=focusIndex-1; i>=0; i--) {
		    if (flSizeLUT[i] < maxFontSize) {
			flSizeLUT[i] = maxFontSize;
			flSpaceLUT[i] = desiredSpace;
			focusIncreased = true;
		    }
		    selectionIndex = i;
		    if (mouseY > y) {
			break;
		    }
		    y -= flSizeLUT[i] + flSpaceLUT[i];
		}
		i--;
		if ((i >= 0) && (flSizeLUT[i] < maxFontSize)) {
		    boolean done = false;
		    while ((i >= 0) && !done) {
			if (flSizeLUT[i] == minFontSize) {
			    done = true;
			}
			if (flSizeLUT[i] < maxFontSize) {
			    flSizeLUT[i]++;
			    if (flSizeLUT[i] == maxFontSize) {
				flSpaceLUT[i] = desiredSpace;
				focusIncreased = true;
			    }
			}
			i--;
		    }
		}
	    }
	    if (focusIncreased) {
		int bg = backgroundColor.getRed();
		int c = labelColor.getRed() + 30;
		if (c > bg) {
		    c = bg;
		}
		labelColor = new Color(c, c, c);
	    }
	    repaint();
	} else {
	    // Not FOCUS LOCK mode
	    
	    // Calculate index of focus item based on pointer position
	    int prevFocusIndex = focusIndex;
	    focusIndex = focusIndexLUT[mouseY];
	    selectionIndex = focusIndex;
	    labelColor = Color.black;
	    repaintDamagedRegion(prevFocusIndex);
	}
    }
public void itemStateChanged(ItemEvent e) {
    System.out.println(((JMenuItem)(e.getSource())).getText() );

}
public void repaintDamagedItem(int index) {
    int y = borderY;
    for (int i=0; i<index; i++) {
	y += sizeLUT[focusIndex][i] + spaceLUT[focusIndex][i];
    }
    int height = sizeLUT[focusIndex][index] + spaceLUT[focusIndex][index];
    repaint(borderLeft, y, getSize().width - borderLeft - borderRight, height);
}

void repaintDamagedRegion(int prevFocusIndex) {
	int i;
	int y;
	int height;
	int yStart1 = -1;
	int yStart2 = -1;
	int height1 = -1;
	int height2 = -1;
	// Compute the portion of the menu that was changed, and just
	// repaint that portion.
	y = borderY;
	for (i=0; i<numItems; i++) {
	    if ((yStart1 == -1) && (sizeLUT[prevFocusIndex][i] > minFontSize)) {
		yStart1 = y;
	    } else if ((yStart1 >= 0) && (sizeLUT[prevFocusIndex][i] == minFontSize)) {
		height1 = y - yStart1;
		break;
	    }
	    y += sizeLUT[prevFocusIndex][i] + spaceLUT[prevFocusIndex][i];
	}
	if (height1 == -1) {
	    height1 = getSize().height - yStart1;
	}

	y = borderY;
	for (i=0; i<numItems; i++) {
	    if ((yStart2 == -1) && (sizeLUT[focusIndex][i] > minFontSize)) {
		yStart2 = y;
	    } else if ((yStart2 >= 0) && (sizeLUT[focusIndex][i] == minFontSize)) {
		height2 = y - yStart2;
		break;
	    }
	    y += sizeLUT[focusIndex][i] + spaceLUT[focusIndex][i];
	}
	if (height2 == -1) {
	    height2 = getSize().height - yStart2;
	}
	
	if (yStart1 < yStart2) {
	    y = yStart1;
	    height = height2 + (yStart2 - yStart1);
	} else {
	    y = yStart2;
	    height = height1 + (yStart1 - yStart2);
	}
	System.out.println("fonction repaintDamagedRegion!!!!!!!!!!!!" );
	repaint(borderLeft, y, getSize().width - borderLeft - borderRight, height);
    }

public void mouseDragged(MouseEvent e) {
    mouseMoved(e);
}

public void mousePressed(MouseEvent e) {}
public void mouseReleased(MouseEvent e) {
    //System.out.println(" Label = " + items[selectionIndex].menuItem.getLabel());
    Color labelColor = Color.black;
    items[selectionIndex].menuItem.doClick();
    menu.fireMenuCanceled();
    requestFocus();
}
public void mouseClicked(MouseEvent e) { }
public void mouseEntered(MouseEvent e) {}
public void mouseExited(MouseEvent e) {}

public void keyPressed(KeyEvent e) {
    int key = e.getKeyCode();
    
    switch (key) {
    case KeyEvent.VK_UP:
	if (selectionIndex > 0) {
	    selectionIndex--;
	    focusIndex--;
	    repaint();
	}
	break;
    case KeyEvent.VK_DOWN:
	if (selectionIndex < (numItems - 1)) {
	    selectionIndex++;
	    focusIndex++;
	    repaint();
	}
	break;
    case KeyEvent.VK_ENTER:
	items[selectionIndex].menuItem.doClick();
	menu.fireMenuCanceled();
	break;
    default:
	// Move index to next element starting with key
	char c = Character.toUpperCase(e.getKeyChar());
	if (Character.isLetter(c)) {
	    // If already on such an element, try the next one
	    if (Character.toUpperCase(items[selectionIndex].label.charAt(0)) == c) {
		selectionIndex++;
		focusIndex++;
		repaint();
	    }
	    
	    // If not on such an element, then search for one
	    if ((selectionIndex >= numItems) || (Character.toUpperCase(items[selectionIndex].label.charAt(0)) != c)) {
		for (int i=0; i<numItems; i++) {
		    if (Character.toUpperCase(items[i].label.charAt(0)) == c) {
			selectionIndex = i;
			focusIndex = i;
			repaint();
			break;
		    }
		}
	    }
	}
	break;
    }	
}
public void keyReleased(KeyEvent e) {}
public void keyTyped(KeyEvent e) {}

public void add(JMenuItem item) {
    try {
	items[numItems].menuItem = item;
	items[numItems].label = item.getText();
    } catch (ArrayIndexOutOfBoundsException e) {
	Item[] newItems = new Item[(numItems == 0) ? 1 : (2 * numItems)];
	System.arraycopy(items, 0, newItems, 0, numItems);
	items = newItems;
	for (int i=numItems; i<items.length; i++) {
	    items[i] = new Item();
	}
	items[numItems].menuItem = item;
	items[numItems].label = item.getText();
    }
    numItems++;
}


/**
 *  Calculate the sizes of the window, the max and min font sizes, and the focus length.
 *  It uses the following the algorithm:
 *  Try to follow desired max font size and focus length by first computing
 *  the biggest minimum font size that will fit in the available space.
 *  If this is not satisfied for a minimum font size of 1, then first
 *  the focus length, and then the max font size is reduced until it fits.
 */
public void calculateSizes() {
    int i;
    int width = 0;
    int height = 0;
    int maxHeight = 0;

    focusLength = desiredFocusLength;
    maxFontSize = desiredMaxFontSize;

    // Calculate window width based on content
    FontRenderContext frc = new FontRenderContext(null, false, false);
    float stringWidth;
    for (i=0; i<numItems; i++) {
	stringWidth = (float)fonts[maxFontSize].getStringBounds(items[i].label, frc).getWidth() + 5;
	if (stringWidth > width) {
	    width = (int)stringWidth + borderLeft + borderRight;
	}
    }

    // Calculate max height based on window position and screen size
    Point location = getLocation();
    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
    maxHeight = screenSize.height - location.y - 30;       // Leave space for Start Menu Bar

    int availWidth = width - (borderLeft + borderRight);
    int availHeight = maxHeight - 2*borderY;
    int size;
    boolean done = false;
    // Calculate minimum font size, and actual window height
    do {
	for (size=maxFontSize; size >= 1; size--) {
	    int tmpHeight = calculateWindowHeight(size) + 10;
	    if (tmpHeight <= maxHeight) {
		height = tmpHeight;
		minFontSize = size;
		if (size == maxFontSize) {
		    // If whole window at max size, then no compressed spacing
		    minSpace = desiredSpace;
		} else {
		    minSpace = (int)(minFontSize * minDesiredSpacing);
		}
		done = true;
		break;
	    }
	}
	if (!done) {
	    // If not done, there wasn't enough room, so try a smaller focus or max font size
	    if (focusLength > 2) {
		focusLength -= 2;
	    } else {
		maxFontSize--;
	    }
	}
    } while (!done);
    // If entire menu is full size, then just use requested space.
    // Else, use all the available space.
    if (size < maxFontSize) {
	height = maxHeight;
    }
	
				// Set the size of the window
    setSize(width+20, height);
    backBuffer = null;

				// Now, calculate layout of all items for each focus
    sizeLUT = new int[numItems][numItems];
    spaceLUT = new int[numItems][numItems];
    flSizeLUT = new int[numItems];
    flSpaceLUT = new int[numItems];
    int d;
    int j, k;
    int fl2;
    int y;
    int space;
    for (i=0; i<numItems; i++) {
	fl2 = focusLength / 2;
	y = borderY;
	for (j=0; j<numItems; j++) {
	    // Calculate size and spacing for the current item
	    d = Math.abs(j - i);
	    if (d > fl2) {
		d -= fl2;
		size = maxFontSize - d;
		space = (int)(size * desiredSpacing);
		if (size <= minFontSize) {
		    size = minFontSize;
		    space = minSpace;
		}
	    } else {
		size = maxFontSize;
		space = desiredSpace;
	    }
	    sizeLUT[i][j] = size;
	    spaceLUT[i][j] = space;
	    y += size + space;
	}

	// If extra space, then grow items to fill it
	int extraSpace = getSize().height - y - 2*borderY;
	if (extraSpace > 0) {
	    int j1, j2;
	    int i1, i2;

	    i1 = i - fl2 - 1;
	    i2 = i + fl2 + 1;
	    while ((extraSpace > 0) && ((i1 >= 0) || (i2 < numItems))) {
		j1 = i1;
		j2 = i2;
		for (k=0; k<(maxFontSize - minFontSize); k++) {
		    if (j1 >= 0) {
			if (extraSpace > 0) {
			    if (sizeLUT[i][j1] < maxFontSize) {
				sizeLUT[i][j1]++;
				extraSpace--;
			    }
			}
			if (extraSpace > 0) {
			    if (spaceLUT[i][j1] < desiredSpace) {
				spaceLUT[i][j1]++;
				extraSpace--;
			    }
			}
			j1--;
		    }
		    if (extraSpace > 0) {
			if (j2 < numItems) {
			    if (sizeLUT[i][j2] < maxFontSize) {
				sizeLUT[i][j2]++;
				extraSpace--;
			    }
			    if (extraSpace > 0) {
				if (spaceLUT[i][j2] < desiredSpace) {
				    spaceLUT[i][j2]++;
				    extraSpace--;
				}
			    }
			    j2++;
			}
		    }
		}
		i1--;
		i2++;
	    }
	}
    }

    // Calculate look-up-table of mouse position => focus index
    focusIndexLUT = new int[height];
    for (i=0; i<numItems; i++) {
	y = borderY;
	for (j=0; j<i; j++) {
	    y += sizeLUT[i][j] + spaceLUT[i][j];
	}
	focusIndexLUT[y] = i;	    
    }
    for (i=1; i<height; i++) {
	if (focusIndexLUT[i] == 0) {
	    focusIndexLUT[i] = focusIndexLUT[i-1];
	}
    }

    // Then, calculate label positions
    char currentLabel = ' ';
    char label;
    int labelY = 0;
    labelLUT = new String[25000];
    labelPosLUT = new int[25000];
    numLabels = 0;
    for (i=0; i < numItems; i++) {
	label = Character.toUpperCase(items[i].label.charAt(0));
	if (currentLabel != label) {
	    y = borderY;
	    for (j=0; j<i; j++) {
		y += sizeLUT[i][j] + spaceLUT[i][j];
	    }
	    y += sizeLUT[i][i];
	    if (y > labelY+maxFontSize+1) {
		labelLUT[numLabels] = new Character(label).toString();
		labelPosLUT[numLabels] = y;
		numLabels++;
		labelY = y;
		currentLabel = label;
	    }
	}
    }
}

    /**
     * Calculate the height of the window needed to render the items with 
     * fisheye distortion using the class variables such as # of elements,
     * max font size, spacing, and focus length, and the 
     * specified minimum font size.
     */
public int calculateWindowHeight(int minFontSize) {
    int height;
    int fl = focusLength;
    int size;
    int space;
    int n = numItems;

    if (minFontSize == maxFontSize) {
				// If whole window in max font, then no fisheye
	height = (int)(n * (maxFontSize + desiredSpace));
	return height;
    }

				// Start with focus area
    if (n < fl) {
	fl = n;
    }
    height = (int)(fl * (maxFontSize + desiredSpace));
    n -= fl;
				// Then, calculate distortion area
    for (size=(maxFontSize-1); size > minFontSize; size--) {
	space = (int)(size * desiredSpacing);
	height += 2*(size + space);
	n -= 2;
	if (n <= 0) {
	    break;
	}
    }

				// Finally, add minimum size area
    height += n * (minFontSize + (int)(minFontSize*minDesiredSpacing));

    height += 2*borderY;

    return height;
}

public void update(Graphics g) {
    paint(g);
}

public void paint(Graphics g) {
    int i;
    int x;
    int y;
    int space;
    int size;
    int fl2;
    boolean antialias = false;
    int width = getSize().width;
    int height = getSize().height;

    Rectangle clipBounds = g.getClipBounds();

				// Allocate back buffer the first time through
    if (backBuffer == null) {
	backBuffer = createImage(width, height);
	gb = backBuffer.getGraphics();
    }
    ((Graphics2D)gb).setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, 
				      RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);
    gb.setClip(clipBounds.x, clipBounds.y, clipBounds.width, clipBounds.height);

				// Fill background
    gb.setColor(backgroundColor);
    gb.fill3DRect(0, 0, width, height, true);

				// Draw FOCUS LOCK background
    y = borderY;
    int y1 = 0;
    int y2 = height - borderY;
    boolean start;
    size = 0;
    if (focusLock) {
	start = true;
	y = flFocusPosition;
	for (i=focusIndex-1; i>=0; i--) {
	    size = flSizeLUT[i];
	    space = flSpaceLUT[i];
	    if (size == minFontSize) {
		y1 = y + size + space;
		break;
	    }
	    y -= size + space;
	}
	y = flFocusPosition;
	for (i=focusIndex; i<numItems; i++) {
	    size = flSizeLUT[i];
	    space = flSpaceLUT[i];
	    if (size == minFontSize) {
		y2 = y;
		break;
	    }
	    y += size + space;
	}
	if (y1 < borderY) {
	    y1 = borderY;
	}
    } else {
	start = true;
	for (i=0; i<numItems; i++) {
	    size = sizeLUT[focusIndex][i];
	    space = spaceLUT[focusIndex][i];
	    if (start) {
		if (size > minFontSize) {
		    y1 = y;
		    start = false;
		}
	    } else {
		if (size == minFontSize) {
		    y2 = y - size;
		    break;
		}
	    }
	    y += size + space;
	}
    }
    gb.setColor(Color.lightGray);


    if (focusLock) {
	gb.fillRect(width/2, y1, width/2-borderRight, y2 - y1);
    } else {
	gb.drawRect(width/2, y1, width/2-borderRight, y2 - y1);
    }

    gb.setColor(Color.white);

    // Then, render items
    x = borderLeft;
    y = borderY;
    if (!focusLock) {
	for (i=0; i<numItems; i++) {
	    size = sizeLUT[focusIndex][i];
	    space = spaceLUT[focusIndex][i];
	    
	    if ((y >= clipBounds.y) && (y <= (clipBounds.y + clipBounds.height))) {
		// Draw focused element with a background hilight
		if (selectionIndex == i) {
		    gb.setColor(hilightColor);
		    gb.fillRect(borderLeft, y, width-(borderLeft+borderRight), size + space);
		    gb.setColor(Color.black);
		} else {
		    gb.setColor(Color.black);
		}
		// Draw item
		if ((size > MAX_ANTIALIAS_SIZE) && antialias) { 
		    ((Graphics2D)gb).setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,
						      RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);
		    antialias = false;
		} else if ((size <= MAX_ANTIALIAS_SIZE) && !antialias) {
		    ((Graphics2D)gb).setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, 
						      RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
		    antialias = true;
		}
		gb.setFont(fonts[size]);
		gb.drawString(items[i].label, x, y+size);
	    }
	    
	    y += space + size;
	}
    } else {
	// FOCUS LOCK mode
	// First render from focus up
	if (focusIndex > 0) {
	    y = flFocusPosition - flSizeLUT[focusIndex-1] - flSpaceLUT[focusIndex-1];
	    for (i=focusIndex-1; i>=0; i--) {
		if (y < borderY) {
		    break;
		}
		size = flSizeLUT[i];
		space = flSpaceLUT[i];
		    
		// Draw focused element with a background hilight
		if (selectionIndex == i) {
		    gb.setColor(hilightColor);
		    gb.fillRect(borderLeft, y, width-(borderLeft+borderRight), size + space);
		}
		gb.setColor(Color.white);
		// Draw item
		if ((size > MAX_ANTIALIAS_SIZE) && antialias) { 
		    ((Graphics2D)gb).setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, 
						      RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);
		    antialias = false;
		} else if ((size <= MAX_ANTIALIAS_SIZE) && !antialias) {
		    ((Graphics2D)gb).setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, 
						      RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
		    antialias = true;
		}
		gb.setFont(fonts[size]);
		gb.drawString(items[i].label, x, y+size);
		    
		if (i > 0) {
		    y -= flSizeLUT[i-1] + flSpaceLUT[i-1];
		}
	    }
	}
	// Then render from focus down
	y = flFocusPosition;
	for (i=focusIndex; i<numItems; i++) {
	    if (y > height-borderY) {
		break;
	    }
	    size = flSizeLUT[i];
	    space = flSpaceLUT[i];
		
				// Draw focused element with a background hilight
	    if (selectionIndex == i) {
		gb.setColor(hilightColor);
	/******	gb.fillRect(borderLeft, y, width-(borderLeft+borderRight), size + space);*******/
	    }
	    gb.setColor(Color.white);
				// Draw item
	    if ((size > MAX_ANTIALIAS_SIZE) && antialias) { 
		((Graphics2D)gb).setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, 
						  RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);
		antialias = false;
	    } else if ((size <= MAX_ANTIALIAS_SIZE) && !antialias) {
		((Graphics2D)gb).setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, 
						  RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
		antialias = true;
	    }
	    gb.setFont(fonts[size]);
	    gb.drawString(items[i].label, x, y+size);
		
	    y += space + size;
	}
    } 
				// Draw alphabetic labels
    gb.setFont(boldFonts[maxFontSize]);
    gb.setColor(labelColor);
    ((Graphics2D)gb).setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, 
				      RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);
    for (i=0; i<numLabels; i++) {
	gb.drawString(labelLUT[i], labelBorderLeft, labelPosLUT[i]);
    }

				// Draw FOCUS LOCK background arrows
    /*if (y1 > borderY) {
	gb.drawImage(up, 3*width/4, y1+5, this);
    }
    if (y2 < height-borderY) {
	gb.drawImage(down, 3*width/4, y2-15, this);
    }*/

				// Swap buffers
    g.drawImage(backBuffer, 0, 0, this);
}
}
import java.util.*;

public class ForceDirect {

    Graphe gr;
    public double time;
    public double temp = 5.0;
    public double minTemp = 3.0;
    public double ae = 2.0, ac = 1.5; 
    public double re = 2.0, rc = 1.5; 
    protected double K, L, D; 
    
    public ForceDirect(Graphe gr, double d ) {
	time = 1.0;
	this.D = d;
	this.L = d*gr.nombreSommets();
	this.K = Math.sqrt(this.L*this.L/gr.nombreSommets() );
    }
    public final double Temp() { return temp; }
    public final void Temp( double d ) { temp = d; }   
    public final double minTemp() { return minTemp;}
    public final void minTemp( double d ) { minTemp = d;}

    protected final double fa(double x) { return ac*Math.pow(x, ae)/K; /* ac*x*x/K;*/ }
    protected final double fr(double x) { return rc*(K*K)/Math.pow(x, re);/* rc* K*K/x;*/ }

    // Temperature du systeme
    protected final double temp(double t) { return (L/(2*D))/(1 + Math.exp(t/8-5));}
    
    protected double energie = 0.0;
    public final double D() { return D; }
    
    public final void D( double d ) { D = d;}
    
    public final void L() { L = D*gr.nombreSommets();}
    
    public double area() { return L*L; }
    public void  K(double kk) {
	this.K = kk;
    }
    public  double  K() {
	return Math.sqrt(area()/gr.nombreSommets() );
    }
    public  double min( double a, double b ) { return (a < b )?a:b; }
    public  double max( double a, double b ) { return ( a > b)?a:b; }
} // class ForceDirect

import java.io.*;
import java.util.*;
import java.awt.*;
import javax.swing.*;

/**
 * Represente un graphe avec un ensemble de sommets et un ensemble d'aretes. 
 * le graphe peut etre simple ou complexe, oriente ou non oriente. La classe 
 * Graphe contient des methodes pour afficher et manipuler des graphes.
 */
class Graphe extends JPanel {
    public Vector sommets;
    public Vector aretes;	
    private boolean oriente;
    private int complexite = 0; // indique le nombre d'aretes avec aretes paralleles
    public boolean multi = false;
    public Sommet centre = null;
    public double[][] matrice;
    public int typeMat = 0;
    public double seuil;
    public double intensite = 1;
    public boolean stress = false;
    public boolean noms = true;
    public boolean masque = false;
    public boolean connexe = false;
    public boolean clustering = false;

    public double maxar = 0;   //  Pour les aretes, maximum des instances du morphing.

    public boolean longs = false; //  affichage des noms longs des sommets
    public boolean sans = true;   //  sans affichage des labels  des sommets 
    
    double maxMetrique1 = 0, maxMetrique2 = 0;
    double minMetrique1 = 0, minMetrique2 = 0;
    double maxArete = 0;
    double maxArete2 = 0;
    double minArete = 0;
    int typeGraphe = 1;
    int rang = 1;
    static final int flag = 0;
    int cercle = 2;
    int instance = 0;
    // **********************************************
    Graphe(int nbsommets) {
	sommets = new Vector(nbsommets);
	aretes = new Vector();
	seuil = 0.0;
    }

    Graphe(Vector sommet, Vector arete ) {
	sommets = sommet;
	aretes = arete;
    } 

    Graphe(boolean oriente)
    {
	sommets = new Vector();
	aretes = new Vector();
	this.oriente = oriente;
	seuil = 0.0;
    }
   
    /**
     * Construit un graphe a partir de sa matrice d'adjacence sous forme d'un fichier texte. 
     */
    public void ChargerMatriceSymetrique( String nom_fichier, int periode ) {
	int M = 0;
	int nb_aretes = 0;
	Point pt = new Point();
	String InstanceFile = nom_fichier.concat(".")+periode;
	instance = periode;
	System.out.println("Lecture des sommets ...." );
	try {
	     
	    File file = new File (InstanceFile);	    
	    Reader rd_result = new FileReader (file); 
	    String ligne_doc = null;
	    LineNumberReader line = new LineNumberReader(rd_result);
	    // Lecture de la premiere ligne du fichier matrice pour generer les sommets
            ligne_doc = line.readLine();
	    StringTokenizer labc = new StringTokenizer(ligne_doc);
	    String lab = labc.nextToken();
	    while ( lab != null  && !lab.equals("CLASSE") ) {
		// Creation du sommet correspondant a la colonne en cours 
		pt.x = 10 + (int)(480*Math.random() );
		pt.y = 10 + (int)(480*Math.random() );
	
		Sommet s = new Sommet(pt.x, pt.y, lab.toLowerCase() );
		s.type = 1;
		s.metrique = 0;
		ajouterSommet(s);

		try {
		    lab = labc.nextToken();
		} catch (NoSuchElementException ex) {
		    break;
		}
		M++;
	    }
	    System.out.println(M + " sommets définis ");
	    matrice = new double[M][M];
	    line.close(); // fin de lecture du fichier

	    // a ce stade, nous avons cree tous les (M) sommets du graphe
	    // prochaine etape : creation des aretes entre ces sommets
	    // lecture du fichier ligne par ligne
	    if ( instance > 1 ) multi = true;

	    for ( int inst = 1; inst <= instance; inst++ ) {
		InstanceFile = nom_fichier.concat(".")+inst;
		System.out.println("Traitement du fichier : " + InstanceFile);

		file = new File (InstanceFile);
		rd_result = new FileReader (file);
		line = new LineNumberReader(rd_result);

		ligne_doc = line.readLine();
		ligne_doc = line.readLine();
		
		int l = 0; // compteur sur les lignes
		// Traitement d'une ligne du fichier
		while ( ligne_doc != null && l < M ) {
		    int k = line.getLineNumber() - 2;
		    Sommet s = getSommet(l);
		    s.Metrique[inst] = 0.0;
		    int j = 0; // compteur sur les colonnes
		    StringTokenizer label = new StringTokenizer(ligne_doc);
		    String str = label.nextToken();

		    while ( label.hasMoreTokens() && j < M ) {
			// lecture des valeurs dans la ligne courante <=> des liens
			Sommet ss = getSommet(j);
			str = label.nextToken();
			str = str.replace(',', '.');
			try {
			    double val = Double.parseDouble(str);
			    if ( val != 0.0 ) {

				if ( s.Metrique[inst] <= val ){
				    s.Metrique[inst] = val;
				}

				if ( l <= j ) {
				    int indice = areteDansGraphe( s, ss );
				    if ( indice != -1 ) {
					Arete a = getArete(indice);
					a.addVal(val);
					a.setValInstance(val, inst);
				    if (val==16.0 && inst!=1) System.out.println("on a atteind 16");
				    for (int i=0; i<=inst; i++){
				      if (maxar<val) maxar=val;
				    }
					String nom;
					val = a.getVal();
					if ( val < 1.0 )  nom = String.valueOf(val);
					else  nom = String.valueOf((int)val);
					a.setNom(nom);

				    } else if ( !s.equals(ss) ) {
					Arete a = new Arete( s, ss, s.x, ss.x, null,
							     val, nb_aretes++ );
					ajouterArete(a);
					a.setValInstance( val, inst );
					String nom;
					val = a.getVal();
					if ( val < 1.0 )  nom = String.valueOf(val);
					else  nom = String.valueOf((int)val);
					a.setNom(nom);
					}
				    }
				}

			}

			catch ( NumberFormatException ex ) {
			    System.out.println("Lecture de la matrice : Format des valeurs incompatible");
			}
			j++;
		    }
		    l++;
		    ligne_doc = line.readLine();
		}
		line.close(); // fin de lecture du fichier
	    }
	}
	catch( IOException e2 ) {
	    System.err.println(e2); System.exit(1);
	    
	}
	catch (NullPointerException e3  ) {
	    System.out.println("\nNullPointerException dans multi: " + e3 );
	}
	double max = 0.0;
	int k = 1;
	for (int j = 0; j < nombreSommets(); j++ ) {
	    Sommet v =  getSommet(j);
	    v.metrique = 0.0;
	    for ( k = 1; k <= periode ; k++ ) {
		if ( v.metrique <= v.Metrique[k] ) 
		    v.metrique = v.Metrique[k];
		if ( max <= v.Metrique[k] ) max = v.Metrique[k]; 
	    }	   
	}
	
	for (int j = 0; j < nombreSommets(); j++ ) {
	    Sommet v =  getSommet(j);
	   v.Metrique[periode+1] = max;
	}
	System.out.println( "\n\n" );	
	cercle = 0;
	System.gc();
	maximumArete();



    }


    /**
     * Construit un graphe a partir de sa matrice sous forme d'un fichier texte. 
     */
    public void ChargerMatriceAsymetrique( String nom_fichier, int periode ) {
	int M = 0;
	int N = 0;
	Point pt = new Point();
	double max = 0.0;
	String InstanceFile = nom_fichier.concat(".")+periode;
	instance = periode;
	try {
	    File file = new File (InstanceFile);
	    Reader rd_result = new FileReader (file);
	    String ligne_doc = null;
	    LineNumberReader line = new LineNumberReader(rd_result);
	    ligne_doc = line.readLine();

	    StringTokenizer labc = new StringTokenizer(ligne_doc);
	    String lab = labc.nextToken();
	    while ( lab != null  && !lab.equals("CLASSE") ) {
		pt.x = 10 + (int)(480*Math.random() );
		pt.y = 10 + (int)(480*Math.random() );
		// Creation du sommet correspondant a la colonne en cours
		Sommet s = new Sommet(pt.x, pt.y, lab );
		s.type = 0;
		s.metrique = 0;
		ajouterSommet(s);
		try{
		    lab = labc.nextToken();
		} catch (NoSuchElementException ex) {
		    break;
		}
		N++;
	    }
	    System.out.println("Fin de lecture des " + N + " sommets en colonnes.... " );

	    // determination du nombre de lignes dans la matrice
	    while ( (ligne_doc = line.readLine()) != null ) {
		labc = new StringTokenizer(ligne_doc);
		lab = labc.nextToken();
		pt.x = 10 + (int)(480*Math.random() );
		pt.y = 10 + (int)(480*Math.random() );
		// Creation du sommet correspondant a la ligne en cours
		Sommet s = new Sommet(pt.x, pt.y, lab );
		s.type = 1;
		s.metrique = 0;
		ajouterSommet(s);
		M++;	    
	    }
	    line.close();
	 
	    System.out.println("Fin de lecture des " + M + " sommets en lignes.... " );
	    //matrice = new double[M][N];	  
	  
	    // a ce stade, nous avons cree tous les (N) sommets "colonnes" et sommets "lignes"
	    // prochaine etape : creation des aretes entre ces sommets

	    // lecture des lignes de la matrice ligne par ligne
	    for ( int inst = 1; inst <= instance; inst++ ) {
		InstanceFile = nom_fichier.concat(".")+inst;
		System.out.println("Traitement du fichier : " + InstanceFile);
		
		file = new File (InstanceFile);
		rd_result = new FileReader (file);
		line = new LineNumberReader(rd_result);
		
		ligne_doc = line.readLine();
		ligne_doc = line.readLine();
		int nb_aretes = 0;
		int l = 0;   // leme ligne <=> leme sommet du graphe

		// lecture des cases de chaque ligne (case par case)
		while ( ligne_doc != null ) {
		   
		    StringTokenizer ligne = new StringTokenizer(ligne_doc);
		    lab = ligne.nextToken(); 
		    int j = 0;
		    Sommet s = getSommet(N+l); // N+l sommet dont le label=lab 
		    
		    while ( ligne.hasMoreTokens() && j < N  ) {
			Sommet ss = getSommet(j); // jieme colonne

			String str = ligne.nextToken();
			str = str.replace(',', '.');
			try {
			    double val = Double.parseDouble(str);
			    // une case non nulle => creation d'une arete
			    if ( val != 0.0 ) {
				if ( s.Metrique[inst] <= val )
				    s.Metrique[inst] = val;

				if ( ss.Metrique[inst] <= val )
				    ss.Metrique[inst] = val;
				if ( max <= val ) max = val;

				int indice = areteDansGraphe( s, ss );
				if ( indice != -1 ) {
				    Arete a = getArete(indice); 
				    a.addVal(val);
				    a.setValInstance(val, inst);
				    String nom;
				    val = a.getVal();
				    if ( val < 1.0 )
					nom = String.valueOf(val);
				    else 
					nom = String.valueOf((int)val);
				    a.setNom(nom);
				} else {
				    Arete a = new Arete( s, ss, s.x, ss.x, null, val, nb_aretes++ );
				    ajouterArete(a);
				    a.setValInstance(val, inst);
				    
				    String nom;  
				    val = a.getVal();
				    if ( val < 1.0 ) 
					nom = String.valueOf(val);
				    else
					nom = String.valueOf((int)val);
				    a.setNom(nom);
				}
			    }
			} catch (NumberFormatException ex) {
			    System.out.println ("Lecture de la matrice : Format des valeurs incompatible");
			}
			j++;
		    }
		    l++;
		    ligne_doc = line.readLine();
		}
		line.close(); // fin de lecture du fichier
	    }
	}
	catch( IOException e2 ) {
	    System.err.println(e2); System.exit(1);
	}
	catch (NullPointerException e3  ) {
	    System.out.println("\nNullPointerException : " + e3 );
	}

	int k = 1;
	for (int j = 0; j <  nombreSommets(); j++ ) {
	    Sommet v =  getSommet(j);
	    v.metrique = 0.0;
	    for ( k = 1; k <= periode; k++ ) 
		if ( v.metrique <= v.Metrique[k] ) 
		    v.metrique = v.Metrique[k];	    
	}

	for (int j = 0; j <  nombreSommets(); j++ ) {
	    Sommet v =  getSommet(j);
	    v.Metrique[periode+1] = max;	   
	}
	
	cercle = 1;
	System.gc();  
	maximumArete();
    }
    
    public void ChargerGraphe( String nom_fichier) {
	int M = 0;
	
	try {
	    File file = new File (nom_fichier);
	    
	    Reader rd_result = new FileReader (file);
	    
	    String ligne_doc = null;
	    LineNumberReader line = new LineNumberReader(rd_result);
	    // calcul du nombre de lignes de la matrice (fichier)
            while ( (ligne_doc = line.readLine()) != null )
		M++;
	    M--;
	    
	    file = new File (nom_fichier);
            rd_result = new FileReader (file);

 	    line = new LineNumberReader(rd_result);

	    // lecture de fichier ligne par ligne
	    ligne_doc = line.readLine();
	    ligne_doc = line.readLine();
	    int l = 0;

	    while ( ligne_doc != null && l < M) {
		l++;
		int j = 0;
		int k = line.getLineNumber() - 2;
		StringTokenizer label = new StringTokenizer(ligne_doc);
		String lab = label.nextToken();

		Point pt = new Point();
		pt.x = 10 + (int)( 480*Math.random() );
		pt.y = 10 + (int)( 480*Math.random() );
		Sommet s = new Sommet(pt.x, pt.y, lab );
		s.x = pt.x;
		s.y = pt.y;
		ajouterSommet(s);
		s.type = 1;
		s.metrique = 0;
		
		while ( label.hasMoreTokens() && j < M  ) {
		    // chargement de la ligne de la matrice d'instance 0
		    String str = label.nextToken();
		    str = str.replace(',', '.');
		    try {
			double a = Double.parseDouble(str);
			matrice[k][j] = a;
			if ( s.Metrique[0] <= a ) s.Metrique[0] = a;
			if ( s.metrique <= a) s.metrique = a; // metrique = maximum de la ligne k
			j++;
		    }
		    catch (NumberFormatException ex) {
			System.out.println("Lecture de la matrice : Format des valeurs incompatible");
		    }
		}
		ligne_doc = line.readLine();
	    }
	    line.close();
	}
	catch( IOException e2 ) {
	    System.err.println(e2); System.exit(1);

	}
	catch (NullPointerException e3  ) {
	    System.out.println("\nNullPointerException dans isntance 0: " + e3 );
	}
	System.gc();
	maximumArete();
    }
    public boolean isEmpty() { return ( sommets.size() == 0); }
    public int nombreSommets() { return sommets.size(); }
    public int nombreAretes() { return aretes.size(); }
    public Sommet getSommet(int i) { return (Sommet)sommets.elementAt(i); }
    public Arete getArete(int i) { return (Arete)aretes.elementAt(i); }
    public boolean getOriente() { return oriente; }
    /**
     * ajoute un sommet dans le graphe. La methode verifie si aucun 
     * sommet de l'ensemble des sommets du graphe n'est equivalent au sommet
     * a ajouter, puis fait l'ajout si ce n'est pas le cas.
     @param sommet le sommet a ajouter
    */
   
    public void ajouterSommet(Sommet sommet)
    {
	for (int i = 0; i < sommets.size(); i++)
	    if (sommet.equals((Sommet)sommets.elementAt(i)))
		return;
	sommets.addElement(sommet);
    }
    
    /**
     * ajoute un ensemble de sommets.
     @param sommetsA sommets a ajouter
    */
    public void ajouterSommets(Sommet[] sommetsA)
    {
	for (int i = 0; i < sommetsA.length; i++)
	    ajouterSommet(sommetsA[i]);
    }
    
    /**
     * Ajoute une arete dans le graphe. La methode verifie si l'arete se trouve 
     * deja dans le graphe avant d'effectuer l'ajout.
     @param arete arete a ajouter
    */
    public void ajouterArete(Arete arete)
    {
	for (int i = 0; i < aretes.size(); i++)
	    if ((oriente && arete.equalsOriented((Arete)aretes.elementAt(i))) ||
		(!oriente && arete.equals((Arete)aretes.elementAt(i))))
		return;
	ajouterSommet(arete.getE1());
	ajouterSommet(arete.getE2());
	for (int i = 0; i < sommets.size(); i++) {
	    Sommet s = (Sommet)sommets.elementAt(i);
	    if ( s.equals(arete.getE1()) )
		arete.setE1(s);
	    else if ( s.equals(arete.getE2()) )
		arete.setE2(s);
	}
	Sommet s1 = arete.getE1();
	Sommet s2 = arete.getE2();
	int mx = (s1.getX()+s2.getX())/2;
	int my = (s1.getY()+s2.getY())/2;
	int p = 0;
	for ( int i = 0; i < aretes.size(); i++ ) {
	    Arete a = (Arete)aretes.elementAt(i);
	    if ( a.paralleleA(arete, false) && a.getID() != arete.getID() )
		p++;
	}
	my += 4*Sommet.RAYON*p*(int)Math.pow(-1.0,p+1);
	arete.setXY(mx,my);
	aretes.addElement(arete);
	
	if (p > 0 ) complexite++;
    }

    /**
     * ajoute un ensemble d'aretes.
     @param aretesA aretes a ajouter
    */
    public void ajouterAretes(Arete[] aretesA)
    {
	for (int i = 0; i < aretesA.length; i++)
	    ajouterArete(aretesA[i]);
    }
    
    /**
     * ajoute un graphe dans ce graphe.
     @param graphe le graphe a ajouter
    */
    public void ajouterGraphe(Graphe graphe)
    {
	int ns = graphe.nombreSommets();
	for (int i = 0; i < ns; i++)
	    ajouterSommet(graphe.getSommet(i));

	int na = graphe.nombreAretes();
	for (int i = 0; i < na; i++) 
	    ajouterArete(graphe.getArete(i));
    }


    /**
     * Calcule le degre d'un sommet d'indice "indice" dans le 
     * graphe. Le degre constitue le nombre d'aretes liees a ce sommet.
     @param indice l'indice du sommet dont on cherche le degre
     */
    public int degre(int indice)
    {
	Sommet s = (Sommet)sommets.elementAt(indice);
	int deg = 0;
	for (int i = 0; i < aretes.size(); i++) {
	    Arete a = (Arete)aretes.elementAt(i);
	    if ( a.getVisible() ) {
		Sommet s1 = a.getE1();
		Sommet s2 = a.getE2();
		
		if ( s.equals( s1) )
		    deg++;	    
		if ( s.equals(s2) )
		    deg++; 
	    }
	}
	return deg;
    }
    public void initDegre() {
	int ns = this.nombreSommets();
	for (int i = 0; i < ns; i++) {
	    Sommet s = this.getSommet(i);
	    s.setDegre((int)degre(i)/2);
	}
    }

    /**
     * Calcule le demi-degre interieur d'un sommet. Ce qui constitue le nombre 
     * d'aretes entrant dans ce sommet. La methode lance une exception si le 
     * graphe n'est pas oriente.
     @param indice indice du sommet dont on cherche le demi-degre interieur
     @exception NotOrientedGraphException
    */
    public int demiDegreInterieur(int indice)
    {
	if (!oriente)
	    throw new NotOrientedGraphException("Cannot calculate half-degrees");
	
	Sommet s = (Sommet)sommets.elementAt(indice);
	int deg = 0;
	for (int i = 0; i < aretes.size(); i++) {
	    Arete a = (Arete)aretes.elementAt(i);
	    if (s.equals(a.getE2()))
		deg++;
	}
	return deg;	
    }
    
    /**
     * Calcule le demi-degre exterieur d'un sommet. Ce qui constitue le nombre 
     * d'aretes sortant dans ce sommet. La methode lance une exception si le 
     * graphe n'est pas oriente.
     @param indice indice du sommet dont on cherche le demi-degre exterieur
     @exception NotOrientedGraphException
    */
    public int demiDegreExterieur( Sommet s )
    {
	if ( !oriente )
	    throw new NotOrientedGraphException(" graphe non oriente !!");
	
	//Sommet s = (Sommet)sommets.elementAt(indice);
	int deg = 0;
	for ( int i = 0; i < aretes.size(); i++ ) {
	    Arete a = (Arete)aretes.elementAt(i);
	    if ( s.equals(a.getE1()) )
		deg++;
	}
	return deg;	
    }
    public Sommet pere(Sommet s)
    {
	Sommet pere = null;
	if ( !oriente )
	    throw new NotOrientedGraphException("graphe non oriente !!");
	for ( int i = 0; i < aretes.size(); i++ ) {
	    Arete a = (Arete)aretes.elementAt(i);
	    Sommet s1 = a.getE1();
	    Sommet s2 = a.getE2();
	    
	    if ( s.equals(s2) ) 
		pere = s1;
	    
	} return pere;
	
    }
    /**
     * Retire le sommet du graphe ainsi que toutes ses aretes incidentes.
     @param indice indice du sommet a supprimer
    */
    public void supprimerSommet(int indice) {
	Sommet s = (Sommet)sommets.elementAt(indice);
	int[] ind = new int[aretes.size()];
	int indi = 0;
	for (int i = 0; i < aretes.size(); i++) {
	    Arete a = (Arete)aretes.elementAt(i);
	    if ( s.equals(a.getE1()) || s.equals(a.getE2()) )
		ind[indi++] = i;
	}
	for (int i = indi-1; i >= 0; i--)
	    supprimerArete(ind[i]);
	
	sommets.removeElementAt(indice);
    }
    
    /**
     * Retire l'arete du graphe.
     @param indice indice de l'arete a retirer
    */
    public void supprimerArete(int indice) {
	Arete a = (Arete)aretes.elementAt(indice);
	int p = 0;
	for (int i = 0; i < aretes.size(); i++) {
	    Arete a2 = (Arete)aretes.elementAt(i);
	    if (a == a2)
		continue;
	    if (a.paralleleA(a2,false) && a.getID() != a2.getID())
		p++;
	}
	if (p == 1)
	    complexite--;
	aretes.removeElementAt(indice);
    }
    
    
    /**
     * Teste si le graphe est simple ou non. Pour ce faire, la methode 
     * verifie s'il y a des aretes paralleles ou des boucles. S'il n'y en a aucune, 
     * le graphe est simple
     @return le resultat du test de simplicite du graphe
    */
    public boolean grapheSimple()
    {
	if (complexite > 0)
	    return false;
	for (int i = 0; i < aretes.size(); i++) {
	    Arete a = (Arete)aretes.elementAt(i);
	    if (a.getE1().equals(a.getE2()))
		return false; // Une boucle a ete trouvee.
	}
	return true;
    }
    
    /**
     * Convertit le graphe en chaine affichable
     @return chaine representant l'objet
    */
    public String toString()
    {
	String str = "Graphe: (";
	str += "Sommets: (";
	for (int i = 0; i < sommets.size(); i++) {
	    if (i > 0)
		str += ", ";
	    str += sommets.elementAt(i);
	}
	str += "), Aretes: (";
	for (int i = 0; i < aretes.size(); i++) {
	    if (i > 0)
		str += ", ";
	    str += aretes.elementAt(i);
	}
	str += "))";
	return str;
    }
    
    /**
     * Retourne le graphe sous-jacent d'un graphe oriente ou un graphe non oriente 
     * construit a partir d'un graphe non oriente. 
     @return objet Graphe resultant de la methode
    */
    public Graphe sousJacent()
    {
	Graphe gr = new Graphe(!oriente);
	gr.ajouterGraphe(this);
	return gr;
    }
    
    /**
     * Retourne l'indice d'un sommet. Si ce sommet ne fait pas partie du graphe, 
     * retourne -1. Les comparaisons sont effectuees avec le test 
     * d'egalite et non pas avec l'operateur ==.
     */
    public int indiceSommet(Sommet s)
    {
	if (s == null)
	    return -1;
	for (int i = 0; i < sommets.size(); i++) {
	    Sommet s2 = (Sommet)sommets.elementAt(i);
	    if ( s2.equals(s) )
		return i;
	}
	return -1;
    }
    
    /*
     * Retourne l'indice d'une arete du graphe. Si l'arete ne fait pas partie du graphe, 
     * la methode retourne -1.
     */
    public int indiceArete(Arete a)
    {
	if (a == null)
	    return -1;
	for (int i = 0; i < aretes.size(); i++) {
	    Arete a2 = (Arete)aretes.elementAt(i);
	    if (a2.equals(a))
		return i;
	}
	return -1;
    }
    

    /**
     * Teste si une arete definie par deux sommets fait partie du graphe
     */
    public int areteDansGraphe(Sommet s1, Sommet s2 ) {
	for (int i = 0; i < nombreAretes(); i++) {
	    Arete arete = getArete(i);
	    Sommet s_or = arete.getE1();
	    Sommet s_ar = arete.getE2();
	    if ( ( s1.equals(s_or) && s2.equals(s_ar) ) || 
		 ( s2.equals(s_or) && s1.equals(s_ar) )  )
		return i;
	    
	}
	return -1;
    }
    public int areteDansGraphe(Arete a ) {
	for (int i = 0; i < nombreAretes(); i++) {
	    Arete arete = getArete(i);
	    if ( a.equals(aretes) )		
		return i;	    
	}
	return -1;
    }
    /**
     * methode utilisee pour obtenir un objet Point qui contiendra 
     * des coordonnes aleatoires non occupees par un autre sommet du graphe.
     @param maxw longueur de la zone de selection
     @param maxh largeur de la zone de selection
     @return point choisi aleatoirement
     */
    public Point nouvellePosition(int maxw, int maxh)
    {
	if (maxw <= 0 || maxh <= 0) {
	    maxw = getSize().width;
	    maxh = getSize().height;
	    throw new IllegalArgumentException("la taille de la fenêtre doit être positive.");
	    
	}
	Random generator = new Random();
	Point pt;
	do {
	    pt = new Point(Math.abs(generator.nextInt()) % maxw,
			   Math.abs(generator.nextInt()) % maxh);
	}
	while (hitTest(pt, true) != null);
	return pt;
    }
    
    /**
     * Effectue un test de tous les sommets afin de savoir quel sommet se trouve en un 
     * point donne, ou dans son voisinage.
     @param pt point a tester
     @param large teste au voisinage des coordonnees du sommet, permettant ainsi une gestion d'un 
     *            clic de souris
     @return sommet se trouvant au point teste, null s'il ne s'y trouve aucun sommet
     */
    public Sommet hitTest( Point pt, boolean large )
    {
	for ( int i = 0; i < sommets.size(); i++ ) {
	    Sommet s = getSommet(i);
	    if ( s.getVisible()) {
		if (large) {
		    double dist = Math.sqrt(Math.pow(pt.x - s.getX(), 2.0)+
					    Math.pow(pt.y - s.getY(), 2.0));
		    if ( dist <= 10 )
			return s;
		} else {
		    if ( s.getX() == pt.x && s.getY() == pt.y  )
			return s;
		}
	    }
	}
	return null;
    }
    
    /**
     * retourne l'etiquette d'une arete du graphe apres l'avoir convertie 
     * en une valeur numerique.
     @param indice indice de l'arete a traiter
     @return etiquette convertie en valeur numerique, -1 si la conversion n'est pas possible.
     */
    public double nGetArete(int indice)
    {
	try {
		//return Integer.parseInt(getArete(indice).getNom());
	    return getArete(indice).getVal();
	    }
	catch (NumberFormatException e) {
		return -1;
	    }
    }

    /**
     * retourne l'etiquette d'un sommet du graphe apres l'avoir convertie en valeur numerique.
     @param indice indice du sommet a traiter
     @return etiquette du sommet en valeur numerique, -1 si la conversion est impossible.
     */
    public int nGetSommet(int indice)
    {
	try {
		return Integer.parseInt(getSommet(indice).getNom());
	    }
	catch (NumberFormatException e) {
		return -1;
	    }
    }
    /**
     * Affiche le graphe sur un contexte d'affichage, sans toutefois verifier
     * si la surface d'affichage est suffisamment grande pour contenir tout le graphe.
     * Aucune verification n'est faite pour savoir si du texte des etiquettes se
     * chevauchent.
     @param g contexte d'affichage a utiliser
    */
    public void reordonner(Sommet s, int w, int h ) {

	int x = s.getX();
	int y = s.getY();

	if ( x <= 0 &&  y <= 0 ) {
	    s.x = 40; s.y = 10; }
	else
	    if ( x <= 0 &&  y > h-80 ) {
		s.x = 40; s.y = h-80; }
	    else 
		if ( x > w &&  y > h-80 ) { 
		    s.x = w-40;  s.y = h-80; }
		else 
		    if ( x > w &&  y < 0 ) {
		    s.x = w-40;  s.y = 10; }
		else if ( x > 0 && x < w  && y <= 0 ) { 
		    s.x = x ; s.y = 10; }
		else if ( x <= 0 &&  y > 0 && y < h ) { 
		    s.x = 40; s.y = y;  }
		else if  ( x > 0 &&  x < w && y > h ) { 
		    s.x = x; s.y = h-80; } 
		else if  ( x > w && y < h ) { 
		    s.x = w-20; s.y = y ; }
		else { 
		    s.x = x; s.y = y ; }
		
    }
    public void maximumMetrique(int instance) {
	maxMetrique1 = 0.0;
	maxMetrique2 = 0.0;
	for ( int i = 0; i < sommets.size(); i++) {
	    Sommet s = getSommet(i);
	    if ( maxMetrique1 <= s.Metrique[instance] && s.type == 1 && s.getVisible() ) // maximum sur les lignes
		maxMetrique1 = s.Metrique[instance];	    
	    if ( maxMetrique2 <= s.Metrique[instance] && s.type == 0 && s.getVisible() ) // maximum sur les colonnes
		maxMetrique2 = s.Metrique[instance]; 
	}
	//System.out.println(" maxMetrique1 = " + maxMetrique1 + "\nmaxMetrique2 = " + maxMetrique2);
    }
    public void maximumMetrique() {
	double max1 = 0.0, max2 = 0.0;
	double min1 = 999999, min2 = 999999;
	double cl = 0.0;

	for (int i = 0; i < sommets.size(); i++) {
	    Sommet s = getSommet(i);
	    if ( max1 <= s.metrique && s.type == 1 && s.getVisible() ) // maximum sur les lignes
		max1 = s.metrique;	    
	    if ( max2 <= s.metrique && s.type == 0 && s.getVisible() ) // maximum sur les colonnes
		max2 = s.metrique;
	}

	for ( int i = 0; i < sommets.size(); i++ ) {
	    Sommet s = getSommet(i);
	    if ( s.getVisible() ) {
		if ( typeMat == 0 ) {
		    if ( s.type == 1 ) {
			cl = (double)(s.metrique )/(double)(max1);
			cl = (double)(1 + Math.pow(cl, 1/2) - Math.pow((1 - cl), 2 ))/2;
			s.couleur = new Color( (int)(255*cl), 0, 0 );
		    }
		    else {
			cl = (double)(s.metrique )/(double)(max2);
			cl = (double)(1 + Math.pow(cl, 1/2) - Math.pow((1 - cl), 2 ))/2;
			s.couleur = new Color( 0, (int)(255*cl), 0 );
		    }
		} else 
		    if ( s.type == 1 ) {
			cl = (double)((double)(s.metrique)/(double)max1);
			cl = (double)(1 + Math.pow(cl, 1/2) - Math.pow((1 - cl), 2 ))/2;
			s.couleur = new Color( (int)(255*cl), 0, 0 );
		    }
	    }
	}
	maxMetrique1 = max1;
	maxMetrique2 = max2;

    }
    public void maximumArete() {

	double maxi = 0;
	double min = 999999;
  //   if (instance == 1){
	for (int i = 0; i < aretes.size(); i++) {
	    Arete a = getArete(i);
	    if ( maxi < a.getVal() && a.getVisible() )  maxi = a.getVal();
	    if ( min  > a.getVal() && a.getVisible() )  min  = a.getVal();
	}

	maxArete = maxi;
	minArete = min;
    }

    /* Calcule le degre d'un sommet dans un graphe donne */

    public int getDegre(Sommet s) {
	this.getVoisins(s, true, this.seuil );
	return(s.voisins.size());

    }

    /* Attribue une couleur pour chaque arete en fonction de sa valeur dans l'intervalle
       des valeurs [min, max] et de l'intensité utilisee. Gere aussi la couleur des aretes dans le morphing
    */
    public synchronized void SetCouleursAretes(double intensite ) {
  	double cl = 0.0;
	double metrique= 0.0;
	double res = 0.0;
	res = maxArete / maxar;
	for ( int i = 0; i < aretes.size(); i++ ) {
	    /* Pour chaque arete, on va prendre la valeur de l'arete (y compris celle additionnant les autres instances) et
	       on va la normaliser de facon à trouver un juste équilibre dans l'affichage, au niveau intensité */
	    Arete a = (Arete)aretes.elementAt(i);
	    if ( a.getVisible()) {
               metrique = (double)(a.getVal()/maxArete);
               cl = (double)( 1.0 + Math.pow(1 - metrique, intensite)- Math.pow(metrique, 1/intensite ) )/2.0;
	       /* on regle l'intensité d'affichage. C'est ici que se gère la différence d'intensité du slider intensite */
	       int v = (int)(250 - 200*cl);
	       a.setCouleur(new Color( v, v, v ));
	    }
	}
    }

    public void paintComponent(Graphics g, int param) {
    	super.paintComponent(g);

	this.SetCouleursAretes(this.intensite);
	for ( int i = 0; i < aretes.size(); i++ ) {
	    Arete a = (Arete)aretes.elementAt(i);
	    a.afficher( g, false, oriente, a.getCouleur() );
	}

	for ( int i = 0; i < sommets.size(); i++ ) {
	    Sommet s = (Sommet)sommets.elementAt(i);
	    if ( typeGraphe == 1 ) {
		if ( s.type == 1 )
		    s.afficher( g, sans, maxMetrique1, longs, cercle, clustering, rang, param );
		if ( s.type == 0 ) 
		    s.afficher( g, sans, maxMetrique2, longs, cercle, clustering, rang, param ); 
	    }
	    else { // typeGraphe == 2 
		if ( s.type == 1 )	
		    s.afficherInstances( g, sans, longs, maxMetrique1, instance, clustering);
		if ( s.type == 0 )
		    s.afficherInstances( g, sans, longs, maxMetrique2, instance, clustering );
	    }
	}
	if ( stress )
	    for ( int i = 0; i < aretes.size(); i++ ) {
		Arete a = (Arete)aretes.elementAt(i);
		a.afficherValeur( g );
	    }	
    }
  
    public void getVoisins( Sommet autre, boolean flag, double seuil ) {
	int na =  aretes.size();
	int j = 0;
	autre.voisins = new Vector();

	for (int i = 0; i < na; i++ ) {
	    Arete a = (Arete)aretes.elementAt(i);

	    Sommet s1 = a.getE1();
	    Sommet s2 = a.getE2();
	    if ( a.getVal() >= seuil ) {
		if ( !flag ) {  // graphe non orienté
		    if ( autre.equals(s1) && !autre.voisins.contains(s2) ) {
			autre.voisins.addElement(s2);
			j++;
		    }
		    else if ( autre.equals(s2) && !autre.voisins.contains(s1) ) {
			j++;
			autre.voisins.addElement(s1);
		    }
		    autre.voisins.setSize(j);
		} else  {      // graphe  orienté
		    if ( autre.equals(s1) && !autre.equals(s2) &&
			 !autre.voisins.contains(s2)) {
			autre.voisins.addElement(s2);
			j++;
		    }
		    autre.voisins.setSize(j);
		}
	    }
	}
    } // fin getVoisins

    // Algorithme Prim pour determiner un MST : Maximal Spanning Tree
    public Graphe determineArbrePrim() {
	Graphe arbre = new Graphe(false);
	Vector sommets_depart = new Vector();
	Vector sommets_arrivee = new Vector();
	int indice = 0;
	double maxi = 0.0;
	Arete grande_arete = null;
	
	// recherche de la plus grande arete
	for (int i = 0; i < aretes.size(); i++) {
	    Arete a = ((Arete)aretes.elementAt(i));
	    if ( a.getVal() > maxi ) {
		maxi = a.getVal();
		grande_arete = a;
	    }
	}
	for (int i = 0; i < sommets.size(); i++) {
	    Sommet s = getSommet(i);
	    sommets_arrivee.addElement(s);		
	}

	Sommet s1 = grande_arete.getE1();
	Sommet s2 = grande_arete.getE2();

	sommets_depart.addElement(s1);
	sommets_depart.addElement(s2);

	sommets_arrivee.removeElement(s1);
	sommets_arrivee.removeElement(s2);

	grande_arete.marked = true;
	arbre.ajouterArete(grande_arete);
	// s1.fixe = true;
	// s2.fixe = true;

	while ( !sommets_arrivee.isEmpty() ) {
	    Arete areteMax = null;
	    int sens = 0;
	    double max = 0.0;
	    for ( int i = 0; i < nombreAretes() ; i++ ) {
		Arete arete = getArete(i);
		
		if ( arete.getVisible() && !arete.marked ) {
		    s1  = arete.getE1();
		    s2  = arete.getE2();
		    if ( sommets_depart.contains(s1)  && !sommets_arrivee.contains(s1) &&
			 sommets_arrivee.contains(s2) && !sommets_depart.contains(s2)  &&
			 s1.getVisible() && s2.getVisible() && arete.getVal() >= max ) {
			max = arete.getVal();
			areteMax = arete;
			sens = 1;
		    } else 
			if ( sommets_depart.contains(s2)  && !sommets_depart.contains(s1)  && 
			     sommets_arrivee.contains(s1) && !sommets_arrivee.contains(s2) &&
			     s1.getVisible() && s2.getVisible() && arete.getVal() >= max ) {
			    max = arete.getVal();
			    areteMax = arete;
			    sens = 2;
			}
		}
	    }
	    
	    if ( areteMax != null ) {
		if ( sens == 1 ) {
		    sommets_depart.addElement(areteMax.getE2());
		    sommets_arrivee.removeElement(areteMax.getE2());
		    
		} 
		if ( sens == 2 ) {
		    sommets_depart.addElement(areteMax.getE1());
		    sommets_arrivee.removeElement(areteMax.getE1());
		} 
		areteMax.marked = true;
		areteMax.setVisible();
		arbre.ajouterArete(areteMax);
		
	    } else {
		System.out.println(" Le Graphe n'est pas connexe" );
		return (this);
	    }
	}
	arbre.maximumArete();
	arbre.stress = this.stress;
	arbre.noms = this.noms;
	
	return (arbre);
    }


    
    // Algorithme Prim pour determiner un MST : Minimal Spanning Tree
    public Graphe determineArbrePrim2() {
	Graphe arbre = new Graphe(false);
	Vector sommets_depart = new Vector();
	Vector sommets_arrivee = new Vector();
	int indice = 0;
	double mini = 999999.0;
	Arete petite_arete = null;
	// recherche de la plus petite arete
	for (int i = 0; i < aretes.size(); i++) {
	    Arete a = ((Arete)aretes.elementAt(i));
	    if ( a.getVal() < mini ){
		mini = a.getVal();
		petite_arete = a;
	    }
	}
	for (int i = 0; i < sommets.size(); i++) {
	    Sommet s = getSommet(i);
	    sommets_arrivee.addElement(s);		
	}
	Sommet s1 = petite_arete.getE1();
	Sommet s2 = petite_arete.getE2();

	sommets_depart.addElement(s1);
	sommets_depart.addElement(s2);

	sommets_arrivee.removeElement(s1);
	sommets_arrivee.removeElement(s2);

	petite_arete.marked = true;
	arbre.ajouterArete(petite_arete);
	// s1.fixe = true;
	// s2.fixe = true;

	while ( !sommets_arrivee.isEmpty() ) {
	   
	    Arete areteMin = null;
	    int sens = 0;
	    double min = 999999.0;
	    for ( int i= 0; i < nombreAretes() ; i++ ) {
		Arete arete = getArete(i);
		s1  = arete.getE1();
		s2  = arete.getE2();
		if ( sommets_depart.contains(s1)  && !sommets_arrivee.contains(s1) &&
		     sommets_arrivee.contains(s2) && !sommets_depart.contains(s2)  &&
		     s1.getVisible() && s2.getVisible() && arete.getVal() < min ) {
		    min = arete.getVal();
		    areteMin = arete;
		    sens = 1;
		} else 
		    if ( sommets_depart.contains(s2)  && !sommets_depart.contains(s1)  && 
			 sommets_arrivee.contains(s1) && !sommets_arrivee.contains(s2) &&
			 s1.getVisible() && s2.getVisible() && arete.getVal() < min ) {
			min = arete.getVal();
			areteMin = arete;
			sens = 2;
		    }
	    }
	    if ( areteMin != null ) {
		if ( sens == 1 ) {
		    sommets_depart.addElement(areteMin.getE2());
		    sommets_arrivee.removeElement(areteMin.getE2());
		}
		if ( sens == 2 ) {
		    sommets_depart.addElement(areteMin.getE1());
		    sommets_arrivee.removeElement(areteMin.getE1());
		}
		
		areteMin.setVisible();
		arbre.ajouterArete(areteMin);
	    } else {
		System.out.println( " Le Graphe n'est pas connexe" );  
		return (this);
	    }
	}
	arbre.maximumArete();
	arbre.stress = this.stress;
	arbre.noms = this.noms;
	
	return (arbre);
    }
    
    static void echangerElements( double[] t, int m, int n ) {
	double temp = t[m];
	
	t[m] = t[n];
	t[n] = temp;
    }
    
    static int partition( double[] t, int m, int n ) {
	double v = t[m];                 // valeur pivot
	int i = m-1;
	int j = n+1;                  // indice final du pivot
	
	while ( true ) {
	    do {
		j--;
	    } while ( t[j] > v );
	    do {
		i++;
	    } while ( t[i] < v);
	    if ( i < j ) {
		echangerElements(t, i, j);
	    } else {
		return j;
	    }
	}
    }
    
    static void triRapide( double[] t, int m, int n ) {
	if ( m < n) {
	    int p = partition(t, m, n); 
	    triRapide(t, m, p);
	    triRapide(t, p+1, n);
	}
    }
    
    // Algorithme Kruskal pour determiner un MST : Maximal Spanning Tree
    public Graphe Kruskal() {
	int ordre = nombreSommets();
	Graphe arbre = new Graphe(false);

	return arbre;
    }
    
    public void visite() {
	for ( int i = 0; i < nombreSommets(); i++) {
	    Sommet s = getSommet(i);
	    if (s.marked())
		System.out.println("sommet " + i + " déjà vu");
	    else {
		System.out.println("sommet " + i + " atteint");
		s.mark();
	    }
	}
    }

    /* retire du graphe  tous les sommets de degre 0. Ceci reduit la taille du graphe
       par consequent accelere les differents algorithmes utilises */
    public void nettoyage() {
	for (int i = 0; i < sommets.size(); i++) {
	    Sommet v = this.getSommet(i);
	    getVoisins(v, false, this.seuil );
	    
	    if ( this.degre(this.indiceSommet(v)) == 0 && v.getVisible()) {
		v.setInvisible();
		System.out.println(this.indiceSommet(v) + " visible = " + v.getVisible() + 
				   "  nom : " + v.nom + 
				   "  degre =  " +  this.degre(this.indiceSommet(v)));
	    }
	    if ( this.degre(this.indiceSommet(v)) == 0 && !v.getVisible() ) {
		v.setVisible();
		System.out.println(this.indiceSommet(v) + " visible = " + v.getVisible() + 
				   "  nom : " + v.nom + 
				   "  degre =  " +  this.degre(this.indiceSommet(v)));
	    }
	}
    } 

    static String tronque(String chaine, int nbDecimales)
    {
	String avant;
	String apres;
	int longueurApres;
	
	StringTokenizer st = new StringTokenizer(chaine,","); 
	avant = st.nextToken(); 
	if (st.hasMoreTokens()) apres = st.nextToken(); 
	else return avant;
	
	if (nbDecimales <= 0) 
	    { 
		if (avant.equals("-0")) avant = "0"; 
		return avant; 
	    } 
	else if (apres.length() <= nbDecimales) return chaine;
	return chaine.substring( 0, chaine.length() - apres.length() + nbDecimales);
    }
  
    /**
       Trier l'ensemble des aretes en fonction de leurs poids
    */
    public void TrierAretes() {
	Vector aretesTriees = new Vector();
	aretesTriees = triInsertion(aretes);
	aretes = (Vector)aretesTriees.clone();
	
    }

    public static Vector triInsertion(Vector v) {
	Vector res = new Vector();  // le vecteur résultat
	int i;    // indice pour le parcours de v
	int p;    // indice pour la position d'insertion dans res
	for (i=0; i < v.size(); i++) { 
	    // on range dans elti le ième élément de v
	    Arete a1 = (Arete)v.elementAt(i);
	    Double elti = new Double(a1.getVal());
	    // recherche de la position p de elti dans le vecteur resultat
	    for (p = 0; p < res.size(); p++) {
		Arete a2 = (Arete)res.elementAt(p);
		Double el  = new Double(a2.getVal());
		if ( elti.doubleValue() < el.doubleValue() )
		    break;
	    }
		// insertion de elti à la position p dans le vecteur resultat
	    res.insertElementAt(a1, p);
	}
	return res;
    }
    
    public void SauvegarderPosition() {
	for ( int i = 0; i < nombreSommets(); i++) {
	    Sommet s = getSommet(i);
	    s.x0 = s.x;
	    s.y0 = s.y;
	}
    }
    
}



class NotOrientedGraphException extends RuntimeException
{
    NotOrientedGraphException(String msg)
    {
	super(msg);
    }
}



  

  

import javax.swing.*;
import javax.swing.event.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.awt.print.*;
import java.lang.*;
import java.io.*;
import javax.swing.filechooser.FileFilter;

public class GraphPanel extends  JPanel
    implements Runnable, MouseListener, ItemListener, MenuListener, KeyListener, Printable {

    public Graphe gr;
    public Graphe mg;
    public Graphe Cluster = new Graphe(false);
    public Graphe lArbre1 = new Graphe(false);
    public Graphe lArbre2 = new Graphe(false);
    public Graphe cnx = new Graphe(false);

    /* booléen permettant de savoir si un des composants du menu est selectionné. Ce même booléen est utilisé pour les divers choix offerts par le menu (ces choix étant exclusifs). Il est mis à true quand le choix est selectionné est devient false quand on décoche.*/
    public boolean on = false;

    /* Ce booléen est utilisé pour savoir si "classe" a été coché dans le menu. On n'a pas recours à "on" car on agit sur des composants du menu exclusifs. or, classe est compatible avec nuances, cercles, histo... */
    public boolean classon = false;

        /* Ce booléen est utilisé pour savoir si "nuances", "cercles" ou "histo" a été coché dans le menu. A savoir que ces trois composants peuvent etre selectionnés si "classes" ou "masquage a été selectionné. */
    public boolean groupon = false;

    public Graphe morphing;

    private Graphics2D graphics;
    private boolean editable = true;
    private boolean dragging = false;
    private Point ptDrag;

    public Sommet selection = null;

    Vector Clusters[];

    Color[] CouleursClusters;

    int nbClusters = 0;
    JFrame frame = new JFrame();

    int NbSommetsVisibles;
    int param=2; /* pour le boutons à cocher concernant l'affichage des histogrammes du morphing */

    Thread relaxer, morph;

    boolean circulaire = false;
    boolean cluster2 = false;
    boolean force3 = false;
    boolean random = false;
    boolean mst1 = false, mst2 = false;
    boolean mcl = false;
    boolean connexe = false;
    boolean morphingActif = false;
    ForceDirect Force;
    FishEyeMenu fisheye = null;

    /*pour indiquer en haut de la fenêtre l'instance en cours. */
    String titre=null;

    Sommet gravite = new Sommet(0, 0);

    String[] Items;

    NomLongs nomslongs = new NomLongs();
    ControlWindow control = null;

    JPopupMenu contenu;
    int noyau = 0;
    String individuChoisi;
    boolean flag = true;
    JProgressBar etatBarre = new JProgressBar();
    double facteur = 1.4;
    int currentInstance = 0, lastInstance = 0;
    int progress = 0;
    int largeur, longueur;

    public void init(int periode) {

	control = new ControlWindow(periode);

	control.slider1.setMinimum((int)gr.minArete);
	control.slider1.setValue((int)gr.minArete);
	control.slider1.setMaximum((int)gr.maxArete);
	control.slider1.setMinorTickSpacing(1);

	control.slider1.addChangeListener(new nouveauSeuil());
	control.slider3.addChangeListener(new IntensiteCouleurs());
	control.slider4.addChangeListener(new FacteurClustering());
	if (periode > 1) {
	    control.slider5.addChangeListener(new ChoixInstance());
	    control.recule.addActionListener(new ChoixTypeInstance());
	    control.avance.addActionListener(new ChoixTypeInstance());
	}

	setLayout( new BorderLayout( 600, 600) );
	this.setBackground(Color.black);

	this.gr = gr;
	cnx.sans = gr.sans;
	cnx.longs = gr.longs;
	cnx.cercle = gr.cercle;
	lArbre1 = lArbre2 = null;
	if ( periode > 1 ) gr.typeGraphe = 2;
	else gr.typeGraphe = 1;

	frame.addKeyListener(this);
	control.addKeyListener(this);

	this.frame.setSize( 600, 620 );
	final MenuItemListener menu = new MenuItemListener(this);

	etatBarre.setFont(new Font("Fixed", Font.BOLD , 14));
	etatBarre.setBackground(Color.lightGray);
	add("South", etatBarre);

	etatBarre.setVisible(false);

	this.frame.setResizable(true);
	this.frame.setJMenuBar(menu.barreMenus);
	this.frame.getContentPane().add(this, BorderLayout.CENTER );
	this.frame.setVisible(true);
	this.control.fenetre.setVisible(true);

}

    public void initColor() {
	CouleursClusters = new Color[nbClusters];
	int tour = 0;
	CouleursClusters[0] = Color.blue;
	if ( nbClusters >= 2 )  CouleursClusters[1] = Color.cyan;
	if ( nbClusters >= 3 )  CouleursClusters[2] = Color.green;
	if ( nbClusters >= 4 )  CouleursClusters[3] = Color.magenta ;
	if ( nbClusters >= 5 )  CouleursClusters[4] = Color.orange;
	if ( nbClusters >= 6 )  CouleursClusters[5] = Color.pink ;
	if ( nbClusters >= 7 )  CouleursClusters[6] = Color.red ;
	if ( nbClusters >= 8 )  CouleursClusters[7] = Color.yellow;
	if ( nbClusters >= 9 )  CouleursClusters[8] = Color.lightGray;
	if ( nbClusters >= 10 ) CouleursClusters[9] = Color.gray;

	for ( int i = 10; i < nbClusters; i++ ) {
	    int nb = 0;
	    if (i%10 == 0 ) tour ++;
	    float c0 = 255 - Clusters[i].size() ;
	    float c1 =  0;
	    float c2 = 0;
	    CouleursClusters[i] = CouleursClusters[tour*i%10].darker();
	}
    }
    static void echangerElements( String[] t, int m, int n ) {
	String temp = t[m];

	t[m] = t[n];
	t[n] = temp;
    }

    static int partition( String[] t, int m, int n ) {
	String v = t[m];                 // valeur pivot
	int i = m-1;
	int j = n+1;                  // indice final du pivot

	while ( true ) {
	    do {
		j--;
	    } while ( t[j].compareTo(v) > 0 );
	    do {
		i++;
	    } while ( t[i].compareTo(v) < 0);
	    if ( i < j ) {
		echangerElements(t, i, j);
	    } else {
		return j;
	    }
	}
    }

    static void triRapide( String[] t, int m, int n ) {
	if ( m < n ) {
	    int p = partition(t, m, n);
	    triRapide(t, m, p);
	    triRapide(t, p+1, n);
	}
    }

    GraphPanel(Graphe gr, boolean editable ) {
	super();
	this.gr = gr;
	this.mg = new Graphe(nbClusters);
	this.editable = editable;
	addMouseListener(this);
    }

    public Graphe getGraphe() { return gr; }
    public void setGraphe(Graphe gr) { this.gr = gr; repaint(); }
    public boolean getEditable() { return editable; }
    public void setEditable(boolean editable) { this.editable = editable; }

    public void centrerGraphe(Graphe g) {

	Dimension d = this.getSize();
	for (int i = 0; i < g.sommets.size(); i++) {
	    Sommet n = g.getSommet(i);

	    if ( largeur != 0 && longueur != 0 ) {
		n.x = n.x * d.width/largeur;
		n.y = n.y * d.height/longueur;
	    }
	    if (n.x < 10)  n.x = 10;
	    else if (n.x > d.width)
		n.x = d.width - n.larg;

	    if (n.y < 10) n.y = 10;
	    else if (n.y > d.height-40){
		n.y = d.height-40;}

	}

	largeur  = d.width;
	longueur = d.height;

    }

    public void paintComponent(Graphics g) {

	super.paintComponent(g);
	int instance = 0;
	if ( control.slider5 != null )
	    instance = control.slider5.getValue();

	if ( morphing != null ) {
	    centrerGraphe(morphing);
	    morphing.paintComponent(g, param);
	}

	if ( !connexe && morphing == null) {
	    if ( !mst1 && !mst2 && !mcl && instance == 0) {
		centrerGraphe(gr);
		gr.paintComponent(g, param);
	    }
	    else
		if ( mst1 && !mst2 && lArbre1 != null ) {
		    centrerGraphe(lArbre1);
		    lArbre1.paintComponent(g, param);
		} else
		    if ( !mst1 && mst2 && lArbre2 != null ) {
			centrerGraphe(lArbre2);
			lArbre2.paintComponent(g, param);
		    }else
			if ( mcl ) {
			    centrerGraphe(mg);
			    mg.paintComponent(g, param);
			}
	}
	else if ( cnx != null ) {
	    centrerGraphe(cnx);
	    cnx.paintComponent(g, param);
	}
	if ( dragging ) {
	    Color oldclr = g.getColor();
	   // g.setColor(new Color(250, 125, 65) );
	    g.setColor(new Color(0,0,0));
	    g.fillOval(ptDrag.x - Sommet.RAYON,
		       ptDrag.y - Sommet.RAYON,
		       2*Sommet.RAYON,
		       2*Sommet.RAYON);
	    g.setColor(oldclr);
	}
    }

    public void mouseDragged(MouseEvent e)
    {
	if ( (e.getModifiers() & MouseEvent.BUTTON1_MASK) == 0 || !dragging )
	    return;
	ptDrag = new Point(e.getX(), e.getY());
	repaint();
    }

    public void mouseMoved(MouseEvent e) {
	if ( contenu != null && contenu.isVisible() ) {
	    Object src = e.getSource();
	    System.out.println(src );
	}
    }

    public void mouseClicked(MouseEvent e) {
	Object src = e.getSource();
	int count = e.getClickCount();
	if ( e.getButton() == 1 && count >= 2) {
	    ptDrag = new Point(e.getX(), e.getY());
	    if ( morphing == null )
		selection = gr.hitTest(ptDrag, true);
	    else
		selection = morphing.hitTest(ptDrag, true);
	    if ( selection != null ) {
		if ( selection.fixe)
		    selection.fixe = false;
		else {
		    selection.fixe = true;

		}
	    }
	}
	if ( e.getButton() == 3 && mcl ) {
	    ptDrag = new Point(e.getX(), e.getY());
	    selection = mg.hitTest(ptDrag, true);
	    boolean trouve = false;
	    int i = 0;
	    if ( selection != null ) {
		for ( i = 0; i < mg.sommets.size() && !trouve; i++ ) {
		    metaNoeud mn = (metaNoeud)mg.getSommet(i);
		    if ( mn.nom.equals(selection.nom) ) trouve = true;
		}
		if ( trouve ) {
		    JMenuItem item;

		    i--;
		    String[] Items = new String[Clusters[i].size()];

		    for ( int j = 0; j < Clusters[i].size(); j++) {
			int indice = ((Integer)(Clusters[i].elementAt(j))).intValue();
			Sommet s = gr.getSommet(indice);
			if ( s.nomlong != null )
			    Items[j] = s.nomlong;
			else
			    Items[j] = s.nom;
		    }
		    triRapide(Items, 0, Clusters[i].size() - 1);

		    contenu = new JPopupMenu( );
		    item = new JMenuItem("Cluster " + i + " : " + Clusters[i].size());
		    item.addItemListener(this);
		    item.addMouseListener(this);
		    contenu.add(item);
		    contenu.addSeparator() ;

		    fisheye = new FishEyeMenu("Contenu");
		    fisheye.addItemListener(this);
		    fisheye.addMouseListener(this);

		    contenu.addMouseListener(this);
		    contenu.add(fisheye);

		    for ( int j = 0; j < Clusters[i].size(); j++) {
			item = new JMenuItem(Items[j]);
			fisheye.add(item);
		    }
		}
		contenu.setLocation(this.frame.getLocation().x + selection.x + 20,
				    this.frame.getLocation().y + selection.y + 60 );
		contenu.setVisible(true);
	    }
	} else if ( e.getButton() == 2 && mcl ) { // Extraction de cluster

	    ptDrag = new Point( e.getX(), e.getY() );
	    selection = mg.hitTest( ptDrag, true );
	    if ( contenu != null )
		contenu.setVisible(false);
	    boolean trouve = false;
	    int i = 0;
	    if ( selection != null ) {
		for ( i = 0; i < mg.sommets.size() && !trouve; i++ ) {
		    metaNoeud mn = (metaNoeud)mg.getSommet(i);
		    if ( mn.nom.equals(selection.nom) )
			trouve = true;
		}
		if ( trouve ) {
		    i--;
		    Cluster = new Graphe(false);
		    Cluster.typeGraphe = gr.typeGraphe;
		    int cpt = 0;
		    for ( int j = 0; j < Clusters[i].size(); j++ ) {
			int indice = ((Integer)(Clusters[i].elementAt(j))).intValue();

			Sommet interne = new Sommet(gr.getSommet(indice).x,
						    gr.getSommet(indice).y,
						    gr.getSommet(indice).couleur,
						    gr.getSommet(indice).nom);

			interne.type = gr.getSommet(indice).type;
			interne.metrique = gr.getSommet(indice).metrique;
			interne.couleur = gr.getSommet(indice).couleur;
			interne.couleurClasse = gr.getSommet(indice).couleurClasse;
			interne.nomlong = gr.getSommet(indice).nomlong;
			interne.nom = gr.getSommet(indice).nom;

			for ( int ll = 1; ll <= gr.instance; ll++ )
			    interne.Metrique[ll] = gr.getSommet(indice).Metrique[ll];
			interne.Metrique[gr.instance+1]= gr.getSommet(indice).Metrique[gr.instance+1];

			Cluster.ajouterSommet(interne);

			for ( int k = 0; k < nbClusters; k++ ) {
			    if ( k != i ) {
				for (int l = 0; l < Clusters[k].size(); l++) {
				    int indiceExterne =
					((Integer)(Clusters[k].elementAt(l))).intValue();

				    Sommet externe_tmp = gr.getSommet(indiceExterne);
				    int ind_a = gr.areteDansGraphe(externe_tmp, interne);

				    if ( !gr.getSommet(indice).equals(externe_tmp) &&
					 ind_a != -1 ) {
					Sommet externe = new Sommet( externe_tmp.x,
								     externe_tmp.y,
								     externe_tmp.couleur,
								     externe_tmp.nom );

					externe.type          = externe_tmp.type;
					externe.metrique      = externe_tmp.metrique;
					externe.couleur       = externe_tmp.couleur;
					externe.couleurClasse = externe_tmp.couleurClasse;
					externe.nomlong       = externe_tmp.nomlong;
					externe.nom           = externe_tmp.nom;
					for ( int ll = 1; ll <= gr.instance; ll++ )
					    externe.Metrique[ll] = externe_tmp.Metrique[ll];
					externe.Metrique[gr.instance+1] =
					    externe_tmp.Metrique[gr.instance+1];

					Cluster.ajouterSommet(externe);

					Arete arete_tmp = gr.getArete(ind_a);
					Arete arete = new Arete(externe_tmp,
								interne,
								externe_tmp.x,
								interne.x,
								arete_tmp.getCouleur(),
								arete_tmp.getNom(),
								cpt++ );

					arete.setVal(arete_tmp.getVal());

					Cluster.ajouterArete(arete);
				    }
				}
			    }
			}
		    }
		    for ( int j = 0; j < Clusters[i].size(); j++ ) {
			int indice = ((Integer)(Clusters[i].elementAt(j))).intValue();

			for ( int k = 0; k < Clusters[i].size(); k++ ) {
			    int ind = ((Integer)(Clusters[i].elementAt(k))).intValue();

			    int ind_a = gr.areteDansGraphe(gr.getSommet(indice),
							   gr.getSommet(ind));
			    if ( !gr.getSommet(indice).equals(gr.getSommet(ind)) &&
				 ind_a != -1 ) {

				Arete arete = new Arete(gr.getSommet(indice),
							gr.getSommet(ind),
							gr.getSommet(indice).x,
							gr.getSommet(ind).x,
							gr.getArete(ind_a).getCouleur(),
							gr.getArete(ind_a).getNom(),
							Cluster.aretes.size()+1 );

				arete.setVal(gr.getArete(ind_a).getVal());
				for ( int ll = 1; ll <= gr.instance ; ll++ )
				    arete.setValInstance(gr.getArete(ind_a).getValInstance(ll), ll);

				Cluster.ajouterArete(arete);
			    }
			}
		    }
		}
		Cluster.clustering = gr.clustering;
		Cluster.TrierAretes();
		GraphPanel Clone = new GraphPanel(Cluster, true);
		Clone.gr = Cluster;
		Clone.Items = new String[Cluster.nombreSommets()];
		Clone.nomslongs   = nomslongs;
		for ( int j = 0; j < Cluster.nombreSommets(); j++) {
		    Sommet s = Cluster.getSommet(j);
		    if ( s.nomlong != null )
			Clone.Items[j] = s.nomlong;
		    else
			Clone.Items[j] = s.nom;
		}
		triRapide(Clone.Items, 0, Cluster.nombreSommets() - 1);

		Cluster.maximumArete();
		Cluster.maxMetrique1 = gr.maxMetrique1;
		Cluster.maxMetrique2 = gr.maxMetrique2;
		Clone.init(gr.instance);

		Cluster.typeMat = gr.typeMat;
		Cluster.sans    = gr.sans;
		Cluster.longs   = gr.longs;
		Cluster.cercle  = gr.cercle;
		Cluster.instance= gr.instance;

		Clone.frame.setTitle( "Tétralogie VisuGraph : Cluster " +i);
		Clone.frame.setVisible(true);

	    }
	} else if (e.getButton() == 3 && connexe) {
	    // Button 3 : selection

	    ptDrag = new Point(e.getX(), e.getY());
	    selection = cnx.hitTest(ptDrag, true);

	    if ( selection != null ) {
		selection.marked = true;
		gr.getVoisins(selection, false, cnx.seuil );
		for ( int i = 0; i < selection.voisins.size(); i++) {
		    Sommet s = (Sommet)selection.voisins.elementAt(i);
		    cnx.ajouterSommet(s);
		    s.setVisible();

		    int indice = gr.areteDansGraphe(selection, s);
		    if ( indice != -1 ) {
			Arete a = gr.getArete(indice);
			if ( !cnx.aretes.contains(a) ) {
			    cnx.ajouterArete(a);
			    if ( a.getVal() >= cnx.seuil )
				a.setVisible();
			    else a.setInvisible();
			}
		    }
		}
		for ( int i = 0; i < cnx.nombreSommets(); i++ ) {
		    Sommet si = cnx.getSommet(i);
		    for ( int j = 0; j < cnx.nombreSommets(); j++ ) {
			Sommet sj = cnx.getSommet(j);
			if ( i != j && si.getVisible() && sj.getVisible() ) {
			    int indice = gr.areteDansGraphe(si, sj);
			    if ( indice != -1 ) {
				Arete a = gr.getArete(indice);
				cnx.ajouterArete(a);
				if ( a.getVal() >= cnx.seuil)
				    a.setVisible();
				else a.setInvisible();
			    }
			}
		    }
		}
		cnx.initDegre();
		cnx.maximumMetrique();
		cnx.maximumArete();
		cnx.TrierAretes();
		if (cnx.nombreSommets() ==  gr.nombreSommets()) {
		    Toolkit.getDefaultToolkit().beep();
		    Toolkit.getDefaultToolkit().beep();
		}
	    } else Toolkit.getDefaultToolkit().beep();
	}
	else if ( e.getButton() == 2 && connexe ) {
	    // Button 2 : de-selection
	    ptDrag = new Point(e.getX(), e.getY());
	    selection = cnx.hitTest(ptDrag, true);

	    if ( selection != null ) {
		cnx.getVoisins(selection, false, cnx.seuil );
		selection.marked = false;
		cnx.supprimerSommet( cnx.indiceSommet(selection) );
		cnx.initDegre();
		for ( int i = 0; i < selection.voisins.size(); i++) {
		    Sommet s = (Sommet)selection.voisins.elementAt(i);
		    int indice = cnx.indiceSommet(s);
		    s.marked = false;
		    cnx.getVoisins( cnx.getSommet(indice), false, cnx.seuil );

		    if ( s.voisins.size() == 0  )
			cnx.supprimerSommet(indice);
		    s.niveau = 100;
		}
		cnx.initDegre();
		cnx.maximumMetrique();
		cnx.maximumArete();
		cnx.TrierAretes();
	    }
	}
	repaint();
    }
    public void keyReleased(KeyEvent e) { progress = 0;}
    public void keyTyped(KeyEvent e) {}
    public void keyPressed(KeyEvent e) {
	int key = e.getKeyCode();

	switch (key) {
	case KeyEvent.VK_ENTER:
	    if ( progress == 1 ) progress = 0;
	    else progress = 1;
	}
    }
    public void ExtractionCluster (int i) {
	Cluster = new Graphe(false);
	int cpt = 0;
	for ( int j = 0; j < Clusters[i].size(); j++ ) {
	    int indice = ((Integer)(Clusters[i].elementAt(j))).intValue();

	    Sommet interne = new Sommet( gr.getSommet(indice).x,
					 gr.getSommet(indice).y,
					 gr.getSommet(indice).couleur,
					 gr.getSommet(indice).nom );

	    interne.type = gr.getSommet(indice).type;
	    interne.metrique = gr.getSommet(indice).metrique;
	    interne.couleur = gr.getSommet(indice).couleur;
	    interne.couleurClasse = gr.getSommet(indice).couleurClasse;
	    interne.nomlong = gr.getSommet(indice).nomlong;
	    interne.nom = gr.getSommet(indice).nom;

	    Cluster.ajouterSommet(interne);

	    for ( int k = 0; k < nbClusters; k++ ) {
		if ( k != i ) {
		    for (int l = 0; l < Clusters[k].size(); l++) {
			int indiceExterne =
			    ((Integer)(Clusters[k].elementAt(l))).intValue();

			Sommet externe_tmp = gr.getSommet(indiceExterne);
			int ind_a = gr.areteDansGraphe(externe_tmp, interne);

			if ( !gr.getSommet(indice).equals(externe_tmp) &&
			     ind_a != -1 ) {
			    Sommet externe = new Sommet( externe_tmp.x,
							 externe_tmp.y,
							 externe_tmp.couleur,
							 externe_tmp.nom );

			    externe.type          = externe_tmp.type;
			    externe.metrique      = externe_tmp.metrique;
			    externe.couleur       = externe_tmp.couleur;
			    externe.couleurClasse = externe_tmp.couleurClasse;
			    externe.nomlong       = externe_tmp.nomlong;
			    externe.nom           = externe_tmp.nom;

			    Cluster.ajouterSommet(externe);
			    Arete arete_tmp = gr.getArete(ind_a);
			    Arete arete = new Arete(externe_tmp,
						    interne,
						    externe_tmp.x,
						    interne.x,
						    arete_tmp.getCouleur(),
						    arete_tmp.getNom(),
						    cpt++ );

			    arete.setVal(arete_tmp.getVal());
			    Cluster.ajouterArete(arete);
			}
		    }
		}
	    }
	}
	for ( int j=0; j < gr.aretes.size(); j++ ) {
	    Arete a = gr.getArete(j);
	    Sommet e1 = a.getE1();
	    Sommet e2 = a.getE2();
	    if ( e1.num_cluster == e2.num_cluster && e1.num_cluster == i ) {
		Arete intra_arete = new Arete(e1, e2, e1.x, e2.x, null, a.getNom(),
					      Cluster.aretes.size()+1 );
		intra_arete.setVal(a.getVal());
		Cluster.aretes.addElement(intra_arete);
	    }
	}
	Cluster.TrierAretes();
	GraphPanel Clone = new GraphPanel(Cluster, true);
	Clone.gr = Cluster;
	Clone.Items = new String[Cluster.nombreSommets()];
	Clone.nomslongs   = nomslongs;
	for ( int j = 0; j < Cluster.nombreSommets(); j++) {
	    Sommet s = Cluster.getSommet(j);
	    if ( s.nomlong != null )
		Clone.Items[j] = s.nomlong;
	    else
		Clone.Items[j] = s.nom;
	}
	triRapide(Clone.Items, 0, Cluster.nombreSommets() - 1);

	Cluster.maximumArete();
	Cluster.maxMetrique1 = gr.maxMetrique1;
	Cluster.maxMetrique2 = gr.maxMetrique2;
	Clone.init(1);

	Cluster.typeMat = this.gr.typeMat;
	Cluster.sans   = gr.sans;
	Cluster.longs  = gr.longs;
	Cluster.cercle = gr.cercle;
	Clone.circulaire = true;
	Clone.circulaire(Cluster);
	Clone.frame.setTitle( "Tétralogie VisuGraph : Cluster " + i );
	Clone.frame.setVisible(true);

    }
    public void mouseEntered(MouseEvent e) {
	if ( contenu != null && contenu.isVisible() ) {
	    Object src = e.getSource();
	    if ( src == fisheye ) {
		fisheye.menuSelectionChanged(true);
		fisheye.setVisible(true);
	    }
	    else
		fisheye.menuSelectionChanged(false);
	}
    }
    public void mouseExited(MouseEvent e) {
	// System.out.println ("mouseExited");
    }

    public void mousePressed(MouseEvent e)
    {
	if ((e.getModifiers() & MouseEvent.BUTTON1_MASK) == 0 || !editable)
	    return;
	ptDrag = new Point(e.getX(), e.getY());
	if ( morphing != null ) selection = morphing.hitTest(ptDrag, true);
	if ( !mst1 && !mst2 && !mcl )                    selection = gr.hitTest(ptDrag, true);
	if (  mst1 && !mst2 && !mcl && lArbre1 != null ) selection = lArbre1.hitTest(ptDrag, true);
	if (  !mst1 && mst2 && !mcl && lArbre2 != null ) selection = lArbre2.hitTest(ptDrag, true);
	if ( !mst1 && !mst2 && mcl ) {
	    selection = mg.hitTest(ptDrag, true);
	    flag = true;
	}

	if ( selection != null ) {
	    dragging = true;
	    Graphics2D g = (Graphics2D)this.getGraphics();
	    selection.afficher( g, false, gr.maxMetrique1, true,
				gr.cercle, gr.clustering, gr.rang, param );
	}
    }

    public void mouseReleased(MouseEvent e)
    {
	Dimension d = getSize();

	if ( contenu != null && contenu.isVisible()  ) {
	    fisheye.fishEyeWindow.setVisible(false);
	    contenu.setVisible(false);
	}
	if (( e.getModifiers() & MouseEvent.BUTTON1_MASK) == 0 || !dragging )
	    return;

	dragging = false;
	ptDrag = new Point(e.getX(), e.getY());

	while (gr.hitTest(ptDrag, false) != null ) {
	    ptDrag.x += Sommet.RAYON;
	    ptDrag.y += Sommet.RAYON;
	}
	selection.deplacer(e.getX(), e.getY(), d.width, d.height);

	ptDrag = null;
	repaint();
	e.consume ();
    }

    class ChoixTypeInstance implements ActionListener {
	 //GraphPanel g = new GraphPanel(gr,true);
	/* pour savoir si le masquage est coché, on crée un objet menu pour lire le menu masquage*/
	public void actionPerformed(ActionEvent e) {

//
	    currentInstance = control.slider5.getValue();
	//    lastInstance=currentInstance;

	    /* on indique les nouvelles valeurs du slider des instances (on l'augmente si on a cliqué sur avance et on le diminue si on a cliqué
	    sur recule). currentInstance sera utilisée dans la fonction animeMorphing pour déplacer le curseur du slider. */
	    if ( e.getSource() == control.avance &&  control.slider5.getValue() <  control.slider5.getMaximum() )
		currentInstance = control.slider5.getValue() + 1;
	    if ( e.getSource() ==  control.recule   )
		currentInstance = control.slider5.getValue() - 1;


	    morphing = new Morphing(false);
	    morphing.typeGraphe = 1;
	    morphing.rang   = currentInstance;
	    morphing.stress = gr.stress;
	    morphing.noms   = gr.noms;
	    morphing.cercle = 2;
	    morphing.longs  = gr.longs;
	    morphing.sans   = gr.sans;
	    morphing.clustering = gr.clustering;
	    morphing.seuil = control.slider1.getValue();
	    morphing.intensite = ConversionIntensite(control.slider3.getValue());
	    /* Le start2() va mettre en place le principe de threads. Ces derniers permettent d'effectuer des taches en parallèle, à partir
	    d'une attribution de valeur au booléen correspondant. Start2() va armer le booleen "morph", qui fera appel à la fonction animeMorphing(),
	    laquelle appliquera le morphing.*/
	    start2();

	    /* on indique les nouvelles valeurs du slider des instances (on l'augmente si on a cliqué sur avance et on le diminue si on a cliqué
	    sur recule). currentInstance sera utilisée dans la fonction animeMorphing pour déplacer le curseur du slider. */
	    if ( e.getSource() == control.avance &&  control.slider5.getValue() <  control.slider5.getMaximum() )
		currentInstance = control.slider5.getValue() + 1;
	    if ( e.getSource() ==  control.recule   )
		currentInstance = control.slider5.getValue() - 1;


	 }
    }

    class ChoixInstance implements ChangeListener {
	public void stateChanged( ChangeEvent e ) {
	// Morphing de graphe par paramètre - echelle
	//Actions effectuées lorsqu'on change d'instance par le biais de l'échelle graduée
	    Object src = e.getSource();

	    if ( !morphingActif ) {
		lastInstance = currentInstance;
		int instance = control.slider5.getValue();
		currentInstance = instance;
		morphing = new Morphing(false);
		morphing.masque = gr.masque ;
		morphing.intensite = ConversionIntensite(control.slider3.getValue());
		//System.out.println("2- current Instance = " + currentInstance + " last Instance = " +lastInstance );
		if ( morphing.masque == true )
		    System.out.println("morphing masque : true " );
		else

		    System.out.println("morphing masque : false " );

		morphing.clustering = gr.clustering;
		morphing.seuil = control.slider1.getValue();
		for ( int i = 0; i < gr.nombreSommets(); i++ ) {
		    Sommet s = gr.getSommet(i);
		    morphing.ajouterSommet(s);
		}
		if ( instance >= 1 ) {
		    morphing.typeGraphe = 1;
		    for ( int i = 0; i < gr.nombreAretes(); i++ ) {
			Arete a = gr.getArete(i);
			double valeur = a.getValInstance(instance);

			Sommet s1 = a.getE1();
			Sommet s2 = a.getE2();
			s1.type = a.getE1().type;
			s2.type = a.getE2().type;
			//s1.couleur = Color.red;
			//s2.couleur = Color.red;
			if ( valeur != 0 ) {
			    Arete ar = new Arete(s1, s2);
			    ar.setVal((int)valeur);
			    ar.setNom(String.valueOf((int)valeur));
			    morphing.ajouterArete(ar);
			    //if ( valeur < morphing.seuil ) ar.setInvisible();
			    s1.metrique = a.getE1().Metrique[instance];
			    s2.metrique = a.getE2().Metrique[instance];
			} else {
			    s1.metrique = a.getE1().Metrique[instance];

			    s2.metrique = a.getE2().Metrique[instance];
			}
			morphing.ajouterSommet(s1);
			morphing.ajouterSommet(s2);
		    }
		    morphing.masque = gr.masque;
		    morphing.stress = gr.stress;
		    morphing.noms   = gr.noms;
		    morphing.longs  = gr.longs;
		    morphing.sans   = gr.sans;
		    morphing.rang = instance;

		    morphing.maxMetrique1 = gr.maxMetrique1/2;
		    morphing.maxMetrique2 = gr.maxMetrique2/2;
		    morphing.maxArete     = gr.maxArete;
		    morphing.minArete     = gr.minArete;

		    repaint();
		    morphing.TrierAretes();
		} else
		    morphing = null;

		// mise a jour des valeurs pour le slider du filtrage
		// if ( morphing != null ) {
		//	morphing.seuil = control.slider1.getValue();
		// }

		if ( instance == control.slider5.getMaximum() )
		    control.avance.setEnabled(false);
		else
		    control. avance.setEnabled(true);

		if (instance == 0 )
		    control.recule.setEnabled(false);
		else
		    control.recule.setEnabled(true);

	   	/* On gère le cas où on a coché la case "masquage". Dans ce cas la, on est sur true (cf ActionPerformed(actionEvent e) définie plus bas). "On" a été activé par un clic sur masquage dans le menu. Dans notre cas on change d'instance mais le morphing doit s'adapter à ce changement. on va donc procéder de la manière suivante : si on a coché masquage, on va agir comme si on le décochait (pour revenir à la situation initiale), puis on va remasquer.*/
	        if (on==true) {
		on = false;
		/* j<2 car on veut passer une première fois pour demasquer (gr.masque=false), puis une seconde fois pour remasquer (gr.masque=true). On change la valeur de gr.masque en fin de boucle for(...)*/
		for (int j=0; j<2; j++){
			gr.masque   = on;
			/* Le code est fortement semblable à celui actionné en cas de (dé)coche de masquage.*/
			Graphe graphe = new Graphe(false);
			if ( !mst1 && !mst2 && !mcl ) { gr.masque = on; graphe = gr ; }
			if (  mst1 && !mst2 && !mcl ) { lArbre1.masque = on; graphe = lArbre1;}
			if ( !mst1 &&  mst2 && !mcl ) { lArbre2.masque = on; graphe = lArbre2;}
			if ( !mst1 && !mst2 &&  mcl ) { mg.masque = on; graphe = mg ;}
			if ( connexe )                { cnx.masque = on; graphe = cnx;}
			if ( morphing != null )       { morphing.masque = on; graphe = morphing; }

			/* Le filtrage ayant été modifié par le masquage (un premier masquage supprime des aretes, ce qui change donc le seuil d'affichage des aretes), on va filtrer au maximum, puis revenir à la valeur initiale, afin que notre masquage soit efficace et adapté à notre instance. */
			int val0=control.slider1.getValue();
			/* on cherche la valeur maximale possible du filtrage et on l'applique. */
			int val1= control.slider1.getMaximum();
			control.slider1.setValue(val1);
			int val2= control.slider1.getMinimum();
			control.slider1.setValue(val2);
			/* On revient à la valeur initiale de filtrage. */
			control.slider1.setValue(val0);

			/* On applique notre (dé)masquage.*/
			for ( int i = 0; i < graphe.nombreSommets(); i++ ) {
				Sommet v = graphe.getSommet(i);
				graphe.getVoisins(v, false, graphe.seuil );

				if ( graphe.degre(graphe.indiceSommet(v)) == 0 &&
				v.getVisible() && on )
				v.setInvisible();

				if ( graphe.degre(graphe.indiceSommet(v)) == 0 &&
				!on )
				v.setVisible();
			}
			if ( circulaire ) circulaire(graphe);
			/* on met "on" à true, afin de pouvoir effectuer dans le second passage, un masquage.*/
			on=true;
	 	}
	    }
	  }
	}
    }

    public void InitMorphing(int instance) {

	morphing.aretes =  new Vector();
	int instanceMax = control.slider5.getMaximum();
	morphing.seuil = control.slider1.getValue();
	morphing.masque = gr.masque ;
	morphing.intensite = ConversionIntensite(control.slider3.getValue());
	for ( int i = 0; i < gr.nombreSommets(); i++ ) {
		    Sommet s = gr.getSommet(i);
		    morphing.ajouterSommet(s);
	}
	for ( int i = 0; i < gr.nombreAretes(); i++ ) {
	    Arete a = gr.getArete(i);
	    Sommet s1 = a.getE1();
	    Sommet s2 = a.getE2();

	    Arete ar = new Arete(s1, s2, s1.x, s2.x, a.getCouleur(), a.getValInstance(instance), i );
     	    ar.setNom(a.getNom());
	    for ( int j = 1; j <= instanceMax; j++ )
		ar.setValInstance(a.getValInstance(j), j );

	    morphing.ajouterArete(ar);
	   // if ( ar.getValInstance(instance) <= morphing.seuil ) ar.setInvisible();
	   // else ar.setVisible();
	}
    }

    public void AnimeMorphing() {
	double t = 0.0;
	double valeur1 = 0.0, valeur2 = 0.0;
	int etape = 0; // pour savoir à quelle étape nous sommes lors du morphing évolutif
	//System.out.println("1- currente Instance = " + currentInstance + " last Instance = " +lastInstance );
	// on progresse dans le temps
	if ( currentInstance > 0 && currentInstance > lastInstance ) {
	    InitMorphing(lastInstance);

	    while ( t <= 1.0 ) {
	    /* nous indiquons dans la barre supérieure du graphe (la où apparaissent le nom de la matrice, le numéro d'instance), l'étape du morphing*/
		etape+=1;

		frame.setTitle( "Tétralogie VisuGraph : " + titre + "                 Graphe d'instance" + control.slider5.getValue()+ "     Etape : "+etape);
		frame.setLocation(210, 0);
		valeur1 = (double)(1-t);
		valeur2 = (double)(  t);
		for ( int i = 0; i < morphing.nombreSommets(); i++ ) {
		    Sommet s = morphing.getSommet(i);
		    s.metrique = Math.round(s.Metrique[currentInstance-1]*valeur1 +
					    s.Metrique[currentInstance]*valeur2);

		   /* if ( s.Metrique[currentInstance-1] < s.Metrique[currentInstance] )
		      s.couleur = Color.green;
		      else
		      if ( s.Metrique[currentInstance-1] > s.Metrique[currentInstance] )
		      s.couleur = Color.red;
		      else s.couleur = Color.orange;*/
		}

		for ( int i = 0; i < morphing.nombreAretes(); i++ ) {
		    Arete a = morphing.getArete(i);
		    Sommet s1 = a.getE1();
		    Sommet s2 = a.getE2();
		    /* getValInstance retourne la valeur des aretes */
		    /* Valeur des aretes de l'instance en cours */
		    double d1 = a.getValInstance(currentInstance-1);
		    /* Valeur des aretes de l'instance suivante (celle qui va s'afficher)*/
		    double d2 = a.getValInstance(currentInstance  );
		    /* ajout des valeurs de l'arete pré et post morphing, pondérées. */
		    double d  = d1*valeur1 + d2*valeur2;
		    // nouvelle arete apparait
		    if ( d1 == 0 && d2 != 0 ) {
			a.setVal((int)(Math.round(d)));
			a.setNom(String.valueOf((int)Math.round(d)));
			if ( !a.getVisible() ) a.setVisible();
		    }
		    // maj d'1 arete qui existe deja et evolue ou stable
		    else if ( d1 != d2 && d1 != 0 && d2 != 0 ||
			      d1 == d2 && d1 != 0 && d2 != 0 ) {
			a.setVal((int)(Math.round(d)));
			a.setNom(String.valueOf((int)Math.round(d)));
			if ( !a.getVisible() ) a.setVisible();
		    }
		    else if ( d1 != 0 && d2 == 0 && d <= 0.01  ) // disparition totale
			a.setInvisible();
		    else if ( d1 != 0 && d2 == 0 && d != 0 ) {
			    a.setVal((int)(Math.round(d)));
			    a.setNom(String.valueOf((int)Math.round(d)));
		    }
		    else if ( d1 == 0 && d2 == 0 && a.getVisible()) {
			a.setInvisible();
		    }
		    //if ( d <= morphing.seuil ) a.setInvisible();  else a.setVisible();
		}
		morphing.maxMetrique1 = gr.maxMetrique1/2;
		morphing.maxMetrique2 = gr.maxMetrique2/2;
 		morphing.maxArete     = gr.maxArete;
 		morphing.minArete     = gr.minArete;
		morphing.typeMat = gr.typeMat;
		repaint();
                t = t + 0.1;
		pause(300);


	    }
	    morphing.TrierAretes();
	    morphingActif = true;
	    control.slider5.setValue(currentInstance);
	} else // on recule dans le temps
	    if ( currentInstance != 0 && currentInstance < lastInstance ) {
		InitMorphing(lastInstance);
		while ( t <= 1 ) {

		/* nous indiquons dans la barre supérieure du graphe (la où apparaissent le nom de la matrice, le numéro d'instance), l'étape du morphing*/
		etape+=1;

			frame.setTitle( "Tétralogie VisuGraph : " + titre + "                 Graphe d'instance" + control.slider5.getValue()+ "     Etape : "+etape);
			frame.setLocation(210, 0);


		    valeur1 = (double)(1-t);
		    valeur2 = (double)(  t);
		    for ( int i = 0; i < morphing.nombreSommets(); i++ ) {
			Sommet s = morphing.getSommet(i);
			s.metrique = Math.round(s.Metrique[currentInstance+1]*valeur1 +
						s.Metrique[currentInstance]*valeur2);
			/*if ( s.Metrique[currentInstance] > s.Metrique[currentInstance+1] )
			  s.couleur = Color.green;
			  else
			  if ( s.Metrique[currentInstance] < s.Metrique[currentInstance+1] )
			  s.couleur = Color.red;
			  else s.couleur = Color.orange;*/
		    }

		    for ( int i = 0; i < morphing.nombreAretes(); i++ ) {
			Arete a = morphing.getArete(i);
			Sommet s1 = a.getE1();
			Sommet s2 = a.getE2();
			double d1 = a.getValInstance(currentInstance+1);
			double d2 = a.getValInstance(currentInstance );
			double d  = d1*valeur1 + d2*valeur2;

			// nouvelle arete apparait
			if ( d1 == 0 && d2 != 0 ) {
			    a.setVal((int)(Math.round(d)));
			    a.setNom(String.valueOf((int)Math.round(d)));
			    if ( !a.getVisible() ) a.setVisible();
			}
			// maj d'1 arete qui existe deja : evolue ou stable
			else if ( d1 != d2 && d1 != 0 && d2 != 0  ||
				  d1 == d2 && d1 != 0 && d2 != 0 ) {
			    a.setVal((int)(Math.round(d)));
			    a.setNom(String.valueOf((int)Math.round(d)));
			    if ( !a.getVisible() ) a.setVisible();

			}
			else if ( d1 != 0 && d2 == 0 && d <= 0.01 )  {// disparition totale
			    a.setInvisible();

			}
			else if ( d1 != 0 && d2 == 0 && d != 0 ) { // en voie de disparition
       			    a.setVal((int)(Math.round(d)));
			    a.setNom(String.valueOf((int)Math.round(d)));
			    a.setVisible();
			}
			else if ( d1 == 0 && d2 == 0 && a.getVisible() ) {
			    a.setInvisible();
			}
			//if ( d < morphing.seuil ) a.setInvisible();  else a.setVisible();
		    }
		    morphing.maxMetrique1 = gr.maxMetrique1/2;
		    morphing.maxMetrique2 = gr.maxMetrique2/2;
		    morphing.maxArete     = gr.maxArete;
		    morphing.minArete     = gr.minArete;
		    morphing.typeMat = gr.typeMat;
		    repaint();
		    t = t + 0.1;
		    pause(300);
		}

		morphing.TrierAretes();
		morphingActif = true;
		control.slider5.setValue(currentInstance);

	    } else
		if ( currentInstance == 0 || lastInstance == currentInstance ) {
		    control.slider5.setValue(currentInstance);
			morphing = null;
		}

	if (currentInstance == control.slider5.getMaximum() )
	    control.avance.setEnabled(false);
	else
	    control.avance.setEnabled(true);

	if (currentInstance == 0 ) {
	    control.recule.setEnabled(false);
	    control.avance.setEnabled(true);
	}
	else
	    control.recule.setEnabled(true);
	if (currentInstance == 1 ) {
	    control.recule.setEnabled(true);
	    control.avance.setEnabled(true);
	}
	lastInstance = currentInstance;
	repaint();
	stop2();
	morphingActif = false;
  /* On gère le cas où on a coché la case "masquage". Dans ce cas la, on est sur true (cf ActionPerformed(actionEvent e) définie plus bas). "On" a été activé par un clic sur masquage dans le menu. Dans notre cas on change d'instance mais le morphing doit s'adapter à ce changement. on va donc procéder de la manière suivante : si on a coché masquage, on va agir comme si on le décochait (pour revenir à la situation initiale), puis on va remasquer.*/
	  if (on==true) {
		on = false;
		/* j<2 car on veut passer une première fois pour demasquer (gr.masque=false), puis une seconde fois pour remasquer (gr.masque=true). On change la valeur de gr.masque en fin de boucle for(...)*/
		for (int j=0; j<2; j++){
			gr.masque   = on;
			/* Le code est fortement semblable à celui actionné en cas de (dé)coche de masquage.*/
			Graphe graphe = new Graphe(false);
			if ( !mst1 && !mst2 && !mcl ) { gr.masque = on; graphe = gr ; }
			if (  mst1 && !mst2 && !mcl ) { lArbre1.masque = on; graphe = lArbre1;}
			if ( !mst1 &&  mst2 && !mcl ) { lArbre2.masque = on; graphe = lArbre2;}
			if ( !mst1 && !mst2 &&  mcl ) { mg.masque = on; graphe = mg ;}
			if ( connexe )                { cnx.masque = on; graphe = cnx;}
			if ( morphing != null )       { morphing.masque = on; graphe = morphing; }

			/* Le filtrage ayant été modifié par le masquage (un premier masquage supprime des aretes, ce qui change donc le seuil d'affichage des aretes), on va filtrer au maximum, puis revenir à la valeur initiale, afin que notre masquage soit efficace et adapté à notre instance. */
			int val0=control.slider1.getValue();
			/* on cherche la valeur maximale possible du filtrage et on l'applique. */
			int val1= control.slider1.getMaximum();
			control.slider1.setValue(val1);
			int val2= control.slider1.getMinimum();
			control.slider1.setValue(val2);
			/* On revient à la valeur initiale de filtrage. */
			control.slider1.setValue(val0);

			/* On applique notre (dé)masquage.*/
			for ( int i = 0; i < graphe.nombreSommets(); i++ ) {
				Sommet v = graphe.getSommet(i);
				graphe.getVoisins(v, false, graphe.seuil );

				if ( graphe.degre(graphe.indiceSommet(v)) == 0 &&
				v.getVisible() && on )
				v.setInvisible();

				if ( graphe.degre(graphe.indiceSommet(v)) == 0 &&
				!on )
				v.setVisible();
			}
			if ( circulaire ) circulaire(graphe);
			/* on met "on" à true, afin de pouvoir effectuer dans le second passage, un masquage.*/
			on=true;

	 	}
	 }
		    repaint();

    }

    /* Indique le dégradé de gris pour représenter les aretes. Notre fond étant noir, plus l'arete est important plus elle apparaitra en gris clair. Inversement, moins elle sera importante, plus sombre elle sera. */
    public double ConversionIntensite(int entree) {
	if ( entree == 0 )
	    return(0.12);
	else if ( entree == 1 )
	    return(0.25);
	else if ( entree == 2 )
	    return(0.5);
	else if ( entree == 3 )
	    return(1.0);
	else if ( entree == 4 )
	    return(2.0);
	else if ( entree == 5 )
	    return(3.0);
	else if ( entree == 6 )
	    return(4.0);
	else  return(1.0);
    }
    class FacteurClustering implements ChangeListener {	
        public void stateChanged (ChangeEvent e) { 
	    double val = control.slider4.getValue();
	    facteur = 1.0;
	    facteur += (double)val/10.0;
	}
    }

    class IntensiteCouleurs implements ChangeListener {
        public void stateChanged (ChangeEvent e) {
	    double val =  ConversionIntensite(control.slider3.getValue());
	    
	    if ( !mst1 && !mst2 && !mcl && !connexe ) gr.intensite      = val; 
	    if (  mst1 && !mst2 && !mcl && !connexe ) lArbre1.intensite = val; 
	    if ( !mst1 &&  mst2 && !mcl && !connexe ) lArbre2.intensite = val; 
	    if ( !mst1 && !mst2 &&  mcl && !connexe ) mg.intensite      = val; 
	    if ( connexe                            ) cnx.intensite     = val; 
	    if ( morphing != null                   ) morphing.intensite = val;
	    //System.out.println(" intensite = " + val );
	    repaint();
	}
    }
    class nouveauSeuil implements ChangeListener {	
        public void stateChanged ( ChangeEvent e ) {
	    double val = control.slider1.getValue();
	    Graphe graphe = new Graphe(false);

	    NbSommetsVisibles = 0;
	    if ( force3 ) stop();
	    if ( !mst1 && !mst2 && !mcl ) { graphe = gr;       gr.seuil       = val; }
	    if (  mst1 && !mst2 && !mcl ) { graphe = lArbre1;  lArbre1.seuil  = val; }
	    if ( !mst1 &&  mst2 && !mcl ) { graphe = lArbre2;  lArbre2.seuil  = val; }
	    if ( !mst1 && !mst2 &&  mcl ) { graphe = mg;       mg.seuil       = val; }
	    if ( connexe                ) { graphe = cnx;      cnx.seuil      = val; }
	    if ( morphing != null       ) { graphe = morphing; morphing.seuil = val; }
	    
	    NbSommetsVisibles = graphe.nombreSommets();

	    for ( int j = 0; j < graphe.aretes.size(); j++) {
		Arete a = graphe.getArete(j);
		Sommet s1 = a.getE1();
		Sommet s2 = a.getE2();
		
		if ( a.getVal() >= val && !a.getVisible() ) {
		    a.setVisible();
		    s1.setVisible();
		    s2.setVisible();
		    NbSommetsVisibles += 2;
		}
		if ( a.getVal() < val && a.getVisible() ) {
		    a.setInvisible();

		    if ( graphe.degre(graphe.indiceSommet(s1)) == 0 && graphe.masque){
			s1.setInvisible();
			if ( graphe.connexe ) 
			    
			NbSommetsVisibles -= 1;
		    }
		    if ( graphe.degre(graphe.indiceSommet(s2)) == 0 && graphe.masque){
			s2.setInvisible();
			NbSommetsVisibles -= 1;
		    }
		}
	    }
	    if ( force3 )
		start();
	    repaint();
	}
    }
    public void adjustmentValueChanged(AdjustmentEvent e) {}

    public void itemStateChanged(ItemEvent e) {
	Object src = e.getSource();
	boolean on = e.getStateChange() == ItemEvent.SELECTED;
	Graphe graphe = new Graphe(false);


	repaint();
    }
    public void menuSelected(MenuEvent e) {}
    public void menuDeselected(MenuEvent e) {}
    public void menuCanceled(MenuEvent e) {}
  
    
    //public void actionPerformed (ActionEvent e) {}

    public void start () {
	relaxer = new Thread(this);
	relaxer.start();
    }
    public void stop () {
	relaxer = null;	
    }
    
    public void start2 () {
	morph = new Thread(this);
	morph.start();
    }
    public void stop2 () {
	morph = null;	
    }
    public void run() {
	
	Thread anime = Thread.currentThread();
	
	while ( anime == relaxer ) {
	    if ( force3 ) {
		if ( morphing != null ) {
		    relax(morphing);
		    force_directed_placement(morphing); 	
		} 
		else if ( !mst1 && !mst2 && !mcl && !connexe ) {
		    relax(gr);
		    force_directed_placement(gr);
		}
		else if ( mst1 && !mst2 && !mcl && !connexe) {
		    relax(lArbre1);
		    force_directed_placement(lArbre1); 	
		} 
		else if ( !mst1 &&  mst2 && !mcl && !connexe) {
		    relax(lArbre2);
		    force_directed_placement(lArbre2); 
		} 
		else if ( connexe) {
		    relax(cnx);
		    force_directed_placement(cnx);
		}
		else if ( !mst1 && !mst2 && mcl && !connexe) {   
		    relax(mg);
		    force_directed_placement(mg);
		}
	    }
	    pause(200); 
	    repaint();
	}
	if ( anime == morph ) {
	     AnimeMorphing();
	     
	}
    }
    
    public void pause(int milliseconds) {
	try {
	    Thread.sleep(milliseconds);
	}
	catch (InterruptedException e) {
	    System.out.println(" Interrupted Exception ");
	}
    }

    synchronized void relax(Graphe graphe) {
	for ( int i = 0 ; i < graphe.nombreAretes() ; i++ ) {
	    Arete a = graphe.getArete(i);
	    Sommet e1 = a.getE1();
	    Sommet e2 = a.getE2();
	    double vx = e1.x - e2.x;
	    double vy = e1.y - e2.y;
	    
	    double distance = Math.sqrt(vx * vx + vy * vy);
	    
	    if ( distance == 0.0 ) distance = 0.0001;
	    
	    double force = (a.longueurCourante() - distance)/(3*distance);
	    double dx = force * vx;
	    double dy = force * vy;
	    
	    e1.dx += dx;
	    e1.dy += dy;
	    e2.dx += -dx;
	    e2.dy += -dy;
	}
	
	for ( int i = 0 ; i < graphe.nombreSommets(); i++ ) {
	    Sommet n1 = graphe.getSommet(i);
	   
	    double dx = 0.0;
	    double dy = 0.0;

	    for ( int j = 0 ; j < graphe.nombreSommets(); j++ ) {
		if (i == j)  continue;
     		Sommet n2 = graphe.getSommet(j);
		double vx = n1.x - n2.x;
		double vy = n1.y - n2.y;

		double distance = vx*vx + vy*vy; // norm(n1, n2)
		
		if ( distance == 0 ) {
		    dx += Math.random();
		    dy += Math.random();
		} else 
		    if ( distance < 100*100 ) {
			dx += vx / distance;
			dy += vy / distance;
		    }
	    }
	    double dforce = dx*dx + dy*dy;
	    if ( dforce > 0.0) {
		dforce = Math.sqrt(dforce) / 2;
		n1.dx += dx/dforce;
		n1.dy += dy/dforce;
	    }
	}
	Dimension d = getSize();

	for (int i = 0 ; i < graphe.nombreSommets() ; i++ ) {
	    Sommet n = graphe.getSommet(i);
	    if (!n.fixe) {
		n.x += (int)( Math.max(-5, Math.min(5, n.dx)) );
		n.y += (int)( Math.max(-5, Math.min(5, n.dy)) );
            }
            if ( n.x < 10 ) {
		n.x = 10;
	    } else if ( n.x > d.width ) {
		n.x = d.width;
	    }
	    if ( n.y < 25 ) {
		n.y = 25;
	    } else if ( n.y > d.height-40 ) {
		n.y = d.height-40;
	    }
	    n.dx /= 2;
	    n.dy /= 2;
	}
    }

    // FDP   
    public synchronized void force_directed_placement(Graphe graphe) {	
	double w = this.frame.getSize().getWidth();
	double h = this.frame.getSize().getHeight();
	gravite.x = (int)w/2;
	gravite.y = (int)h/2;
	//System.out.println("x = " + gravite.x);
	int nbvisible = 0;
	
	int ordre = graphe.nombreSommets();
	for ( int i = 0; i < ordre; i++ ) {
	    Sommet s = graphe.getSommet(i);
	    if ( s.getVisible() ) nbvisible++;
	}
	double k = Math.sqrt(w*h/nbvisible);
	double val =  control.slider2.getValue();
	Force.K(3*k*val/5);
	
	for ( int i = 0; i < graphe.nombreSommets(); i++ ) {
	    Sommet u = graphe.getSommet(i);
	    if ( u.getVisible() ) {
		u.stabilize();
		u.dx += 5;
		double xg = (double)( u.x - gravite.x );
		double yg = (double)( u.y - gravite.y );
		double dg = Math.sqrt( xg*xg + yg*yg );

		//if ( dg > 0.00001 ) 
		  //  u.forced( gravite, -0.08/dg*Force.fa(dg) );

		// ******** Calcul des forces repulsives 

		for ( int j = 0; j < graphe.nombreSommets(); j++ ) {
		    Sommet v = graphe.getSommet(j);
		    if ( !u.equals(v) && v.getVisible() ) {
			double xx = (double)(u.x - v.x);
			double yy = (double)(u.y - v.y);
			double distance = Math.sqrt(xx*xx + yy*yy); // distance entre u et v
			
			if ( distance > 3*k ) continue;
			if ( distance == 0.0 ) distance = 0.0001;
			u.forced( v, 1.0/distance*Force.fr(distance) );
		    }	
		    if ( !v.getVisible() ) 
			v.stabilize();			    
		}
		// Calcul des forces attractives
		graphe.getVoisins( u, false, graphe.seuil );
		for ( int j = 0; j < u.voisins.size(); j++ ) {
		    Sommet v = (Sommet)u.voisins.elementAt(j);
		    double xx = (double)(u.getX() - v.getX());
		    double yy = (double)(u.getY() - v.getY());
		    double distance =  Math.sqrt(xx*xx + yy*yy);
		    if (  v.getVisible() ) { 
			if ( (cluster2 && v.num_cluster != u.num_cluster ) || !cluster2 ) 
			    u.forced( v, -(1+val/10)/distance*Force.fa(distance) ); 
			
			if ( cluster2 && v.num_cluster == u.num_cluster ) 
			    u.forced( v, -(2+val/10)/distance*Force.fa(distance) );
		    }
		}
	    }
	}
	// Deplacement des sommets en fonction de la temperature globale du systeme
	
	double Temp = Force.temp(Force.time) + Force.minTemp();
	// Mise a jour de la temperature globale du systeme
	Force.Temp(Temp);

	for (int j = 0; j < graphe.nombreSommets(); j++ ) {
	    Sommet v = graphe.getSommet(j);
	    if ( v.getVisible() ) {
		double force = v.deltaForce();

		if( force < 0.00001 && Force.time < 100 ) continue;

		if ( !v.fixe && force > Force.minTemp()) {
		    v.moveDelta( 1.0/force * Force.min( force/5, Temp/5) );
		}
	    }
	}
	Force.time += 1.0;
    }

    public synchronized void force_directed_placement2(Graphe graphe) {
	double w = this.frame.getSize().getWidth();
	double h = this.frame.getSize().getHeight()-20;
	gravite.x = (int)w/2;
	gravite.y = (int)h/2;

	int nbvisible = 0;

	int ordre = graphe.nombreSommets();
	for ( int i = 0; i < ordre; i++ ) {
	    Sommet s = graphe.getSommet(i);
	    if ( s.getVisible() ) nbvisible++;
	}
	double k = Math.sqrt(w*h/nbvisible);
	double val =  control.slider2.getValue();
	Force.K(3*k*val/5);

	for ( int i = 0; i < graphe.nombreSommets(); i++ ) {
	    Sommet u = graphe.getSommet(i);
	    if ( u.getVisible() ) {
		u.stabilize();
		u.dx += 5;
		double xg = (double)( u.x - gravite.x );
		double yg = (double)( u.y - gravite.y );
		double dg = Math.sqrt( xg*xg + yg*yg );

		if ( dg > 0.00001 )
		    u.forced( gravite, -0.08/dg*Force.fa(dg) );

		// ******** Calcul des forces repulsives

		for ( int j = 0; j < graphe.nombreSommets(); j++ ) {
		    Sommet v = graphe.getSommet(j);
		    if ( !u.equals(v) && v.getVisible() ) {
			double xx = (double)(u.x - v.x);
			double yy = (double)(u.y - v.y);
			double distance = Math.sqrt(xx*xx + yy*yy); // distance entre u et v

			if ( distance > 3*k ) continue;
			if ( distance == 0.0 ) distance = 0.0001;
			u.forced( v, 1.0/distance*Force.fr(distance) );
		    }
		    if ( !v.getVisible() )
			v.stabilize();
		}
	    }
	}
	// Calcul des forces attractives

	for ( int j = 0; j < graphe.aretes.size(); j++ ) {
	    Arete a = graphe.getArete(j);
	    Sommet v = a.getE1();
	    Sommet u = a.getE2();
	    double xx = (double)(u.getX() - v.getX());
	    double yy = (double)(u.getY() - v.getY());
	    double distance =  Math.sqrt(xx*xx + yy*yy);
	    if ( a.getVal() > graphe.seuil && v.getVisible() && u.getVisible() && 
		 a.getVisible() && distance > 0.00001 ) { 
		if ( (cluster2 && v.num_cluster != u.num_cluster ) || !cluster2 ) {
		    u.forced( v, -1/distance*Force.fa(distance) ); 
		    v.forced( u, -1/distance*Force.fa(distance) ); 
		}
		
		if ( cluster2 && v.num_cluster == u.num_cluster ) {
		    u.forced( v, -2/distance*Force.fa(distance) );
		    v.forced( u, -2/distance*Force.fa(distance) );
		}
	    }
	}
     	
	// Deplacement des sommets en fonction de la temperature globale du systeme
	
	double Temp = Force.temp(Force.time) + Force.minTemp();
	// Mise a jour de la temperature globale du systeme
	Force.Temp(Temp);
	
	for (int j = 0; j < graphe.nombreSommets(); j++ ) {
	    Sommet v = graphe.getSommet(j);
	    
	    if ( v.getVisible() ) {
		double force = v.deltaForce();
		
		if( force < 0.00001 && Force.time < 100 ) continue;
		
		if ( !v.fixe && force > Force.minTemp()) { 
		    v.moveDelta( 1.0/force * Force.min( force/5, Temp/5) );
		}   
	    }
	}
	Force.time += 1.0;
    }
    /* Representation circulaire du graphe */
    public  void circulaire( Graphe graphe ) {
	double w = getSize().getWidth()  - 20;
	double h = getSize().getHeight() - 40;
	double rX, rY;

	rX = w/2.0;
	rY = h/2.0;

	int nb_classe0 = 0;
	int nb_classe1 = 0;
	for ( int i = 0; i < graphe.nombreSommets(); i++ ) {
	    Sommet s = graphe.getSommet(i);
	    if ( s.type == 0 && s.getVisible()) nb_classe0++;
	    if ( s.type == 1 && s.getVisible()) nb_classe1++;
	}

	double theta0 = 3*Math.PI/2;       
        double delta0 = 2*Math.PI/nb_classe0 ;

	double theta1 = 3*Math.PI/2;
	double delta1 = 2*Math.PI/nb_classe1;

	if ( graphe.typeMat == 0 || graphe.typeMat == 3 ) {
	    for (int i = 0; i < graphe.nombreSommets(); i++) {
		Sommet s = graphe.getSommet(i);
		
		if ( s.type == 1 && s.getVisible()){
		    s.x =  (int)(w/2 + ( rX - 16 )*Math.cos(theta1));
		    s.y =  (int)(h/2 + ( rY - 16 )*Math.sin(theta1));
		    theta1 += delta1;
		}
	    	if ( s.type == 0 && s.getVisible()){
		    s.x =  (int)(w/2 + ( 2*rX/3 - 6 )*Math.cos(theta0));
		    s.y =  (int)(h/2 + ( 2*rY/3 - 6 )*Math.sin(theta0));
		    theta0 += delta0;
		}
	    }
	} 
	if ( graphe.typeMat == 1 || graphe.typeMat == 2 ) {
	    if ( cluster2 ) {
		for (int i = 0; i < nbClusters; i++) {
		    int indice = ((Integer)(Clusters[i].elementAt(0))).intValue();
		    try {
			Sommet s = graphe.getSommet(indice);
			s.x =  (int)(w/2 + ( rX - 16 )*Math.cos(theta1));
			s.y =  (int)(h/2 + ( rY - 16 )*Math.sin(theta1));
			theta1 += delta1;
			for (int j = 1; j < Clusters[i].size(); j++) {
			    int ind = ((Integer)(Clusters[i].elementAt(j))).intValue();
			    Sommet ss= graphe.getSommet(ind);
			    ss.x =  (int)(w/2 + ( rX - 16 )*Math.cos(theta1));
			    ss.y =  (int)(h/2 + ( rY - 16 )*Math.sin(theta1));
			    theta1 += delta1;
			} 
		    } catch (ArrayIndexOutOfBoundsException e) {
			//System.out.println("\nArrayIndexOutOfBoundsException : " + e );
			continue;
		    }
		}
	    }
	    else
		for ( int i = 0; i < graphe.nombreSommets(); i++ ) {
		    Sommet s = graphe.getSommet(i);
		    
		    if ( s.type == 1 && s.getVisible()) {	
			s.x =  (int)(w/2 + ( rX - 16 )*Math.cos(theta1 ));
			s.y =  (int)(h/2 + ( rY - 16 )*Math.sin(theta1 ));
			theta1 += delta1;
		    }
		}
	}
    }
    
    public  void circulaireClustered( Graphe gr ) {
	
	if ( gr.typeMat == 1 || gr.typeMat == 2 ) {
	    double theta = 0.0;
	    
	    for ( int i = 0; i < nbClusters; i++ ) {
		double maxMetrique = 0;
		int rep = 0;
		Sommet noyau = new Sommet(0, 0);
		for ( int j = 0; j < Clusters[i].size(); j++ ) {
		    int indice = ((Integer)(Clusters[i].elementAt(j))).intValue();
		    noyau =  gr.getSommet(indice);
		    noyau.fixe = false;
		    if ( noyau.metrique > maxMetrique ) {
			maxMetrique = noyau.metrique;
			rep = indice;	
		    }
		}
		noyau =  gr.getSommet(rep);
		noyau.fixe = true;
		
		double rayon = 10.0; 
		metaNoeud cluster = (metaNoeud)mg.getSommet(i);
		noyau.x = cluster.x;
		noyau.y = cluster.y;
		double delta = 2*Math.PI/( Clusters[i].size()-1 );
		
		for ( int j = 0; j < Clusters[i].size(); j++ ) {
		    Sommet s = (Sommet)(cluster.sommets.elementAt(j)); 
		    if ( !s.equals(noyau) ) {
			s.x = (int)(noyau.x + rayon*Math.cos(theta));
			s.y = (int)(noyau.y + rayon*Math.sin(theta));
			rayon += 0.25;
			theta += delta;
		    }
		}
	    }
	}
    }
	
    public void ArbreCouvrant( Graphe graphe ) {	
	System.out.println(" Arbre Maximal Partiel ");
	if ( lArbre1 == null ) 
	    lArbre1 = graphe.determineArbrePrim();
		
	lArbre1.typeGraphe = graphe.typeGraphe;
	lArbre1.typeMat = graphe.typeMat;
	lArbre1.instance = graphe.instance;
	lArbre1.sans = graphe.sans;
	lArbre1.longs = graphe.longs;
	lArbre1.cercle  = graphe.cercle;
	lArbre1.maxMetrique1 = graphe.maxMetrique1;
	lArbre1.maxMetrique2 = graphe.maxMetrique2;	
	lArbre1.TrierAretes();
	if ( lArbre1 != null ) {  
	    control.slider1.setMinimum((int)lArbre1.minArete);
	    control.slider1.setValue((int)lArbre1.minArete);
	    control.slider1.setMaximum((int)lArbre1.maxArete);
	    control.slider1.setMinorTickSpacing(1);
	}
    }

    public void ArbreCouvrant2( Graphe graphe ) {
	System.out.println(" Arbre Minimal Partiel ");
	if ( lArbre2 == null )
	    lArbre2 = graphe.determineArbrePrim2();

	lArbre2.typeGraphe = graphe.typeGraphe;
	lArbre2.typeMat = graphe.typeMat;
	lArbre2.instance = graphe.instance;
	lArbre2.sans = graphe.sans;
	lArbre2.longs = graphe.longs;
	lArbre2.cercle  = graphe.cercle;
	lArbre2.maxMetrique1 = graphe.maxMetrique1;
	lArbre2.maxMetrique2 = graphe.maxMetrique2;
	lArbre2.typeGraphe = graphe.typeGraphe;
	lArbre2.TrierAretes();
	if ( lArbre2 != null ) {
	    control.slider1.setMinimum((int)lArbre2.minArete);
	    control.slider1.setValue((int)lArbre2.minArete);
	    control.slider1.setMaximum((int)lArbre2.maxArete);
	    control.slider1.setMinorTickSpacing(1);
	}
    }

    public void colorerGraphe(Graphe graphe, Color cl) {
	int na = gr.nombreAretes();
	for (int i = 0; i < na; i++) {
	    Arete a = gr.getArete(i);
	    if ( graphe.areteDansGraphe(a.getE1(), a.getE2()) != -1 ||
		 graphe.areteDansGraphe(a.getE2(), a.getE1()) != -1 )
		 a.setCouleur(cl);
	}
    }
   
    public void MCL(String args ) {

    	int nbvisible = 0;
	int ordre = gr.nombreSommets();
	if ( gr.typeMat == 1 ||  gr.typeMat == 2 ) {
	    for ( int i = 0; i < ordre; i++ ) {
		Sommet s = gr.getSommet(i);
		if( s.getVisible() ) nbvisible++;
	    }
	    try {
		Writer out = new FileWriter (args);
		out.write("(mclheader\n");
		out.write("mcltype matrix \n"); 
		out.write("dimensions "+nbvisible+"x"+nbvisible );
		out.write("\n)\n");
		out.write("(mclmatrix\n");
		out.write("begin\n");
		for ( int i = 0; i < ordre; i++ ) {
		    Sommet s = gr.getSommet(i);
		    if ( s.getVisible() ) {
			gr.getVoisins(s, false, gr.seuil );
			out.write(i + "    " );
			for ( int j = 0; j < s.voisins.size(); j++ ) {
			    Sommet ss = (Sommet)s.voisins.elementAt(j);
			    if ( ss.getVisible() && s.getVisible()) {
				Arete a = gr.getArete(gr.areteDansGraphe(s, ss));
				if ( a.getVisible() ) 
				    out.write( gr.indiceSommet(ss) + ":" + a.getVal()+ " ");
			    }
			}
			out.write("$\n");
		    }
		}
		out.write(")\n");
		out.close();
	
	    }
	    catch ( IOException e) {
		System.out.println(" Erreur " + e);
	    }
	    try { 
		 
		String cheminbin = System.getProperty("cheminBin")+"/bin/clustering "; 
		String cheminout = System.getProperty("cheminResult")+"/out.clusters";  
		Process pr2 =
		    Runtime.getRuntime().exec(cheminbin  + args + " -I " + facteur + " -o " + cheminout); 
		pr2.waitFor();
		gr.clustering = true;
		
	    }
	    catch (Exception e) {
                System.out.println(" Erreur de Clustering " + e);
            }
	} else {
	   System.out.println(" Le Clustering ne s'applique que sur des matrices symétriques"); 
	   gr.clustering = false;
	}
	//gr.clustering = true;
	repaint();

    }
    public void lireClustersMCL(String args) {
	char[] ordre;
	nbClusters = 0;
	String texte;
	int nb_clusters;
	try {
	    File file = new File (args);
	    Reader rd_result = new FileReader (file); 
	    String ligne_doc = null;
	    LineNumberReader line = new LineNumberReader(rd_result);
	    
	    ligne_doc = line.readLine();
	    ligne_doc = line.readLine();
	    ligne_doc = line.readLine();
	    
	    StringTokenizer ligne = new StringTokenizer(ligne_doc); 
	    String tt = ligne.nextToken();
	    tt = ligne.nextToken();
	    StringTokenizer dimension = new StringTokenizer(tt, "x");

	    String  nbso    = dimension.nextToken();
	    String clusters = dimension.nextToken();

	    nbClusters    = Integer.parseInt(clusters);
	    int nbsommets = Integer.parseInt(nbso);

	    Clusters = new Vector[nbClusters];
	   
	    while ( ligne_doc != null && ligne_doc.compareTo("begin") != 0 ) 
		ligne_doc = line.readLine();
	    
	    ligne_doc = line.readLine();
	    int i = line.getLineNumber()-7;
	    while ( ligne_doc != null && ligne_doc.compareTo(")") != 0 ) {
		StringTokenizer cluster = new StringTokenizer(ligne_doc);
		Clusters[i] = new Vector();

		String element_cluster = cluster.nextToken();
		element_cluster = cluster.nextToken();
		
		while ( element_cluster.compareTo("$") != 0 ) {
		    Clusters[i].addElement(new Integer(element_cluster));
		    try {
			element_cluster = cluster.nextToken();
			
		    } catch (NoSuchElementException EE) {
			ligne_doc = line.readLine();
			cluster = new StringTokenizer(ligne_doc); 
			element_cluster = cluster.nextToken();
		    } 
		}
		ligne_doc = line.readLine();
		i++;
	    }
	    line.close();
	}
	catch ( IOException e ) {
	    System.out.println(" Erreur : " + e );
	}
    }

    public void genereClusters(Graphe graphe) {
	mg.sommets = new Vector(nbClusters);
	mg.aretes = new Vector();
	mg.typeGraphe = gr.typeGraphe;
	mg.typeMat = gr.typeMat;
	mg.instance = gr.instance;
	String nom = null;
	int degre = 1;

	System.out.println("Le graphe est décomposé en " + nbClusters + " classes.");
	System.out.println("Construction du méta-graphe");
	for ( int i = 0; i < nbClusters; i++ ) {
	    int indice = ((Integer)(Clusters[i].elementAt(0))).intValue();
	    Sommet s = graphe.getSommet(indice);
	    s.fixe = false;
	    metaNoeud mn = new metaNoeud( "Cluster " + String.valueOf(i), s.x, s.y );
	    
	    s.num_cluster = i;
	   
	    for ( int j = 0; j < Clusters[i].size(); j++ ) {
		int ind = ((Integer)(Clusters[i].elementAt(j))).intValue();
		Sommet ss = graphe.getSommet(ind);
		ss.type = 1;
		mn.sommets.addElement(ss);
		ss.num_cluster = i;
		mn.metrique += ss.metrique;
		
		for ( int l = 1; l <= graphe.instance ; l++ ) 
		    mn.Metrique[l] += ss.Metrique[l];
		
		mn.Metrique[graphe.instance+1] += ss.Metrique[graphe.instance+1];
	    }

	    mn.type = 1;
	    mn.couleur = s.couleurClasse;
	    mn.couleurClasse = s.couleurClasse;
	    mg.sommets.addElement((Sommet)mn);   
	    //System.out.println(" mn.nom " + mn.couleurClasse + " s.nom "+ s.nom +" la couleur de sa classe "+ s.couleurClasse);
	    int cpt_intra_aretes = 0;

	    for ( int k = 0; k < graphe.aretes.size(); k++ ) {
		Arete a = graphe.getArete(k);
		Sommet e1 = a.getE1();
		Sommet e2 = a.getE2();

		if ( e1.num_cluster == e2.num_cluster ) {
		    Arete intra_arete = new Arete(e1, e2, e1.x, e2.x, null, a.getNom(), 
						  cpt_intra_aretes++ );
		    intra_arete.setVal(a.getVal());
		    mn.aretes.addElement(intra_arete);
		}
	    }
	}
	mg.maximumMetrique();

	int cpt_meta_aretes = 0;

	for ( int i = 0; i < graphe.aretes.size(); i++) {
	    Arete a = graphe.getArete(i);
	    Sommet e1 = a.getE1();
	    Sommet e2 = a.getE2();
	    if ( e1.num_cluster != e2.num_cluster ) {
		metaNoeud m1 = ( metaNoeud)mg.getSommet(e1.num_cluster);
		metaNoeud m2 = ( metaNoeud)mg.getSommet(e2.num_cluster);
		
		Arete meta_arete = new Arete( m1, m2, m1.x, m2.x, null, a.getNom(), 
					     cpt_meta_aretes++ );
		meta_arete.setVal(a.getVal());
		mg.aretes.addElement(meta_arete); 
	    }
	}
	mg.maximumArete();
    }
    
    public void imprimer() {
	PrinterJob prj = PrinterJob.getPrinterJob();
	prj.setPrintable((Printable)this);
	
	if( prj.printDialog()) {
	    try{
		prj.print();
	    }
	    catch (PrinterException pe) {
		System.out.println(pe);
	    }
	}
    }
    
    public int print( Graphics g, PageFormat pf, int pageIndex ) {
	if( pageIndex == 0 ) {
	    paintComponent(g);
	    return PAGE_EXISTS;
	}
	else return NO_SUCH_PAGE;
    }

    // Sauvegarde le trace du graphe pour une eventuelle utilisation
    public void SauvegarderGraphe(Graphe graphe) { 
	String rep = System.getProperty("user.dir");
	File fichier;
	FileFilter filtre = new FileFilter() {
	    public boolean accept(File f1) {
		return (f1.isDirectory() || f1.getName().endsWith(".gr"));
	    }
	    public String getDescription() {
		return ("Fichier Graph (*" + ".gr" + ")");
	    }
	};
	JFileChooser boite = new JFileChooser(rep);
	boite.addChoosableFileFilter(filtre);
	boite.setFileFilter(filtre);
	int option = boite.showSaveDialog(frame);
	if (option == JFileChooser.APPROVE_OPTION) {
	    fichier = boite.getSelectedFile();
	    if(fichier.getName().endsWith(".gr")) {
		rep = boite.getCurrentDirectory().getAbsolutePath();
		if (fichier.exists()) {
		    int i = JOptionPane.showConfirmDialog(null,"Le fichier existe déjà, écraser ?",
							  "Attention",
							  JOptionPane.YES_NO_OPTION,
							  JOptionPane.WARNING_MESSAGE);
		}
		// Je transforme en Coordonnees
		transforme(fichier.getAbsolutePath(), graphe);
		JOptionPane.showMessageDialog(frame, "Génération du dessin en coordonnees effectuée");
	    } else {
		JOptionPane.showMessageDialog(null,
					      "Le fichier sélectionné doit etre du type .gr",
					      "Type de fichier non valide",
					      JOptionPane.INFORMATION_MESSAGE);
	    };
	} 
    }
    
    public void transforme(String nom, Graphe graphe) {
	// Ouverture du fichier en écriture
	try {
	    BufferedWriter out = new BufferedWriter(new FileWriter(nom));
	    try {
		for ( int i = 0; i < gr.nombreSommets(); i++ ) {
		    Sommet s = graphe.getSommet(i);
		    out.write(s.nom + " : " + s.x + " " + s.y+"\n");
		}
	    }
	    catch (IOException e) {   
	    }
	    out.close();
	} catch (IOException e) {
	    
	}
	
    }

    public static void main(String[] argv) {

	String instance = argv[1];
	int type = Integer.parseInt(argv[2]);
	int periode = Integer.parseInt(argv[3]);
	Graphe gr = new Graphe(false);
	String fichierCoord = argv[1].concat(".gr");
	File fileCoord = new File(fichierCoord);
	//System.out.println(" instance = " + instance + " periode = " + periode );

	if ( type == 1 || type == 2 ) {	 
	    gr.ChargerMatriceSymetrique( argv[1], periode ); 
	}
	if ( type == 0 || type == 3 )
	    gr.ChargerMatriceAsymetrique( argv[1], periode);

	gr.typeMat = type;
	
	
	GraphPanel tgr2 = new GraphPanel( gr, true );


	StringTokenizer chemin  = new StringTokenizer( argv[0], "/");
	StringTokenizer chemin2 = new StringTokenizer( argv[1], "/");
	String repertoire = null;
	String fichier2 = null;

	while (chemin.hasMoreTokens() ) 
	    repertoire = chemin.nextToken();

	while (chemin2.hasMoreTokens() ) 
	    fichier2 = chemin2.nextToken();

	fichier2 = fichier2.substring(0, fichier2.length());
	tgr2.titre= fichier2;
	tgr2.frame.setTitle( "Tétralogie VisuGraph : " + fichier2 + "                 Graphe initial");
	tgr2.frame.setLocation(210, 0);
	String repertoire2 = argv[0].concat("/");
	if ( type == 0 ) {
	    String fichier  = repertoire2.concat(repertoire.concat(".varA"));
	    tgr2.nomslongs.LireNomsLongs(fichier);
	    fichier  = repertoire2.concat(repertoire.concat(".indA"));
	    NomLongs nomslongsbis = new NomLongs();
	    nomslongsbis.LireNomsLongs(fichier );
	    tgr2.nomslongs.data.putAll(nomslongsbis.data);
	} else {
	    String fichier  = repertoire2.concat(repertoire.concat(".indA"));
	    tgr2.nomslongs.LireNomsLongs(fichier );
	}
	
	for ( int i = 0; i < gr.nombreSommets(); i++ ) {
	    Sommet s = gr.getSommet(i);	    
	    s.nomlong = (String)tgr2.nomslongs.data.get( (Object)(s.nom) );	    
	}	
	
	tgr2.Items = new String[gr.nombreSommets()];

	tgr2.NbSommetsVisibles = gr.nombreSommets();

    	for ( int i = 0; i < gr.nombreSommets(); i++ ) {
	    Sommet s = gr.getSommet(i);
	    if ( s.nomlong != null )
		tgr2.Items[i] = s.nomlong;  
	    else {
		tgr2.Items[i] = s.nom;  
		s.nomlong     = s.nom;  
	    }
	}	
	tgr2.triRapide( tgr2.Items, 0, gr.nombreSommets() - 1 );	
	tgr2.gr.maximumMetrique();
	
	gr.TrierAretes();
	tgr2.init(periode);

	tgr2.gr.centre =  gr.getSommet(0);
	tgr2.gr.SetCouleursAretes(tgr2.gr.intensite);
	tgr2.Force = new ForceDirect( gr, 10 );
	tgr2.frame.addWindowListener( new WindowAdapter() {
	    public void windowClosing(WindowEvent evt) {
		System.exit(0);
	    }
	});
    }
}

class MenuItemListener implements ActionListener {
   
    private GraphPanel gp;
    JMenuBar barreMenus;
    JMenu Animation, Labels, Representation, Clustering, icones, edition;
    JMenuItem parametres, fdp, Random, arret, circulaire, cluster, stochastique, 
	MST, mst, metaGraphe, origine, imprimer, quitter,
	sans, court, longs, pcercle, cercle, histog, classe, sauver, HF, HV, masquage, barre, valien, PV;

    public MenuItemListener(GraphPanel gp) {
	this.gp = gp;

	if (gp.control.slider5 != null )
	    gp.control.slider5.addChangeListener(new NouvelleTache());

	barreMenus = new JMenuBar();
 /* Conception du menu à base d'items et de boutons radios */
	edition = new JMenu("Edition");
/* On souligne la première lettre de Edition, montrant ainsi une tête de liste d'item */
	edition.setMnemonic(KeyEvent.VK_E);
	//barreMenus.add(edition);

	imprimer = new JMenuItem("Imprimer");
	imprimer.addActionListener(this);
	imprimer.setMnemonic(KeyEvent.VK_I);
	edition.add(imprimer);

	Animation = new JMenu("Animation");
	Animation.addActionListener(this);
	Animation.setMnemonic(KeyEvent.VK_A);

	parametres = new JMenuItem("Paramètres");
	parametres.addActionListener(this);
	Animation.add(parametres);
	Animation.addSeparator();
	fdp = new JMenuItem("Forces"); // mon FDP
	fdp.addActionListener(this);
	Animation.add(fdp);

	Random = new JMenuItem("Aléatoire");
	Random.addActionListener(this);
	Animation.add(Random);

	arret = new JMenuItem("Arrêter");   // arret de l'animation
	arret.addActionListener(this);
	Animation.add(arret);
	Animation.addSeparator();

	sauver =  new JMenuItem("Enregistrer");   // arret de l'animation
	sauver.addActionListener(this);
	//Animation.add(sauver);
	//Animation.addSeparator();

	quitter =  new JMenuItem("Quitter");
	quitter.addActionListener(this);
	Animation.add(quitter);

	barreMenus.add(Animation);

	Representation = new JMenu("Représentation"); //  menu  Representation
	Representation.addActionListener(this);
	Representation.setMnemonic(KeyEvent.VK_R);
	Representation.addSeparator();
	circulaire = new JCheckBoxMenuItem("Circulaire");
	circulaire.addActionListener(this);
	Representation.add(circulaire);

	mst = new JCheckBoxMenuItem("Arbre Maximal");
	mst.addActionListener(this);
	mst.addChangeListener(new NouvelleTache());
	Representation.add(mst);

	MST = new JCheckBoxMenuItem("Arbre Minimal");
	MST.addActionListener(this);
	MST.addChangeListener(new NouvelleTache());
	Representation.add(MST);

	metaGraphe = new JCheckBoxMenuItem("Graphe de Clusters");
	metaGraphe.addActionListener(this);
	metaGraphe.addChangeListener(new NouvelleTache());
	Representation.add(metaGraphe);

	origine = new JCheckBoxMenuItem("Graphe initial");
	origine.addActionListener(this);
	origine.addChangeListener(new NouvelleTache());
	Representation.add(origine);

	PV = new JCheckBoxMenuItem("Proches voisins");
	PV.addActionListener(this);
	Representation.add(PV);

	barreMenus.add(Representation);

	Clustering = new JMenu("Clustering");	/*System.out.println(" Coordonnees : " + fichierCoord );
	if ( fileCoord.exists()) {
	    JOptionPane.showConfirmDialog(null,"Un fichier de coordonnées existe déjà, l'utiliser ?",
					  "Attention",
					  JOptionPane.YES_NO_OPTION,
					  JOptionPane.WARNING_MESSAGE);
	    try {
		Reader rd_result = new FileReader (fileCoord);
		LineNumberReader line = new LineNumberReader(rd_result);
		String ligne_doc = null;
		while ( ligne_doc != null ) {
		    ligne_doc = line.readLine();
		    StringTokenizer labc = new StringTokenizer(ligne_doc);
		    Sommet s = gr.getSommet(line.getLineNumber());

		    String str = labc.nextToken();
		    s.x = Integer.parseInt(str);
		    str = labc.nextToken();
		    s.y = Integer.parseInt(str);
		    System.out.println(s.nom + " : " + s.x +" : " + s.y );
		}
	    } catch (IOException ex) {
		;
	    }
	}*/
	Clustering.addActionListener(this);
	Clustering.setMnemonic(KeyEvent.VK_C);

	stochastique = new JMenuItem("Stochastique");
	stochastique.addActionListener(this);
	stochastique.addChangeListener( new NouvelleTache() );
	Clustering.add(stochastique);

	barreMenus.add(Clustering);

	JMenu menu = new JMenu("Sommets");
	menu.setMnemonic(KeyEvent.VK_S);

	FishEyeMenu subMenu = null;
	char label = ' ';
	JMenuItem item;
	for ( int i = 0; i < gp.Items.length; i++ ) {
	    if ( label != Character.toUpperCase(gp.Items[i].charAt(0)) ) {
		label  = Character.toUpperCase(gp.Items[i].charAt(0));
		subMenu = new FishEyeMenu(gp.Items[i].substring(0, 1).toUpperCase());
		menu.add(subMenu);
	    }
	    item = new JMenuItem( gp.Items[i] );
	    item.setLocation(menu.getLocation().x + 20, subMenu.getLocation().y );
	    item.addActionListener(this);
	    item.addChangeListener(new NouvelleTache());
	    subMenu.add(item);
	}

	barreMenus.add(menu);
	Labels = new JMenu("Labels");
	Labels.setMnemonic('L');
	barreMenus.add(Labels);
	
	sans = new JCheckBoxMenuItem("Sans");
	sans.addActionListener(this);
	Labels.add(sans);
	
	court = new JCheckBoxMenuItem("Court");
	court.addActionListener(this);       
	Labels.add(court);
	
	longs = new JCheckBoxMenuItem("Long");
	longs.addActionListener(this);            
	Labels.add(longs);

	valien = new JCheckBoxMenuItem("Valeurs des liens");
	valien.addActionListener(this);
	Labels.add(valien);

	icones = new JMenu("Icônes");
	icones.setMnemonic(KeyEvent.VK_I);
	barreMenus.add(icones);

	pcercle = new JCheckBoxMenuItem("Nuances");
	pcercle.addActionListener(this);
	icones.add(pcercle);

	cercle = new JCheckBoxMenuItem("Cercles");
	cercle.addActionListener(this);
	icones.add(cercle);

	histog = new JMenuItem("Histogrammes");
	histog.addActionListener(this);
	icones.add(histog);

/* Boutons permettant l'affichage des histogrammes lors du morphing. Soit chaque barre de l'histogramme représente une instance (Histo Fixe), soit seule la barre de l'histogramme, correpondant à l'instance en cours, change de couleur. */
	HF = new JCheckBoxMenuItem("     Histo fixe");
	HF.addActionListener(this);
	icones.add(HF);

	HV = new JCheckBoxMenuItem("     Histo variable");
	HV.addActionListener(this);
	icones.add(HV);

	barre = new JCheckBoxMenuItem("Barres");
	barre.addActionListener(this);
	icones.add(barre);

	classe = new JCheckBoxMenuItem("Classes");
	classe.addActionListener(this);
	icones.add(classe);

	masquage= new JCheckBoxMenuItem("Masquage");
	masquage.addActionListener(this);
	icones.add(masquage);

/*Gestion de l'individualité de la coche : si on coche "Histo Fixe", on ne peut pas cocher "Histo Variable" et vice - versa */
	ButtonGroup group0 = new ButtonGroup();
	group0.add(HV);
	group0.add(HF);

/*Gestion de l'individualité de la coche : si on coche "nuances", on ne peut pas cocher "cercle" ou "histog" et vice - versa */
/*	ButtonGroup group = new ButtonGroup();
	group.add(cercle);
	group.add(pcercle);
	group.add(histog);
	group.add(barre);*/

/*Gestion de l'individualité de la coche : si on coche "sans", on ne peut pas cocher "court" ou "longs" et vice - versa */
	ButtonGroup group2 = new ButtonGroup();
	group2.add(sans);
	group2.add(court);
	group2.add(longs);
     }

     class NouvelleTache implements ChangeListener {
	public void stateChanged(ChangeEvent e) {

	    if ( !gp.mst1 && !gp.mst2 && !gp.mcl && !gp.connexe && gp.control.slider5 != null) {
		if ( gp.control.slider5.getValue() == 0 ){
		    	gp.frame.setTitle( "Tétralogie VisuGraph : " + gp.titre + "                 Graphe initial");
			gp.frame.setLocation(210, 0);
	//gp.etatBarre.setString ("Graphe initial" );
		}else{
		    	gp.frame.setTitle( "Tétralogie VisuGraph : " + gp.titre + "                 Graphe d'instance : "+ gp.control.slider5.getValue());
			gp.frame.setLocation(210, 0);

		   /* gp.etatBarre.setString ("Graphe d'instance :  "  +
					    gp.control.slider5.getValue() );*/
		
	    	}
	    }
	    if ( gp.mst1 && !gp.mst2 && !gp.mcl && !gp.connexe && gp.lArbre1 != null)
		gp.etatBarre.setString ("Arbre de poids maximal");

	    if ( !gp.mst1 &&  gp.mst2 && !gp.mcl && !gp.connexe  && gp.lArbre2 != null)
		gp.etatBarre.setString ("Arbre de poids minimal");

	    if ( !gp.mst1 && !gp.mst2 && gp.mcl && !gp.connexe ) 
		gp.etatBarre.setString ("Graphe de classe" );

	    if ( ( gp.connexe && !gp.mst1 && !gp.mst2 && !gp.mcl ) ||
		 ( gp.connexe &&  gp.mst1 && !gp.mst2 && !gp.mcl ) ||
		 ( gp.connexe && !gp.mst1 &&  gp.mst2 && !gp.mcl ) ||
		 ( gp.connexe && !gp.mst1 && !gp.mst2 &&  gp.mcl )) {
		if ( gp.individuChoisi != null )
		    gp.etatBarre.setString ("Sous-Graphe de :" + gp.individuChoisi );
		else
		    gp.etatBarre.setString ("Sous-Graphe de :"  );
		
	    }

	    gp.etatBarre.setStringPainted(true);
	    gp.repaint();
	}

    }
    public void actionPerformed(ActionEvent e) {
	
	Object source = e.getSource(); // Extrait l'élément du menu sélectionné
	Dimension d = gp.getSize();


	/*if( source == sauver )  
	    gp.SauvegarderGraphe(gp.gr);
	else  */
	if( source == imprimer) gp.imprimer(); 
	else if( source == quitter )  {
	    gp.frame.dispose();
	    gp.control.fenetre.dispose();
	    System.exit(0); // Quitte le programme
	}
	else if (source == valien ) {
	    gp.on = valien.isSelected();
	    gp.gr.stress = gp.on;
	    if ( gp.lArbre1  != null )  gp.lArbre1.stress = gp.on;
	    if ( gp.lArbre2  != null )  gp.lArbre2.stress = gp.on;
	    if ( gp.mg       != null )       gp.mg.stress = gp.on;
	    if ( gp.cnx      != null )      gp.cnx.stress = gp.on;
	    if ( gp.morphing != null ) gp.morphing.stress = gp.on;
	}
	else if (source == sans ) { // sommets sans labels
	    gp.gr.sans  = true;
	    gp.gr.longs = false; 
	    if ( gp.mst1 && gp.lArbre1 != null ) {
		gp.lArbre1.sans  = gp.gr.sans;
		gp.lArbre1.longs = gp.gr.longs;
	    }
	    if ( gp.mst2 && gp.lArbre2 != null ) {
		gp.lArbre2.sans  = gp.gr.sans;
		gp.lArbre2.longs =gp.gr.longs ;
	    }
	    if ( gp.mcl && gp.mg != null ) {
		gp.mg.sans  = gp.gr.sans;
		gp.mg.longs = gp.gr.longs ;
	    }
	    if ( gp.connexe && gp.cnx != null ) {
		gp.cnx.sans  = gp.gr.sans;
		gp.cnx.longs = gp.gr.longs ;	
	    }   
	    if ( gp.morphing != null ) {
		gp.morphing.sans  = gp.gr.sans;
		gp.morphing.longs = gp.gr.longs ;
	    }
	}
	else if (source == court ) { // sommets avec labels courts
	    gp.gr.sans = false;
	    gp.gr.longs = false;
	   if ( gp.mst1 && gp.lArbre1 != null ) {
		gp.lArbre1.sans  = gp.gr.sans;
		gp.lArbre1.longs = gp.gr.longs;
	    }
	    if ( gp.mst2 && gp.lArbre2 != null ) {
		gp.lArbre2.sans  = gp.gr.sans;
		gp.lArbre2.longs = gp.gr.longs ;
	    }
	    if ( gp.mcl && gp.mg != null ) {
		gp.mg.sans  = gp.gr.sans;
		gp.mg.longs = gp.gr.longs ;
	    }
	    if ( gp.connexe && gp.cnx != null ) {
		gp.cnx.sans  = gp.gr.sans;
		gp.cnx.longs = gp.gr.longs ;	
	    }
	    if ( gp.morphing != null ) {
		gp.morphing.sans  = gp.gr.sans;
		gp.morphing.longs = gp.gr.longs ;
	    }
	}
	else if (source == longs ) { // sommets avec labels longs
	    gp.gr.sans = false;
	    gp.gr.longs = true;

	    if ( gp.lArbre1 != null ) {
		gp.lArbre1.sans  = gp.gr.sans;
		gp.lArbre1.longs = gp.gr.longs;
	    }
	    if ( gp.lArbre2 != null ) {
		gp.lArbre2.sans  = gp.gr.sans;
		gp.lArbre2.longs = gp.gr.longs ;
	    }
	    if ( gp.mg != null ) {
		gp.mg.sans  = gp.gr.sans;
		gp.mg.longs = gp.gr.longs ;
	    }
	    if ( gp.connexe && gp.cnx != null ) {
		gp.cnx.sans  = gp.gr.sans;
		gp.cnx.longs = gp.gr.longs ;	
	    }
	    if ( gp.morphing != null ) {
		gp.morphing.sans  = gp.gr.sans;
		gp.morphing.longs = gp.gr.longs ;
	    }
	}
	// type de dessin 
	else if (source == Random) { // dessin aleatoire
	    gp.random = true;
	    if ( !gp.mcl )
		for (int i = 0 ; i < gp.gr.nombreSommets() ; i++) {
		    Sommet n =  gp.gr.getSommet(i);
		    if (!n.fixe) {
			Point p = gp.gr.nouvellePosition(d.width, d.height);
			n.x = p.x ;
			n.y = p.y;
		    }
		}
	    else 
		for (int i = 0 ; i < gp.mg.nombreSommets() ; i++) {
		    Sommet n =  gp.mg.getSommet(i);
		    if (!n.fixe) {
			Point p = gp.mg.nouvellePosition(d.width, d.height);
			n.x = p.x ;
			n.y = p.y; 
		    }
		}
	} else if (source == fdp) {  // dessin avec animation
	    gp.force3 = true;
	    gp.circulaire = false;

	    if ( !gp.connexe && !gp.mst1 && !gp.mst2) {
		gp.Force = new ForceDirect(gp.gr, 10 );
		
		gp.Force.time = 1.0;
		gp.Force.Temp(10);
	    } else 
		if ( gp.connexe) { 
		    gp.Force = new ForceDirect(gp.cnx, 10 );
		    
		    gp.Force.time = 1.0;
		    gp.Force.Temp(10);
		}
		else 
		    if ( gp.mcl) {
			
			gp.Force = new ForceDirect(gp.mg, 10 );
			
			gp.Force.time = 1.0;
			gp.Force.Temp(10);
		    } 
	    if ( gp.mst1 || gp.mst2) {
		gp.Force = new ForceDirect(gp.mg, 10 );
		
		gp.Force.time = 1.0;
		gp.Force.Temp(10);
	    }
	    gp.start();  
	}
	else if (source == arret) { // arret de l'animation
	    gp.force3 = false; 
	    gp.stop();
	}
	else if ( source == circulaire ) {
	    gp.circulaire = true; 
	    gp.force3 = false;
	    gp.stop();
	    if ( gp.connexe ) 
		gp.circulaire(gp.cnx);
	    else 
		gp.circulaire(gp.gr);
	    if ( gp.mcl ) 
		gp.circulaire(gp.mg);
	    if ( gp.morphing != null ) 
		gp.circulaire(gp.morphing);

	} 
	else if ( source == parametres ) { //affichage de la fenetre des parametres
	    gp.control.fenetre.setVisible(true);
	}
	else if (source == stochastique ) { // clustering stochastique
	    gp.force3 = false;
	    
	    gp.stop();
	    String chemin =  System.getProperty("cheminResult"); 	   
	    String cheminin  =  chemin + "/clusters.out"; 
	    String cheminout =  chemin + "/out.clusters"; 
	    
	    gp.MCL(cheminin);
	    if ( gp.gr.clustering ) {
		System.out.println("Fin de clustering ");
		gp.cluster2 = true;
		gp.mcl = true; 
		gp.lireClustersMCL(cheminout);
		
		gp.initColor();
		gp.mg.sans = gp.gr.sans;
		gp.mg.longs = false;
		gp.mg.cercle  = gp.gr.cercle;
		
		for (int i = 0; i < gp.nbClusters; i++ ) {		
		    for (int j = 0; j < gp.Clusters[i].size(); j++) {
			int ind = ((Integer)(gp.Clusters[i].elementAt(j))).intValue();
			try {
			    Sommet s = gp.gr.getSommet(ind);
			    s.couleurClasse = gp.CouleursClusters[i];
			}catch (ArrayIndexOutOfBoundsException exception) {
			    ;
			}
		    }
		}
		gp.genereClusters(gp.gr);
		if (gp.flag) gp.circulaireClustered(gp.gr);
		gp.flag = false;
		
	    }
	}
	// types de structures
	else if (source == mst) { // arbre recouvrant minimum
	    if (gp.force3 ) gp.force3 = false;
	    gp.mst1 = true;
	    gp.mst2 = false; 
	    gp.mcl = false;
	    if ( !gp.connexe ) {
		gp.ArbreCouvrant(gp.gr);
		gp.lArbre1.cercle = gp.gr.cercle;
	    }
	    else {
		gp.ArbreCouvrant(gp.cnx);
	   	gp.lArbre1.cercle = gp.cnx.cercle;
	    }
	    if ( gp.lArbre1 != null) gp.lArbre1.clustering = gp.gr.clustering;

	}else if (source == MST) { // arbre recouvrant maximum
	    if (gp.force3 ) gp.force3 = false;
	    gp.mst1 = false;
	    gp.mst2 = true; 
	    gp.mcl = false;
	    
	    if ( !gp.connexe ) {
		gp.ArbreCouvrant2(gp.gr);
		gp.lArbre2.cercle = gp.gr.cercle;
	    }
	    else {
		gp.ArbreCouvrant2(gp.cnx);
		gp.lArbre2.cercle = gp.cnx.cercle;
	    }
	    if ( gp.lArbre2 != null) gp.lArbre2.clustering = gp.gr.clustering;
	}
	else if (source == origine) { // graphe d'origine
	    gp.mst1 = false;
	    gp.mst2 = false;
	    gp.mcl = false;
	    if (gp.flag ) {
		gp.circulaireClustered(gp.gr);
		gp.flag = false;
	    }
	    
	    gp.control.slider1.setMinimum((int)gp.gr.minArete);
	    gp.control.slider1.setValue((int)gp.gr.minArete);
	    gp.control.slider1.setMaximum((int)gp.gr.maxArete);
	    gp.control.slider1.setMinorTickSpacing(1);
	}
	else if ( source == PV ) {
   	    gp.on = PV.isSelected();
	    gp.connexe = gp.on;
	    gp.cnx.seuil = gp.control.slider1.getValue();
	    if ( gp.lArbre1 != null ) {
		gp.lArbre1.longs   = gp.gr.longs;
		gp.lArbre1.cercle  = gp.gr.cercle;
		gp.lArbre1.seuil = gp.cnx.seuil;
	    }
	    if ( gp.lArbre2 != null ) {
		gp.lArbre2.longs   = gp.gr.longs;
		gp.lArbre2.cercle  = gp.gr.cercle;
		gp.lArbre2.seuil = gp.cnx.seuil;
	    }
	    if ( gp.mg      != null ) {
		gp.mg.sans    = gp.gr.sans;
	    }
	    if ( gp.cnx     != null ) {
		gp.cnx.sans    = gp.gr.sans;
		gp.cnx.longs   = gp.gr.longs;
		gp.cnx.cercle  = gp.gr.cercle;

	    }
	    if ( gp.morphing != null ) {
		gp.morphing.sans    = gp.gr.sans;
		gp.morphing.longs   = gp.gr.longs;
		gp.morphing.cercle  = gp.gr.cercle;
		gp.morphing.seuil   = gp.cnx.seuil;
	    }
	}
	else if ( source == metaGraphe ) { // graphe de clusters : meta-graphe
	    if (gp.force3 ) gp.force3 = false;
	    gp.mst1 = false;
	    gp.mst2 = false;
	    if ( gp.gr.typeMat == 1 ) {
		gp.mcl = true;
		gp.mg.cercle  = gp.gr.cercle;
	    }
	    gp.control.slider1.setMinimum((int)gp.mg.minArete);
	    gp.control.slider1.setValue((int)gp.mg.minArete);
	    gp.control.slider1.setMaximum((int)gp.mg.maxArete);
	    gp.control.slider1.setMinorTickSpacing(1);
	}
	else if ( source == pcercle  ) {
	    gp.groupon = pcercle.isSelected();
	    if (gp.groupon == true) {
		gp.gr.cercle = 0;
		if ( gp.lArbre1 != null )
			gp.lArbre1.cercle = gp.gr.cercle;
		if ( gp.lArbre2 != null )
			gp.lArbre2.cercle = gp.gr.cercle;
		if ( gp.mg != null )
			gp.mg.cercle = gp.gr.cercle;
		if ( gp.connexe  )
			gp.cnx.cercle = gp.gr.cercle;
		if ( gp.morphing != null )
			gp.morphing.cercle = gp.gr.cercle;
		cercle.setSelected(false);
		barre.setSelected(false);
		classe.setSelected(false);

	    } else {
	    		gp.gr.cercle = 2;
			if ( gp.lArbre1 != null )
				gp.lArbre1.cercle  = gp.gr.cercle;
			if ( gp.lArbre2 != null )
				gp.lArbre2.cercle  = gp.gr.cercle;
			if ( gp.mg != null )
				gp.mg.cercle  = gp.gr.cercle;
			if ( gp.connexe )
				gp.cnx.cercle  = gp.gr.cercle;
			if ( gp.morphing != null )
				gp.morphing.cercle = gp.gr.cercle;
		}
	} else if ( source == cercle ) {
	    gp.groupon = cercle.isSelected();
	    if (gp.groupon == true) {
		gp.gr.cercle = 1;
		if ( gp.lArbre1 != null )
			gp.lArbre1.cercle  = gp.gr.cercle;
		if ( gp.lArbre2 != null )
			gp.lArbre2.cercle  = gp.gr.cercle;
		if ( gp.mg != null )
			gp.mg.cercle  = gp.gr.cercle;
		if ( gp.connexe )
			gp.cnx.cercle  = gp.gr.cercle;
		if ( gp.morphing != null )
			gp.morphing.cercle = gp.gr.cercle;
		pcercle.setSelected(false);

		barre.setSelected(false);
	     }else {
	      		gp.gr.cercle = 2;
			if ( gp.lArbre1 != null )
				gp.lArbre1.cercle  = gp.gr.cercle;
			if ( gp.lArbre2 != null )
				gp.lArbre2.cercle  = gp.gr.cercle;
			if ( gp.mg != null )
				gp.mg.cercle  = gp.gr.cercle;
			if ( gp.connexe )
				gp.cnx.cercle  = gp.gr.cercle;
			if ( gp.morphing != null )
				gp.morphing.cercle = gp.gr.cercle;
		}
		/*on est dans le cas où cercle a été coché ou décoché. on veut gérer alors la coche de classe et avoir les deux
		 à la fois (classe et cercle). on réapplique l'algorithme qui trace les classes et on controle qu'aucun autre choix
		 (nuances,histo, barre..) ne soit possible. */
		if (classe.isSelected()) {

		        gp.gr.clustering=true;
		}
	} else if ( source == histog ) {
	    gp.param=2;
	    gp.gr.cercle = 2;
	    if ( gp.lArbre1 != null )
		gp.lArbre1.cercle  = gp.gr.cercle;
	    if ( gp.lArbre2 != null )
		gp.lArbre2.cercle  = gp.gr.cercle;
	    if ( gp.mg != null )
		gp.mg.cercle  = gp.gr.cercle;
	    if ( gp.connexe )
		gp.cnx.cercle  = gp.gr.cercle;
	    if ( gp.morphing != null )
		gp.morphing.cercle = gp.gr.cercle;
	    cercle.setSelected(false);
	    pcercle.setSelected(false);
	    barre.setSelected(false);

	} else if ( source == classe ) {
		gp.classon = classe.isSelected();
	    /*if ( gp.gr.typeMat == 1 ||  gp.gr.typeMat == 2 )*/
		gp.gr.cercle = 3;
	    /*else gp.gr.cercle = 0;*/
		if (gp.classon == true){
			if ( gp.lArbre1 != null )  {gp.lArbre1.cercle  = gp.gr.cercle;}
			if ( gp.lArbre2 != null )  {gp.lArbre2.cercle  = gp.gr.cercle;}
			if ( gp.mg != null )       {gp.mg.cercle = gp.gr.cercle;}
			if ( gp.connexe )          {gp.cnx.cercle = gp.gr.cercle;}
			if ( gp.morphing != null ) {gp.morphing.cercle = gp.gr.cercle;}

			pcercle.setSelected(false);
		}
		else{
			gp.gr.cercle = 2;
			if ( gp.lArbre1 != null )  gp.lArbre1.cercle  = gp.gr.cercle;
			if ( gp.lArbre2 != null )  gp.lArbre2.cercle  = gp.gr.cercle;
			if ( gp.mg != null )       gp.mg.cercle  = gp.gr.cercle;
			if ( gp.connexe )          gp.cnx.cercle  = gp.gr.cercle;
			if ( gp.morphing != null ) gp.morphing.cercle = gp.gr.cercle;

		}
		if(pcercle.isSelected())    {pcercle.setSelected(false); pcercle.setSelected(true);}
		else if(cercle.isSelected())     {cercle.setSelected(false); cercle.setSelected(true);}
		else if(barre.isSelected())      {barre.setSelected(false); barre.setSelected(true);}

	} else if (source == HV){
		gp.param=2;
	    	cercle.setSelected(false);
	    	pcercle.setSelected(false);
	    	barre.setSelected(false);
		gp.gr.cercle = 2;
		if ( gp.lArbre1 != null )
			gp.lArbre1.cercle  = gp.gr.cercle;
		if ( gp.lArbre2 != null )
			gp.lArbre2.cercle  = gp.gr.cercle;
		if ( gp.mg != null )
			gp.mg.cercle  = gp.gr.cercle;
		if ( gp.connexe )
			gp.cnx.cercle  = gp.gr.cercle;
		if ( gp.morphing != null )
			gp.morphing.cercle = gp.gr.cercle;
	} else if (source == HF){
		gp.param=1;
		cercle.setSelected(false);
	    	pcercle.setSelected(false);
	    	barre.setSelected(false);
		gp.gr.cercle = 2;
		if ( gp.lArbre1 != null )
			gp.lArbre1.cercle  = gp.gr.cercle;
		if ( gp.lArbre2 != null )
			gp.lArbre2.cercle  = gp.gr.cercle;
		if ( gp.mg != null )
			gp.mg.cercle  = gp.gr.cercle;
		if ( gp.connexe )
			gp.cnx.cercle  = gp.gr.cercle;
		if ( gp.morphing != null )
			gp.morphing.cercle = gp.gr.cercle;
	}else if (source == barre){
	    gp.groupon = barre.isSelected();
	    System.out.println("je suis dans barre, quel etat ?  " + gp.groupon);
	    if (gp.groupon == true) {
		gp.param=3;
		cercle.setSelected(false);
		pcercle.setSelected(false);
		gp.gr.cercle = 2;
		if ( gp.lArbre1 != null )
			gp.lArbre1.cercle  = gp.gr.cercle;
		if ( gp.lArbre2 != null )
			gp.lArbre2.cercle  = gp.gr.cercle;
		if ( gp.mg != null )
			gp.mg.cercle  = gp.gr.cercle;
		if ( gp.connexe )
			gp.cnx.cercle  = gp.gr.cercle;
		if ( gp.morphing != null )
			gp.morphing.cercle = gp.gr.cercle;
	    }else {
		gp.gr.cercle = 2;
		if ( gp.lArbre1 != null )
			gp.lArbre1.cercle  = gp.gr.cercle;
		if ( gp.lArbre2 != null )
			gp.lArbre2.cercle  = gp.gr.cercle;
		if ( gp.mg != null )
			gp.mg.cercle  = gp.gr.cercle;
		if ( gp.connexe )
			gp.cnx.cercle  = gp.gr.cercle;
		if ( gp.morphing != null )
			gp.morphing.cercle = gp.gr.cercle;
		}

	}else if (source == masquage){

	    gp.on = masquage.isSelected();

	    gp.gr.masque   = gp.on;
	    Graphe graphe = new Graphe(false);
	    if ( !gp.mst1 && !gp.mst2 && !gp.mcl ) { gp.gr.masque = gp.on; graphe = gp.gr ; }
	    if (  gp.mst1 && !gp.mst2 && !gp.mcl ) { gp.lArbre1.masque = gp.on; graphe = gp.lArbre1;}
	    if ( !gp.mst1 &&  gp.mst2 && !gp.mcl ) { gp.lArbre2.masque = gp.on; graphe = gp.lArbre2;}
	    if ( !gp.mst1 && !gp.mst2 &&  gp.mcl ) { gp.mg.masque = gp.on; graphe = gp.mg ;}
	    if ( gp.connexe )                { gp.cnx.masque = gp.on; graphe = gp.cnx;}
	    if ( gp.morphing != null )       { gp.morphing.masque = gp.on; graphe = gp.morphing; }

	    for ( int i = 0; i < graphe.nombreSommets(); i++ ) {
		Sommet v = graphe.getSommet(i);
		graphe.getVoisins(v, false, graphe.seuil );

		if ( graphe.degre(graphe.indiceSommet(v)) == 0 &&
		     v.getVisible() && gp.on )
		    v.setInvisible();

		if ( graphe.degre(graphe.indiceSommet(v)) == 0 &&
		     !gp.on )
		    v.setVisible();
	    }
	    if ( gp.circulaire ) gp.circulaire(graphe);

	}else { // le cas d'exploration a partir d'un focus.
	    JMenuItem item = (JMenuItem)e.getSource();
	    gp.individuChoisi = item.getText();
	    Sommet selectionne = null;

	    int w = (int)(d.width- 20)/2;
	    int h = (int)(d.height-6)/2;
	    boolean trouve = false;
	    gp.cnx = null;
	    gp.cnx = new Graphe(false);
	    gp.cnx.typeGraphe = gp.gr.typeGraphe;
	    gp.cnx.instance = gp.gr.instance;

	    gp.cnx.stress = gp.gr.stress; 
	    gp.cnx.noms   = gp.gr.noms;
	    gp.cnx.cercle = gp.gr.cercle;
	    gp.cnx.longs  = gp.gr.longs;
	    gp.cnx.sans   = gp.gr.sans;
	    gp.cnx.maxMetrique1 = gp.gr.maxMetrique1;
	    gp.cnx.maxMetrique2 = gp.gr.maxMetrique2;
	    gp.cnx.maxArete = gp.gr.maxArete;
	    gp.cnx.typeMat = gp.gr.typeMat;
	    // Identification d'item selectionné dans le graphe d'origine
	    if ( !gp.mst1 || !gp.mst2 && gp.connexe == true) {
		for ( int i = 0; i < gp.gr.nombreSommets() && !trouve; i++) {
		    Sommet s = gp.gr.getSommet(i);
		    s.setCouleurTxt(Color.white);
		    if ( s.fixe ) {
			s.x += 20;
			s.y += 20;
			s.fixe = false;
		    }
		    s.marked = false; 
		    s.niveau = 100;
		    
		    if (( s.nom.compareToIgnoreCase(gp.individuChoisi) == 0 || 
			 s.nomlong.compareToIgnoreCase(gp.individuChoisi) == 0 ) ) {
			
			selectionne = s;
			selectionne.fixe = true;
			selectionne.x = w;
			selectionne.y = h;
			s.x = w;
			s.y = h;
			trouve = true;
			s.setCouleur(Color.black);
			//s.setCouleurTxt(Color.red);
			s.niveau = 0;
			gp.cnx.ajouterSommet(s);
		    }
		}
		// Recherche des voisins de l'item selectionné  
		gp.gr.getVoisins( selectionne, false, gp.cnx.seuil );
		for ( int i = 0; i < selectionne.voisins.size(); i++ ) { 
		    Sommet s = (Sommet)selectionne.voisins.elementAt(i); 
		    gp.cnx.ajouterSommet(s);
		    s.niveau = 1;
		    s.setCouleur(Color.red);
		    s.setCouleurTxt(Color.white);
		    //s.fixe = true;
		    int indice = gp.gr.areteDansGraphe(selectionne, s);  
		    if ( indice != -1 ) {
			Arete a = gp.gr.getArete(indice);
			gp.cnx.ajouterArete(a);
		    }
		}
		for ( int i = 0; i < gp.cnx.nombreSommets(); i++) { 
		    Sommet si = gp.cnx.getSommet(i);
		    for ( int j = 0; j < gp.cnx.nombreSommets(); j++) { 
			Sommet sj = gp.cnx.getSommet(j);
			if ( i != j ) {
			    int indice = gp.gr.areteDansGraphe(si, sj); 
			    if ( indice != -1 ) {
				Arete a = gp.gr.getArete(indice);
				gp.cnx.ajouterArete(a);
			    }
			}
		    }
		}
	    }
	    if ( gp.mst1 && !gp.mst2 && gp.connexe == true ) {
		for ( int i = 0; i < gp.lArbre1.nombreSommets(); i++) {
		    Sommet s = gp.lArbre1.getSommet(i);
		    
		    if ( s.fixe ) {
			s.x += 20;
			s.y += 20;
			s.fixe = false;
		    }
		    if ( s.nom.compareTo(gp.individuChoisi) == 0 ) {	
			selectionne = s;
			selectionne.fixe = true;
			selectionne.x = w;
			selectionne.y = h;
		    }
		}
	    }
	    if ( !gp.mst1 && gp.mst2 && gp.connexe == true ) {
		for ( int i = 0; i < gp.lArbre2.nombreSommets(); i++) {
		    Sommet s = gp.lArbre2.getSommet(i);	    
		    if ( s.fixe ) {
			s.x += 20;
			s.y += 20;
			s.fixe = false;
		    }
		    if ( s.nom.compareTo(gp.individuChoisi) == 0 ) {
			selectionne = s;
			selectionne.fixe = true;
			selectionne.x = w;
			selectionne.y = h;
		    }
		}	
	    }
	    gp.cnx.initDegre();
	    gp.cnx.maximumMetrique();
	    gp.cnx.maximumArete();
	    
	}
	gp.repaint();



    }
  }


import javax.swing.*;
import javax.swing.event.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.awt.print.*;
import java.lang.*;
import java.io.*;
import java.awt.geom.*;


public class GraphPanel extends  JPanel
    implements Runnable, ActionListener, MouseListener, ItemListener,  MenuListener, Printable { 
    
    public Graphe gr;
    public Graphe mg;
    public Graphe Cluster = new Graphe(false);
    public Graphe lArbre1 = new Graphe(false);
    public Graphe lArbre2 = new Graphe(false);
    public Graphe cnx = new Graphe(false);

    public Morphing morphing = null;

    private Graphics2D graphics;
    private boolean editable = true;
    private boolean dragging = false; 
    private Point ptDrag;
  
    public Sommet selection = null;
   
    Vector Clusters[];
    Color[] CouleursClusters;

    int nbClusters = 0;
    JFrame frame = new JFrame();

    int NbSommetsVisibles;

    Thread relaxer;
  
    boolean circulaire = false;
    boolean cluster2 = false;
    boolean force3 = false;
    boolean random = false;
    boolean mst1 = false, mst2 = false;
    boolean mcl = false;
    boolean connexe = false;

    int currentH  ;
    int currentW  ;
    ForceDirect Force;
    FishEyeMenu fisheye = null; 
    
    Sommet gravite = new Sommet(0, 0);
 
    String[] Items;
    
    NomLongs nomslongs = new NomLongs();
    ControlWindow control = null;

    JPopupMenu contenu;
    int noyau = 0;
    String individuChoisi;
    boolean flag = true;
    JProgressBar etatBarre = new JProgressBar();
    double facteur = 1.4;
   
    public void init(int periode) {

	control = new ControlWindow(periode);
	
	control.slider1.setMinimum((int)gr.minArete);
	control.slider1.setValue((int)gr.minArete);
	control.slider1.setMaximum((int)gr.maxArete);
	control.slider1.setMinorTickSpacing(1);

	control.slider1.addChangeListener(new nouveauSeuil()); 
	control.slider3.addChangeListener(new IntensiteCouleurs()); 
	control.slider4.addChangeListener(new FacteurClustering()); 
	control.slider5.addChangeListener(new ChoixTypeInstance());

	control.box1.addItemListener(this);	
	control.box2.addItemListener(this);
	control.box3.addItemListener(this);
	control.box4.addChangeListener(new ChoixTypeInstance());

	setLayout( new BorderLayout(600,600) );
	this.setBackground(Color.white);

	this.gr = gr;
	cnx.sans = gr.sans;
	cnx.longs = gr.longs;
	cnx.cercle = gr.cercle;
	lArbre1 = lArbre2 = null;
	if ( periode > 1 ) gr.typeGraphe = 2;
	else gr.typeGraphe = 1;
	

	this.frame.setSize( 600, 620 );
	final MenuItemListener menu = new MenuItemListener(this);

	etatBarre.setFont(new Font("Fixed", Font.BOLD , 14));
	etatBarre.setBackground(Color.lightGray);
	add("South", etatBarre);
	
	etatBarre.setString("Graphe initial ");
	etatBarre.setStringPainted(true);
	etatBarre.setVisible(true);

	this.frame.setResizable(true);
	this.frame.setJMenuBar(menu.barreMenus);
	this.frame.getContentPane().add(this, BorderLayout.CENTER );
	this.frame.setVisible(true);
	this.control.fenetre.setVisible(true);

    }

    public void initColor() {
	CouleursClusters = new Color[nbClusters];
	int tour = 0;
	CouleursClusters[0] = Color.blue;
	if ( nbClusters >= 2 )  CouleursClusters[1] = Color.cyan; 
	if ( nbClusters >= 3 )  CouleursClusters[2] = Color.green;
	if ( nbClusters >= 4 )  CouleursClusters[3] = Color.magenta ; 
	if ( nbClusters >= 5 )  CouleursClusters[4] = Color.orange; 
	if ( nbClusters >= 6 )  CouleursClusters[5] = Color.pink ; 
	if ( nbClusters >= 7 )  CouleursClusters[6] = Color.red ; 
	if ( nbClusters >= 8 )  CouleursClusters[7] = Color.yellow; 
	if ( nbClusters >= 9 )  CouleursClusters[8] = Color.lightGray;  
	if ( nbClusters >= 10 ) CouleursClusters[9] = Color.gray; 
	
	for ( int i = 10; i < nbClusters; i++ ) {
	    int nb = 0;
	    if (i%10 == 0 ) tour ++; 
	    float c0 = 255 - Clusters[i].size() ; 
	    float c1 =  0; 
	    float c2 = 0; 
	    CouleursClusters[i] = CouleursClusters[tour*i%10].darker();
	}
    }
    static void echangerElements( String[] t, int m, int n ) {
	String temp = t[m];

	t[m] = t[n];
	t[n] = temp;
    }

    static int partition( String[] t, int m, int n ) {
	String v = t[m];                 // valeur pivot
	int i = m-1;
	int j = n+1;                  // indice final du pivot

	while ( true ) {
	    do {
		j--;
	    } while ( t[j].compareTo(v) > 0 );
	    do {
		i++;
	    } while ( t[i].compareTo(v) < 0);
	    if ( i < j ) {
		echangerElements(t, i, j);
	    } else {
		return j;
	    }
	}
    }
    
    static void triRapide( String[] t, int m, int n ) {
	if ( m < n ) {
	    int p = partition(t, m, n); 
	    triRapide(t, m, p);
	    triRapide(t, p+1, n);
	}
    }
    
    GraphPanel(Graphe gr, boolean editable ) {
	super();
	this.gr = gr;
	
	this.mg = new Graphe(nbClusters);
	this.editable = editable;
	addMouseListener(this);
    }

    public Graphe getGraphe() { return gr; }
    public void setGraphe(Graphe gr) { this.gr = gr; repaint(); }
    public boolean getEditable() { return editable; }
    public void setEditable(boolean editable) { this.editable = editable; }

    public void centrerGraphe(Graphe g) {
	Dimension d = this.getSize();

	for (int i = 0; i < g.sommets.size(); i++) {
	    Sommet n = g.getSommet(i);

	    if (n.x < 10)  n.x = 10;
	    else if (n.x > d.width)
		n.x = d.width - n.larg;

	    if (n.y < 10) n.y = 10;
	    else if (n.y > d.height-40)
		n.y = d.height-40;
	}
    }
    
    public void paintComponent(Graphics g) {

	super.paintComponent(g);
	int instance = control.slider5.getValue();
	//System.out.println(" Instance = " + instance );
	if ( morphing != null ) {
	    centrerGraphe(morphing);
	    morphing.paintComponent(g);
	}

	if ( !connexe && morphing == null) {
	    if ( !mst1 && !mst2 && !mcl && instance == 0) {
		centrerGraphe(gr);
		gr.paintComponent(g);
	    }
	    else
		if ( mst1 && !mst2 && lArbre1 != null ) {
		    centrerGraphe(lArbre1);
		    lArbre1.paintComponent(g);
		} else
		    if ( !mst1 && mst2 && lArbre2 != null ) {
			centrerGraphe(lArbre2);
			lArbre2.paintComponent(g);
		    }else
			if ( mcl ) {
			    centrerGraphe(mg);
			    mg.paintComponent(g);
			}
	}
	else if ( cnx != null ) {
	    centrerGraphe(cnx);
	    cnx.paintComponent(g);
	}
	if ( dragging ) {
	    Color oldclr = g.getColor();
	    g.setColor(new Color(250, 125, 65) );
	    g.fillOval(ptDrag.x - Sommet.RAYON,
		       ptDrag.y - Sommet.RAYON,
		       2*Sommet.RAYON,
		       2*Sommet.RAYON);
	    g.setColor(oldclr);
	}
    }

    public void mouseDragged(MouseEvent e)
    {
	if ( (e.getModifiers() & MouseEvent.BUTTON1_MASK) == 0 || !dragging )
	    return;
	ptDrag = new Point(e.getX(), e.getY());
	repaint();
    }

    public void mouseMoved(MouseEvent e) {
	if ( contenu != null && contenu.isVisible() ) {
	    Object src = e.getSource();
	    System.out.println(src );
	}
    }
    
    public void mouseClicked(MouseEvent e) {
	Object src = e.getSource();
	int count = e.getClickCount();
	
	if ( e.getButton() == 1 && count >= 2) {
	    ptDrag = new Point(e.getX(), e.getY());
	    if ( morphing == null )
		selection = gr.hitTest(ptDrag, true);
	    else 
		selection = morphing.hitTest(ptDrag, true);
	    if ( selection != null ) {
		if ( selection.fixe) 
		    selection.fixe = false;
		else
		    selection.fixe = true;
	    } 
	}
	if ( e.getButton() == 2 && mcl ) {
	    ptDrag = new Point(e.getX(), e.getY());
	    selection = mg.hitTest(ptDrag, true);
	    boolean trouve = false;
	    int i = 0;
	    if ( selection != null ) {
		for ( i = 0; i < mg.sommets.size() && !trouve; i++ ) {
		    metaNoeud mn = (metaNoeud)mg.getSommet(i);
		    if ( mn.nom.equals(selection.nom) ) trouve = true;
		}
		if ( trouve ) {
		    JMenuItem item;
		   
		    i--;
		    String[] Items = new String[Clusters[i].size()];
		    
		    for ( int j = 0; j < Clusters[i].size(); j++) {
			int indice = ((Integer)(Clusters[i].elementAt(j))).intValue();
			Sommet s = gr.getSommet(indice);
			if ( s.nomlong != null )
			    Items[j] = s.nomlong; 
			else 
			    Items[j] = s.nom; 
		    }	
		    triRapide(Items, 0, Clusters[i].size() - 1);
		    
		    contenu = new JPopupMenu( );
		    item = new JMenuItem("Cluster " + i + " : " + Clusters[i].size());
		    item.addItemListener(this);
		    item.addMouseListener(this);
		    contenu.add(item);
		    contenu.addSeparator() ;
	    
		    fisheye = new FishEyeMenu("Contenu");
		    fisheye.addItemListener(this);
		    fisheye.addMouseListener(this);
		    
		    contenu.addMouseListener(this);
		    contenu.add(fisheye); 
		    
		    for ( int j = 0; j < Clusters[i].size(); j++) {
			item = new JMenuItem(Items[j]);
			fisheye.add(item);
		    }
		}	
		contenu.setLocation(this.frame.getLocation().x + selection.x + 20, 
				    this.frame.getLocation().y + selection.y + 60 );
		contenu.setVisible(true);	
	    }
	} else if ( e.getButton() == 3 && mcl ) { // Extraction de cluster

	    ptDrag = new Point(e.getX(), e.getY() );
	    selection = mg.hitTest( ptDrag, true );
	    
	    boolean trouve = false;
	    int i = 0;
	    if ( selection != null ) {
		for ( i = 0; i < mg.sommets.size() && !trouve; i++ ) {
		    metaNoeud mn = (metaNoeud)mg.getSommet(i);
		    if ( mn.nom.equals(selection.nom) ) 
			trouve = true;	
		}	
		if ( trouve ) {
		    i--;
		    Cluster = new Graphe(false);
		    int cpt = 0;
		    for ( int j = 0; j < Clusters[i].size(); j++ ) {
			int indice = ((Integer)(Clusters[i].elementAt(j))).intValue();
			
			Sommet interne = new Sommet(gr.getSommet(indice).x, 
						    gr.getSommet(indice).y,
						    gr.getSommet(indice).couleur,
						    gr.getSommet(indice).nom);

			interne.type = gr.getSommet(indice).type;
			interne.metrique = gr.getSommet(indice).metrique;
			interne.couleur = gr.getSommet(indice).couleur;
			interne.couleurClasse = gr.getSommet(indice).couleurClasse;
			interne.nomlong = gr.getSommet(indice).nomlong;
			interne.nom = gr.getSommet(indice).nom;
			
			Cluster.ajouterSommet(interne);
			
			for ( int k = 0; k < nbClusters; k++ ) {  
			    if ( k != i ) {
				for (int l = 0; l < Clusters[k].size(); l++) {
				    int indiceExterne = 
					((Integer)(Clusters[k].elementAt(l))).intValue(); 

				    Sommet externe_tmp = gr.getSommet(indiceExterne);
				    int ind_a = gr.areteDansGraphe(externe_tmp, interne);
				    
				    if ( !gr.getSommet(indice).equals(externe_tmp) && 
					 ind_a != -1 ) {
					Sommet externe = new Sommet( externe_tmp.x, 
								     externe_tmp.y,
								     externe_tmp.couleur,
								     externe_tmp.nom );
					
					externe.type          = externe_tmp.type;
					externe.metrique      = externe_tmp.metrique;
					externe.couleur       = externe_tmp.couleur;
					externe.couleurClasse = externe_tmp.couleurClasse;
					externe.nomlong       = externe_tmp.nomlong;
					externe.nom           = externe_tmp.nom;
					
					Cluster.ajouterSommet(externe);
					Arete arete_tmp = gr.getArete(ind_a);
					Arete arete = new Arete(externe_tmp,
								interne,
								externe_tmp.x,
								interne.x,
								arete_tmp.getCouleur(),
								arete_tmp.getNom(), 
								cpt++ );
					
					arete.setVal(arete_tmp.getVal());
					Cluster.ajouterArete(arete);
				    }
				}
			    }
			}	
		    }
		    for ( int j = 0; j < Clusters[i].size(); j++ ) {
			int indice = ((Integer)(Clusters[i].elementAt(j))).intValue();
			
			for ( int k = 0; k < Clusters[i].size(); k++ ) {
			    int ind = ((Integer)(Clusters[i].elementAt(k))).intValue();
			    
			    int ind_a = gr.areteDansGraphe(gr.getSommet(indice), 
							   gr.getSommet(ind));
			    if ( !gr.getSommet(indice).equals(gr.getSommet(ind)) && 
				 ind_a != -1 ) {
				
				Arete arete = new Arete(gr.getSommet(indice),
							gr.getSommet(ind),
							gr.getSommet(indice).x,
							gr.getSommet(ind).x,
							gr.getArete(ind_a).getCouleur(),
							gr.getArete(ind_a).getNom(), 
							Cluster.aretes.size()+1 );
				
				arete.setVal(gr.getArete(ind_a).getVal());
				Cluster.ajouterArete(arete);	
			    }
			}
		    }
		}
		Cluster.TrierAretes();
		GraphPanel Clone = new GraphPanel(Cluster, true);
		Clone.gr = Cluster;
		Clone.Items = new String[Cluster.nombreSommets()];
		Clone.nomslongs   = nomslongs;
		for ( int j = 0; j < Cluster.nombreSommets(); j++) {
		    Sommet s = Cluster.getSommet(j);
		    if ( s.nomlong != null )
			Clone.Items[j] = s.nomlong; 
		    else 
			Clone.Items[j] = s.nom; 
		}	
		triRapide(Clone.Items, 0, Cluster.nombreSommets() - 1);
		
		Cluster.maximumArete();
		Cluster.maxMetrique1 = gr.maxMetrique1;
		Cluster.maxMetrique2 = gr.maxMetrique2;
		Clone.init(1);
		
		Cluster.typeMat = this.gr.typeMat;
		Cluster.sans   = gr.sans;	
		Cluster.longs  = gr.longs;
		Cluster.cercle = gr.cercle;
		Clone.circulaire = true;
		Clone.circulaire(Cluster);
		Clone.frame.setTitle( "Tétralogie VisuGraph : Cluster " + i );
		Clone.frame.setVisible(true);
		
	    }
	} else if (e.getButton() == 3 && connexe) {
	    // Button 3 : selection  

	    ptDrag = new Point(e.getX(), e.getY());
	    selection = cnx.hitTest(ptDrag, true);
	    
	    if ( selection != null ) {
		selection.marked = true;
		gr.getVoisins(selection, false, cnx.seuil );
		for ( int i = 0; i < selection.voisins.size(); i++) { 
		    Sommet s = (Sommet)selection.voisins.elementAt(i); 
		    cnx.ajouterSommet(s);
		    s.setVisible();

		    int indice = gr.areteDansGraphe(selection, s);   
		    if ( indice != -1 ) { 
			Arete a = gr.getArete(indice); 
			if ( !cnx.aretes.contains(a) ) {
			    cnx.ajouterArete(a); 
			    if ( a.getVal() >= cnx.seuil ) 
				a.setVisible();  
			    else a.setInvisible();
			}
		    }
		}
		for ( int i = 0; i < cnx.nombreSommets(); i++ ) { 
		    Sommet si = cnx.getSommet(i);
		    for ( int j = 0; j < cnx.nombreSommets(); j++ ) { 
			Sommet sj = cnx.getSommet(j);
			if ( i != j && si.getVisible() && sj.getVisible() ) {
			    int indice = gr.areteDansGraphe(si, sj); 
			    if ( indice != -1 ) {
				Arete a = gr.getArete(indice);
				cnx.ajouterArete(a);
				if ( a.getVal() >= cnx.seuil) 
				    a.setVisible();
				else a.setInvisible();
			    }
			}
		    }   
		}
		cnx.initDegre();
		cnx.maximumMetrique();
		cnx.maximumArete();
		cnx.TrierAretes();
		if (cnx.nombreSommets() ==  gr.nombreSommets()) {
		    Toolkit.getDefaultToolkit().beep();
		    Toolkit.getDefaultToolkit().beep();
		}
	    } else Toolkit.getDefaultToolkit().beep();
	} 
	else if ( e.getButton() == 2 && connexe ) {
	    // Button 2 : de-selection 
	    ptDrag = new Point(e.getX(), e.getY());
	    selection = cnx.hitTest(ptDrag, true);
	    
	    if ( selection != null ) {
		cnx.getVoisins(selection, false, cnx.seuil );
		selection.marked = false;
		cnx.supprimerSommet( cnx.indiceSommet(selection) );
		cnx.initDegre();
		for ( int i = 0; i < selection.voisins.size(); i++) { 
		    Sommet s = (Sommet)selection.voisins.elementAt(i); 
		    int indice = cnx.indiceSommet(s);
		    s.marked = false; 
		    cnx.getVoisins( cnx.getSommet(indice), false, cnx.seuil ); 
		    
		    if ( s.voisins.size() == 0  ) 
			cnx.supprimerSommet(indice);	
		    s.niveau = 100; 
		}
		cnx.initDegre();
		cnx.maximumMetrique();
		cnx.maximumArete();
		cnx.TrierAretes();
	    }
	}
	repaint();	
    }

    public void ExtractionCluster (int i) {
	Cluster = new Graphe(false);
	int cpt = 0;
	for ( int j = 0; j < Clusters[i].size(); j++ ) {
	    int indice = ((Integer)(Clusters[i].elementAt(j))).intValue();
	    
	    Sommet interne = new Sommet(gr.getSommet(indice).x, 
					gr.getSommet(indice).y,
					gr.getSommet(indice).couleur,
					gr.getSommet(indice).nom);
	    
	    interne.type = gr.getSommet(indice).type;
	    interne.metrique = gr.getSommet(indice).metrique;
	    interne.couleur = gr.getSommet(indice).couleur;
	    interne.couleurClasse = gr.getSommet(indice).couleurClasse;
	    interne.nomlong = gr.getSommet(indice).nomlong;
	    interne.nom = gr.getSommet(indice).nom;
	    
	    Cluster.ajouterSommet(interne);
	    
	    for ( int k = 0; k < nbClusters; k++ ) {  
		if ( k != i ) {
		    for (int l = 0; l < Clusters[k].size(); l++) {
			int indiceExterne = 
			    ((Integer)(Clusters[k].elementAt(l))).intValue(); 
			
			Sommet externe_tmp = gr.getSommet(indiceExterne);
			int ind_a = gr.areteDansGraphe(externe_tmp, interne);
			
			if ( !gr.getSommet(indice).equals(externe_tmp) && 
			     ind_a != -1 ) {
			    Sommet externe = new Sommet( externe_tmp.x, 
							 externe_tmp.y,
							 externe_tmp.couleur,
							 externe_tmp.nom );
			    
			    externe.type          = externe_tmp.type;
			    externe.metrique      = externe_tmp.metrique;
			    externe.couleur       = externe_tmp.couleur;
			    externe.couleurClasse = externe_tmp.couleurClasse;
			    externe.nomlong       = externe_tmp.nomlong;
			    externe.nom           = externe_tmp.nom;
			    
			    Cluster.ajouterSommet(externe);
			    Arete arete_tmp = gr.getArete(ind_a);
			    Arete arete = new Arete(externe_tmp,
						    interne,
						    externe_tmp.x,
						    interne.x,
						    arete_tmp.getCouleur(),
						    arete_tmp.getNom(), 
						    cpt++ );
			    
			    arete.setVal(arete_tmp.getVal());
			    Cluster.ajouterArete(arete);
			}
		    }
		}
	    }	
	}
	for ( int j=0; j < gr.aretes.size(); j++ ) {
	    Arete a = gr.getArete(j);
	    Sommet e1 = a.getE1();
	    Sommet e2 = a.getE2();
	    if ( e1.num_cluster == e2.num_cluster && e1.num_cluster == i ) {
		Arete intra_arete = new Arete(e1, e2, e1.x, e2.x, null, a.getNom(), 
					      Cluster.aretes.size()+1 );
		intra_arete.setVal(a.getVal());
		Cluster.aretes.addElement(intra_arete); 
	    }	
	}
	Cluster.TrierAretes();
	GraphPanel Clone = new GraphPanel(Cluster, true);
	Clone.gr = Cluster;
	Clone.Items = new String[Cluster.nombreSommets()];
	Clone.nomslongs   = nomslongs;
	for ( int j = 0; j < Cluster.nombreSommets(); j++) {
	    Sommet s = Cluster.getSommet(j);
	    if ( s.nomlong != null )
		Clone.Items[j] = s.nomlong; 
	    else 
		Clone.Items[j] = s.nom; 
	}	
	triRapide(Clone.Items, 0, Cluster.nombreSommets() - 1);
	
	Cluster.maximumArete();
	Cluster.maxMetrique1 = gr.maxMetrique1;
	Cluster.maxMetrique2 = gr.maxMetrique2;
	Clone.init(1);
	
	Cluster.typeMat = this.gr.typeMat;
	Cluster.sans   = gr.sans;	
	Cluster.longs  = gr.longs;
	Cluster.cercle = gr.cercle;
	Clone.circulaire = true;
	Clone.circulaire(Cluster);
	Clone.frame.setTitle( "Tétralogie VisuGraph : Cluster " + i );
	Clone.frame.setVisible(true);
	
    }
    public void mouseEntered(MouseEvent e) {
	
	if ( contenu != null && contenu.isVisible() ) {
	    Object src = e.getSource();
	    if ( src == fisheye ) {
		fisheye.menuSelectionChanged(true);	
		fisheye.setVisible(true);
	    }
	    else 
		fisheye.menuSelectionChanged(false);
	}
	currentW = getSize().width;
	currentH = getSize().height;
    }
    public void mouseExited(MouseEvent e) {
	// System.out.println ("mouseExited");
    }

    public void mousePressed(MouseEvent e)
    {
	if ((e.getModifiers() & MouseEvent.BUTTON1_MASK) == 0 || !editable)
	    return;
	ptDrag = new Point(e.getX(), e.getY());
	if ( morphing != null ) selection = morphing.hitTest(ptDrag, true);
	if ( !mst1 && !mst2 && !mcl )                    selection = gr.hitTest(ptDrag, true);
	if (  mst1 && !mst2 && !mcl && lArbre1 != null ) selection = lArbre1.hitTest(ptDrag, true);
	if (  !mst1 && mst2 && !mcl && lArbre2 != null ) selection = lArbre2.hitTest(ptDrag, true);
	if ( !mst1 && !mst2 && mcl ) { 
	    selection = mg.hitTest(ptDrag, true); 
	    flag = true;
	}

	if (selection != null) {
	    dragging = true;
	}
	
    }

    public void mouseReleased(MouseEvent e)
    {
	Dimension d = getSize();
	
	if ( contenu != null && contenu.isVisible()  ) {
	    fisheye.fishEyeWindow.setVisible(false);
	    contenu.setVisible(false);
	}
	if (( e.getModifiers() & MouseEvent.BUTTON1_MASK) == 0 || !dragging )
	    return;

	dragging = false;
	ptDrag = new Point(e.getX(), e.getY());
	
	while (gr.hitTest(ptDrag, false) != null ) {
	    ptDrag.x += Sommet.RAYON;
	    ptDrag.y += Sommet.RAYON;
	}
	selection.deplacer(e.getX(), e.getY(), d.width, d.height);
	
	ptDrag = null;
	repaint();
	e.consume ();
    }
   
    class tailleLabels implements ChangeListener {	
        public void stateChanged (ChangeEvent e) {
	    int val = control.slider2.getValue();
	    Graphe graphe = new Graphe(false);
	    if ( !mst1 && !mst2 && !mcl ) { graphe = gr; }
	    if (  mst1 && !mst2 && !mcl ) { graphe = lArbre1; }
	    if ( !mst1 &&  mst2 && !mcl ) { graphe = lArbre2; }
	    if ( !mst1 && !mst2 &&  mcl ) { graphe = mg; }
	    if ( !mst1 && !mst2 && !mcl && connexe ) { graphe = cnx; }

	    for ( int i = 0; i < graphe.nombreSommets(); i++ ) {
		Sommet s = graphe.getSommet(i);
		String name = (String)nomslongs.data.get((Object)(s.nom));
		if ( name.length() >= val )
		    s.nomlong = name.substring(0, val); 
	    }	
	    repaint();
	}
    }
    class ChoixTypeInstance implements ChangeListener, ItemListener {
	public void itemStateChanged(ItemEvent e) {
	    int instance = control.slider5.getValue();
	    morphing = new Morphing(false);
	    
	} 
  
	public void stateChanged( ChangeEvent e ) {
	    int instance = control.slider5.getValue();
	    morphing = new Morphing(false);

	    if ( instance >= 1 ) {
		morphing.typeGraphe = 1;
		for ( int i = 0; i < gr.nombreAretes(); i++ ) {
		    Arete a = gr.getArete(i);
		    double valeur = 0;
		    if ( control.box4.isSelected() )
			valeur = Math.abs(a.getValInstance(instance) - a.getValInstance(instance-1));
		    else 
			valeur =  a.getValInstance(instance);

		    Sommet s1 = a.getE1();
		    Sommet s2 = a.getE2();
		    s1.type = a.getE1().type;
		    s2.type = a.getE2().type;

		    if ( valeur != 0 ) {
			Arete ar = new Arete(s1, s2);
			ar.setVal((int)valeur);
			ar.setNom(String.valueOf((int)valeur));
			morphing.ajouterArete(ar);
			if ( control.box4.isSelected() ) {
			    s1.metrique = Math.abs(a.getE1().Metrique[instance] - 
						   a.getE1().Metrique[instance-1]);
			    s2.metrique = Math.abs(a.getE2().Metrique[instance] - 
						   a.getE2().Metrique[instance-1]);
			    
			} else {
			    s1.metrique = a.getE1().Metrique[instance];
			    s2.metrique = a.getE2().Metrique[instance];
			}
		    } else {
			if ( control.box4.isSelected() ) {
			    s1.metrique = Math.abs(a.getE1().Metrique[instance] - 
						   a.getE1().Metrique[instance-1]);
			    s2.metrique = Math.abs(a.getE2().Metrique[instance] - 
						   a.getE2().Metrique[instance-1]);

			} else {
			    s1.metrique = a.getE1().Metrique[instance];
			    s2.metrique = a.getE2().Metrique[instance];
			}
		
			morphing.ajouterSommet(s1);
			morphing.ajouterSommet(s2);
		    } 
		}
		morphing.stress = gr.stress; 
		morphing.noms   = gr.noms;
		morphing.cercle = gr.cercle;
		morphing.longs  = gr.longs;
		morphing.sans   = gr.sans;
		morphing.rang = instance;

		morphing.maximumArete();
		morphing.maximumMetrique();
		morphing.TrierAretes();
		morphing.typeMat = gr.typeMat;
		repaint();
		for (int j = 0; j < morphing.nombreSommets(); j++ ) {
		    Sommet v = morphing.getSommet(j);
		    System.out.println( v.getNom() + " : " + v.metrique + " : " + v.Metrique[1]);
		}
		//System.out.println( "Max1 : "+morphing.maxMetrique1+" min1 : "+morphing.minMetrique1+"\n");
	    } else {
		morphing = null;
	    }
	}
    }
    
    public double ConversionIntensite(int entree) {
	if ( entree == 0 ) 
	    return(0.12);
	else if ( entree == 1 ) 
	    return(0.25);
	else if ( entree == 2 ) 
	    return(0.5);
	else if ( entree == 3 ) 
	    return(1.0);
	else if ( entree == 4 ) 
	    return(2.0);
	else if ( entree == 5 ) 
	    return(3.0);
	else if ( entree == 6 ) 
	    return(4.0);
	else  return(1.0);
    }
    class FacteurClustering implements ChangeListener {	
        public void stateChanged (ChangeEvent e) { 
	    double val = control.slider4.getValue();
	    facteur = 1.0;
	    facteur += (double)val/10.0;
	}
    }
    class nouvelleForce implements ChangeListener {	
        public void stateChanged (ChangeEvent e) { 
	    double val =  control.slider2.getValue();	    
	}
    }
    class IntensiteCouleurs implements ChangeListener {	
        public void stateChanged (ChangeEvent e) {

	    double val =  ConversionIntensite(control.slider3.getValue());
	    
	    if ( !mst1 && !mst2 && !mcl && !connexe ) gr.intensite      = val; 
	    if (  mst1 && !mst2 && !mcl && !connexe ) lArbre1.intensite = val; 
	    if ( !mst1 &&  mst2 && !mcl && !connexe ) lArbre2.intensite = val; 
	    if ( !mst1 && !mst2 &&  mcl && !connexe ) mg.intensite      = val; 
	    if ( connexe                            ) cnx.intensite     = val; 
	    if ( morphing != null                   ) morphing.intensite = val;
	    System.out.println(" intensite = " + val );
	    repaint();
	}
    }
    class nouveauSeuil implements ChangeListener {	
        public void stateChanged ( ChangeEvent e ) {
	    double val = control.slider1.getValue();
	    Graphe graphe = new Graphe(false);
	    
	    NbSommetsVisibles = 0;
	    if ( force3 ) stop();
	    if ( morphing != null ) { graphe = morphing;      morphing.seuil = val; }
	    if ( !mst1 && !mst2 && !mcl ) { graphe = gr;      gr.seuil      = val; }
	    if (  mst1 && !mst2 && !mcl ) { graphe = lArbre1; lArbre1.seuil = val; }
	    if ( !mst1 &&  mst2 && !mcl ) { graphe = lArbre2; lArbre2.seuil = val; }
	    if ( !mst1 && !mst2 &&  mcl ) { graphe = mg;       mg.seuil     = val; }
	    if ( connexe )                { graphe = cnx;         cnx.seuil = val; }
	    
	    NbSommetsVisibles = graphe.nombreSommets();

	    for (int j = 0; j < graphe.aretes.size(); j++) {
		Arete a = graphe.getArete(j);
		Sommet s1 = a.getE1();
		Sommet s2 = a.getE2();
		
		if ( a.getVal() >= val && !a.getVisible() ) {
		    a.setVisible();
		    s1.setVisible();
		    s2.setVisible();
		    NbSommetsVisibles += 2;
		}
		if ( a.getVal() < val && a.getVisible()) {
		    a.setInvisible();

		    if ( graphe.degre(graphe.indiceSommet(s1)) == 0 && graphe.masque) {
			s1.setInvisible();
			if ( graphe.connexe ) 
			    
			NbSommetsVisibles -= 1;
		    }
		    if ( graphe.degre(graphe.indiceSommet(s2)) == 0 && graphe.masque) {
			s2.setInvisible();
			NbSommetsVisibles -= 1;
		    }
		}
	    }
	    /*if ( circulaire ) circulaire(graphe);*/
	    if ( force3 )
		start();
	    repaint();
	}
    }
    public void adjustmentValueChanged(AdjustmentEvent e) {}

    public void itemStateChanged(ItemEvent e) {
	Object src = e.getSource();
	boolean on = e.getStateChange() == ItemEvent.SELECTED;
	Graphe graphe = new Graphe(false);

	if (src == control.box1) {
	    gr.stress = on;

	    if ( lArbre1  != null ) lArbre1.stress = on;
	    if ( lArbre2  != null ) lArbre2.stress = on;
	    if ( mg       != null )      mg.stress = on;
	    if ( cnx      != null )     cnx.stress = on;
	    if ( morphing != null )morphing.stress = on; 
	}
	if (src == control.box2) {
	    gr.masque   = on; 
	   
	    if ( !mst1 && !mst2 && !mcl ) { gr.masque = on; graphe = gr ; }
	    if (  mst1 && !mst2 && !mcl ) { lArbre1.masque = on; graphe = lArbre1;}
	    if ( !mst1 &&  mst2 && !mcl ) { lArbre2.masque = on; graphe = lArbre2 ;}
	    if ( !mst1 && !mst2 &&  mcl ) { mg.masque = on; graphe = mg ;}
	    if ( connexe )                { cnx.masque = on; graphe = cnx;   }
	    if ( morphing != null )       { morphing.masque = on; graphe = morphing; }
		
	    for ( int i = 0; i < graphe.nombreSommets(); i++ ) {
		Sommet v = graphe.getSommet(i);
		graphe.getVoisins(v, false, graphe.seuil );
		
		if ( graphe.degre(graphe.indiceSommet(v)) == 0 && v.getVisible() && on ) 
		    v.setInvisible();
	
		if ( graphe.degre(graphe.indiceSommet(v)) == 0 && !v.getVisible() && !on ) 
		    v.setVisible();	
	    }
	    if ( circulaire ) circulaire(graphe);
	}
	if (src == control.box3 ) {  

	    connexe = on;
	    cnx.seuil = control.slider1.getValue();
	    if ( lArbre1 != null ) { 
		lArbre1.longs   = gr.longs; 
		lArbre1.cercle  = gr.cercle;
		lArbre1.seuil = cnx.seuil;
	    }
	    if ( lArbre2 != null ) { 
		lArbre2.longs   = gr.longs; 
		lArbre2.cercle  = gr.cercle;
		lArbre2.seuil = cnx.seuil;
	    }
	    if ( mg      != null ) {
		mg.sans    = gr.sans; 
	    }
	    if ( cnx     != null ) { 
		cnx.sans    = gr.sans;
		cnx.longs   = gr.longs;
		cnx.cercle  = gr.cercle;	
	    }
	    if ( morphing != null ) { 
		morphing.sans    = gr.sans;
		morphing.longs   = gr.longs;
		morphing.cercle  = gr.cercle;	
	    }   
	} 
	repaint();
    }
    public void menuSelected(MenuEvent e) {}
    public void menuDeselected(MenuEvent e) {}
    public void menuCanceled(MenuEvent e) {}
  
    
    public void actionPerformed (ActionEvent e) {} 

    public void start () {
	relaxer = new Thread(this);
	relaxer.start();
    }
    
    public void stop () {
	relaxer = null;	
    }
    
    public void run() {
	
	Thread me = Thread.currentThread();

	while ( relaxer == me ) {
	    if ( force3 ) {
		if ( morphing != null ) {
		    relax(morphing);
		    force_directed_placement(morphing); 	
		} 
		else if ( !mst1 && !mst2 && !mcl && !connexe ) {
		    relax(gr);
		    force_directed_placement(gr);
		}
		else if (  mst1 && !mst2 && !mcl && !connexe) {
		    relax(lArbre1);
		    force_directed_placement(lArbre1); 	
		} 
		else if ( !mst1 &&  mst2 && !mcl && !connexe) {
		    relax(lArbre2);
		    force_directed_placement(lArbre2); 
		} 
		else if ( connexe) {
		    relax(cnx);
		    force_directed_placement(cnx);
		}
		else if ( !mst1 && !mst2 && mcl && !connexe) {   
		    relax(mg);
		    force_directed_placement(mg);
		}
	    }
	    pause(100); 
	    repaint();
	}
    }
    
    public void pause(int milliseconds)
    {
	try {
	    Thread.sleep(milliseconds);
	}
	catch (InterruptedException e) {
	    System.out.println(" Interrupted Exception ");
	}
    }

    synchronized void relax(Graphe graphe) {
	for ( int i = 0 ; i < graphe.nombreAretes() ; i++ ) {
	    Arete a = graphe.getArete(i);
	    Sommet e1 = a.getE1();
	    Sommet e2 = a.getE2();
	    double vx = e1.x - e2.x;
	    double vy = e1.y - e2.y;
	    
	    double distance = Math.sqrt(vx * vx + vy * vy);
	    
	    if ( distance == 0.0 ) distance = 0.0001;
	    
	    double force = (a.longueurCourante() - distance)/(3*distance);
	    double dx = force * vx;
	    double dy = force * vy;
	    
	    e1.dx += dx;
	    e1.dy += dy;
	    e2.dx += -dx;
	    e2.dy += -dy;
	}
	
	for ( int i = 0 ; i < graphe.nombreSommets(); i++ ) {
	    Sommet n1 = graphe.getSommet(i);
	   
	    double dx = 0.0;
	    double dy = 0.0;

	    for ( int j = 0 ; j < graphe.nombreSommets(); j++ ) {
		if (i == j)  continue;
     		Sommet n2 = graphe.getSommet(j);
		double vx = n1.x - n2.x;
		double vy = n1.y - n2.y;

		double distance = vx*vx + vy*vy; // norm(n1, n2)
		
		if ( distance == 0 ) {
		    dx += Math.random();
		    dy += Math.random();
		} else 
		    if ( distance < 100*100 ) {
			dx += vx / distance;
			dy += vy / distance;
		    }
	    }
	    double dforce = dx*dx + dy*dy;
	    if ( dforce > 0.0) {
		dforce = Math.sqrt(dforce) / 2;
		n1.dx += dx/dforce;
		n1.dy += dy/dforce;
	    }
	}
	Dimension d = getSize();

	for (int i = 0 ; i < graphe.nombreSommets() ; i++ ) {
	    Sommet n = graphe.getSommet(i);
	    if (!n.fixe) {
		n.x += (int)( Math.max(-5, Math.min(5, n.dx)) );
		n.y += (int)( Math.max(-5, Math.min(5, n.dy)) );
            }
            if ( n.x < 10 ) {
		n.x = 10;
	    } else if ( n.x > d.width ) {
		n.x = d.width;
	    }
	    if ( n.y < 25 ) {
		n.y = 25;
	    } else if ( n.y > d.height-40 ) {
		n.y = d.height-40;
	    }
	    n.dx /= 2;
	    n.dy /= 2;
	}
    }

    // FDP   
    public synchronized void force_directed_placement(Graphe graphe) {
	
	double w = this.frame.getSize().getWidth();
	double h = this.frame.getSize().getHeight()-20;
	gravite.x = (int)w/2;
	gravite.y = (int)h/2;
	
	int nbvisible = 0;
	
	int ordre = graphe.nombreSommets();
	for ( int i = 0; i < ordre; i++ ) {
	    Sommet s = graphe.getSommet(i);
	    if ( s.getVisible() ) nbvisible++;
	}
	double k = Math.sqrt(w*h/nbvisible);
	double val =  control.slider2.getValue();
	Force.K(3*k*val/5);


	for ( int i = 0; i < graphe.nombreSommets(); i++ ) {
	    Sommet u = graphe.getSommet(i);
	    if ( u.getVisible() ) {
		u.stabilize();
		u.dx += 5;
		double xg = (double)( u.x - gravite.x );
		double yg = (double)( u.y - gravite.y );
		double dg = Math.sqrt( xg*xg + yg*yg );
		
		if ( dg > 0.00001 ) 
		    u.forced( gravite, -0.08/dg*Force.fa(dg) );

		// ******** Calcul des forces repulsives 

		for ( int j = 0; j < graphe.nombreSommets(); j++ ) {
		    Sommet v = graphe.getSommet(j);
		    if ( !u.equals(v) && v.getVisible() ) {
			double xx = (double)(u.x - v.x);
			double yy = (double)(u.y - v.y);
			double distance = Math.sqrt(xx*xx + yy*yy); // distance entre u et v
			
			if ( distance > 3*k ) continue;
			if ( distance == 0.0 ) distance = 0.0001;
			u.forced( v, 1.0/distance*Force.fr(distance) );
		    }	
		    if ( !v.getVisible() ) {
			v.stabilize();	
		    }
		}
		// Calcul des forces attractives
		graphe.getVoisins( u, false, graphe.seuil );
		for ( int j = 0; j < u.voisins.size(); j++ ) {
		    Sommet v = (Sommet)u.voisins.elementAt(j);
		    double xx = (double)(u.getX() - v.getX());
		    double yy = (double)(u.getY() - v.getY());
		    double distance =  Math.sqrt(xx*xx + yy*yy);
		    if (  v.getVisible() ) { 

			if ( (cluster2 && v.num_cluster != u.num_cluster ) || !cluster2 ) 
			    u.forced( v, -1/distance*Force.fa(distance) ); 
			
			if ( cluster2 && v.num_cluster == u.num_cluster ) 
			    u.forced( v, -2/distance*Force.fa(distance) );
			 
		    }
		}
	    }
	}
	// Deplacement des sommets en fonction de la temperature globale du systeme
	
	double Temp = Force.temp(Force.time) + Force.minTemp();
	// Mise a jour de la temperature globale du systeme
	Force.Temp(Temp);
	
	for (int j = 0; j < graphe.nombreSommets(); j++ ) {
	    Sommet v = graphe.getSommet(j);
	    if ( v.getVisible() ) {
		double force = v.deltaForce();
		
		if( force < 0.00001 && Force.time < 100 ) continue;
		
		if ( !v.fixe && force > Force.minTemp()) { 
		    v.moveDelta( 1.0/force * Force.min( force/5, Temp/5) );
		}   
	    }
	}
	Force.time += 1.0;
    }

    /* Representation circulaire du graphe */
    public  void circulaire( Graphe graphe ) {
	double w = getSize().getWidth()  - 20;
	double h = getSize().getHeight() - 40;
	double rX, rY;

	rX = w/2.0;
	rY = h/2.0;

	int nb_classe0 = 0;
	int nb_classe1 = 0;
	for ( int i = 0; i < graphe.nombreSommets(); i++ ) {
	    Sommet s = graphe.getSommet(i);
	    if ( s.type == 0 && s.getVisible()) nb_classe0++;
	    if ( s.type == 1 && s.getVisible()) nb_classe1++;
	}

	double theta0 = 3*Math.PI/2;       
        double delta0 = 2*Math.PI/nb_classe0 ;

	double theta1 = 3*Math.PI/2;
	double delta1 = 2*Math.PI/nb_classe1;

	if ( graphe.typeMat == 0 || graphe.typeMat == 3 ) {
	    for (int i = 0; i < graphe.nombreSommets(); i++) {
		Sommet s = graphe.getSommet(i);
		
		if ( s.type == 1 && s.getVisible()){
		    s.x =  (int)(w/2 + ( rX - 16 )*Math.cos(theta1));
		    s.y =  (int)(h/2 + ( rY - 16 )*Math.sin(theta1));
		    theta1 += delta1;
		}
	    	if ( s.type == 0 && s.getVisible()){
		    s.x =  (int)(w/2 + ( 2*rX/3 - 6 )*Math.cos(theta0));
		    s.y =  (int)(h/2 + ( 2*rY/3 - 6 )*Math.sin(theta0));
		    theta0 += delta0;
		}
	    }
	} 
	if ( graphe.typeMat == 1 || graphe.typeMat == 2 ) {
	    if ( cluster2 ) {
		for (int i = 0; i < nbClusters; i++) {
		    int indice = ((Integer)(Clusters[i].elementAt(0))).intValue();
		    try {
			Sommet s = graphe.getSommet(indice);
			s.x =  (int)(w/2 + ( rX - 16 )*Math.cos(theta1));
			s.y =  (int)(h/2 + ( rY - 16 )*Math.sin(theta1));
			theta1 += delta1;
			for (int j = 1; j < Clusters[i].size(); j++) {
			    int ind = ((Integer)(Clusters[i].elementAt(j))).intValue();
			    Sommet ss= graphe.getSommet(ind);
			    ss.x =  (int)(w/2 + ( rX - 16 )*Math.cos(theta1));
			    ss.y =  (int)(h/2 + ( rY - 16 )*Math.sin(theta1));
			    theta1 += delta1;
			} 
		    } catch (ArrayIndexOutOfBoundsException e) {
			//System.out.println("\nArrayIndexOutOfBoundsException : " + e );
			continue;
		    }
		}
	    }
	    else
		for ( int i = 0; i < graphe.nombreSommets(); i++ ) {
		    Sommet s = graphe.getSommet(i);
		    
		    if ( s.type == 1 && s.getVisible()) {	
			s.x =  (int)(w/2 + ( rX - 16 )*Math.cos(theta1 ));
			s.y =  (int)(h/2 + ( rY - 16 )*Math.sin(theta1 ));
			theta1 += delta1;
		    }
		}
	}
    }
    
    public  void circulaireClustered( Graphe gr ) {
	
	if ( gr.typeMat == 1 || gr.typeMat == 2 ) {
	    double theta = 0.0;
	    
	    for ( int i = 0; i < nbClusters; i++ ) {
		double maxMetrique = 0;
		int rep = 0;
		Sommet noyau = new Sommet(0, 0);
		for ( int j = 0; j < Clusters[i].size(); j++ ) {
		    int indice = ((Integer)(Clusters[i].elementAt(j))).intValue();
		    noyau =  gr.getSommet(indice);
		    noyau.fixe = false;
		    if ( noyau.metrique > maxMetrique ) {
			maxMetrique = noyau.metrique;
			rep = indice;	
		    }
		}
		noyau =  gr.getSommet(rep);
		noyau.fixe = true;
		
		double rayon = 10.0; 
		metaNoeud cluster = (metaNoeud)mg.getSommet(i);
		noyau.x = cluster.x;
		noyau.y = cluster.y;
		double delta = 2*Math.PI/( Clusters[i].size()-1 );
		
		for ( int j = 0; j < Clusters[i].size(); j++ ) {
		    Sommet s = (Sommet)(cluster.sommets.elementAt(j)); 
		    if ( !s.equals(noyau) ) {
			s.x = (int)(noyau.x + rayon*Math.cos(theta));
			s.y = (int)(noyau.y + rayon*Math.sin(theta));
			rayon += 0.25;
			theta += delta;
		    }
		}
	    }
	}
    }
	
    public void ArbreCouvrant( Graphe graphe ) {	
	System.out.println(" Arbre Maximal Partiel ");
	if ( lArbre1 == null ) 
	    lArbre1 = graphe.determineArbrePrim();
	
	lArbre1.typeGraphe = graphe.typeGraphe;
	lArbre1.typeMat = graphe.typeMat;
	lArbre1.instance = graphe.instance;
	lArbre1.sans = graphe.sans;
	lArbre1.longs = graphe.longs;
	lArbre1.cercle  = graphe.cercle;
	lArbre1.maxMetrique1 = graphe.maxMetrique1;
	lArbre1.maxMetrique2 = graphe.maxMetrique2;	
	lArbre1.TrierAretes();
    }

    public void ArbreCouvrant2( Graphe graphe ) {
	System.out.println(" Arbre Minimal Partiel ");
	if ( lArbre2 == null ) 
	    lArbre2 = graphe.determineArbrePrim2();

	lArbre2.typeGraphe = graphe.typeGraphe;
	lArbre2.typeMat = graphe.typeMat;
	lArbre2.instance = graphe.instance;
	lArbre2.sans = graphe.sans;
	lArbre2.longs = graphe.longs;
	lArbre2.cercle  = graphe.cercle;
	lArbre2.maxMetrique1 = graphe.maxMetrique1;
	lArbre2.maxMetrique2 = graphe.maxMetrique2;
	lArbre2.typeGraphe = graphe.typeGraphe;
	lArbre2.TrierAretes();
    }

    public void colorerGraphe(Graphe graphe, Color cl)
    {
	int na = gr.nombreAretes();
	for (int i = 0; i < na; i++) {
	    Arete a = gr.getArete(i);
	    if ( graphe.areteDansGraphe(a.getE1(), a.getE2()) != -1 ||
		 graphe.areteDansGraphe(a.getE2(), a.getE1()) != -1 )
		 a.setCouleur(cl);
	}
    }

    public void imprimer() {
	PrinterJob prj = PrinterJob.getPrinterJob();
	prj.setPrintable((Printable)this);
	
	if( prj.printDialog()) {
	    try{
		prj.print();
	    }
	    catch (PrinterException pe) {
		System.out.println(pe);
	    }
	}
    }
    public int print( Graphics g, PageFormat pf, int pageIndex ) {
	if( pageIndex == 0 ) {
	    paintComponent(g);  
	    return PAGE_EXISTS;
	}
	else return NO_SUCH_PAGE;
    }
    
   
    public void MCL(String args ) {

    	int nbvisible = 0;
	int ordre = gr.nombreSommets();
	if ( gr.typeMat == 1 ||  gr.typeMat == 2 ) {
	    for ( int i = 0; i < ordre; i++ ) {
		Sommet s = gr.getSommet(i);
		if( s.getVisible() ) nbvisible++;
	    }
	    try {
		Writer out = new FileWriter (args);
		out.write("(mclheader\n");
		out.write("mcltype matrix \n"); 
		out.write("dimensions "+nbvisible+"x"+nbvisible );
		out.write("\n)\n");
		out.write("(mclmatrix\n");
		out.write("begin\n");
		for ( int i = 0; i < ordre; i++ ) {
		    Sommet s = gr.getSommet(i);
		    if ( s.getVisible() ) {
			gr.getVoisins(s, false, gr.seuil );
			out.write(i + "    " );
			for ( int j = 0; j < s.voisins.size(); j++ ) {
			    Sommet ss = (Sommet)s.voisins.elementAt(j);
			    if ( ss.getVisible() && s.getVisible()) {
				Arete a = gr.getArete(gr.areteDansGraphe(s, ss));
				if ( a.getVisible() ) 
				    out.write( gr.indiceSommet(ss) + ":" + a.getVal()+ " ");
			    }
			}
			out.write("$\n");
		    }
		}
		out.write(")\n");
		out.close();
	
	    }
	    catch ( IOException e) {
		System.out.println(" Erreur " + e);
	    }
	    try { 
		
		String cheminbin = System.getProperty("cheminBin")+"/bin/clustering "; 
		String cheminout = System.getProperty("cheminResult")+"/out.clusters";  
		//System.out.println("chemin du binaire = " + cheminbin );
		//System.out.println("chemin des resultats = " + cheminout );
		//System.out.println("Facteur du clustering  = " + facteur );
		Process pr2 =
		    Runtime.getRuntime().exec(cheminbin  + args + " -I " + facteur + " -o " + cheminout); 
		pr2.waitFor();
		gr.clustering = true;
	    }
	    catch (Exception e) {
                System.out.println(" Erreur de Clustering " + e);
            }
	} else {
	   System.out.println(" Le Clustering ne s'applique que sur des matrices symétriques"); 
	   gr.clustering = false;
	}
	//gr.clustering = true;
	repaint();

    }
    public void lireClustersMCL(String args) {
	char[] ordre;
	nbClusters = 0;
	String texte;
	int nb_clusters;
	try {
	    File file = new File (args);
	    Reader rd_result = new FileReader (file); 
	    String ligne_doc = null;
	    LineNumberReader line = new LineNumberReader(rd_result);
	    
	    ligne_doc = line.readLine();
	    ligne_doc = line.readLine();
	    ligne_doc = line.readLine();
	    
	    StringTokenizer ligne = new StringTokenizer(ligne_doc); 
	    String tt = ligne.nextToken();
	    tt = ligne.nextToken();
	    StringTokenizer dimension = new StringTokenizer(tt, "x");

	    String  nbso    = dimension.nextToken();
	    String clusters = dimension.nextToken();

	    nbClusters    = Integer.parseInt(clusters);
	    int nbsommets = Integer.parseInt(nbso);

	    Clusters = new Vector[nbClusters];
	   
	    while ( ligne_doc != null && ligne_doc.compareTo("begin") != 0 ) 
		ligne_doc = line.readLine();
	    
	    ligne_doc = line.readLine();
	    int i = line.getLineNumber()-7;
	    while ( ligne_doc != null && ligne_doc.compareTo(")") != 0 ) {
		StringTokenizer cluster = new StringTokenizer(ligne_doc);
		Clusters[i] = new Vector();

		String element_cluster = cluster.nextToken();
		element_cluster = cluster.nextToken();
		
		while ( element_cluster.compareTo("$") != 0 ) {
		    Clusters[i].addElement(new Integer(element_cluster));
		    try {
			element_cluster = cluster.nextToken();
			
		    } catch (NoSuchElementException EE) {
			ligne_doc = line.readLine();
			cluster = new StringTokenizer(ligne_doc); 
			element_cluster = cluster.nextToken();
		    } 
		}
		ligne_doc = line.readLine();
		i++;
	    }
	    line.close();
	}
	catch ( IOException e ) {
	    System.out.println(" Erreur : " + e );
	}
    }

    public void genereClusters(Graphe graphe) {
	mg.sommets = new Vector(nbClusters);
	mg.aretes = new Vector();

	String nom = null;
	int degre = 1;
	System.out.println("le graphe est décomposé en " + nbClusters + " classes");
	System.out.println("Construction du méta-graphe");
	for ( int i = 0; i < nbClusters; i++ ) {
	    int indice = ((Integer)(Clusters[i].elementAt(0))).intValue();
	    Sommet s = graphe.getSommet(indice);
	    s.fixe = false;
	    metaNoeud mn = new metaNoeud( "Cluster " + String.valueOf(i), s.x, s.y );

	    s.num_cluster = i;
	   
	    for ( int j = 0; j < Clusters[i].size(); j++ ) {
		int ind = ((Integer)(Clusters[i].elementAt(j))).intValue();
		Sommet ss = graphe.getSommet(ind);
		mn.sommets.addElement(ss);
		ss.num_cluster = i;
		mn.metrique += ss.metrique;
	    }
	    mn.type = 1;
	    mn.couleur = s.couleurClasse;
	    mn.couleurClasse = s.couleurClasse;
	    mg.sommets.addElement((Sommet)mn);   
	    //System.out.println(" mn.nom " + mn.couleurClasse + " s.nom "+ s.nom +" la couleur de sa classe "+ s.couleurClasse);
	    int cpt_intra_aretes = 0;

	    for ( int k = 0; k < graphe.aretes.size(); k++) {
		Arete a = graphe.getArete(k);
		Sommet e1 = a.getE1();
		Sommet e2 = a.getE2();

		if ( e1.num_cluster == e2.num_cluster ) {
		    Arete intra_arete = new Arete(e1, e2, e1.x, e2.x, null, a.getNom(), 
						  cpt_intra_aretes++ );
		    intra_arete.setVal(a.getVal());
		    mn.aretes.addElement(intra_arete); 
		}
	    }
	}
	mg.maximumMetrique();

	int cpt_meta_aretes = 0;

	for ( int i = 0; i < graphe.aretes.size(); i++) {
	    Arete a = graphe.getArete(i);
	    Sommet e1 = a.getE1();
	    Sommet e2 = a.getE2();
	    if ( e1.num_cluster != e2.num_cluster ) {
		metaNoeud m1 = ( metaNoeud)mg.getSommet(e1.num_cluster);
		metaNoeud m2 = ( metaNoeud)mg.getSommet(e2.num_cluster);
		
		Arete meta_arete = new Arete( m1, m2, m1.x, m2.x, null, a.getNom(), 
					     cpt_meta_aretes++ );
		meta_arete.setVal(a.getVal());
		mg.aretes.addElement(meta_arete); 
	    }
	}
	mg.maximumArete();
    }

    public void SaveImage() {
	
	/*BufferedImage loc_img = new BufferedImage(322,322,BufferedImage.TYPE_INT_RGB);
	Graphics loc_g2d = loc_img.createGraphics();
	//coloration du font en blanc
	loc_g2d.setColor(Color.white);
	loc_g2d.fillRect(0, 0, 322, 322);

	//enregistrement du graphique en image jpg sur le disque
	File file;
	FileOutputStream out;
	try
	    {
		file = new File("Impression.jpg");
		out = new FileOutputStream(file);
		JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(out);
		JPEGEncodeParam param = encoder.getDefaultJPEGEncodeParam(loc_img);
		param.setQuality(1.0f, false);
		encoder.setJPEGEncodeParam(param);
		try
		    {
			encoder.encode(loc_img);
		    }
		catch (IOException par_e)
		    {System.err.println(par_e.getMessage());}
		out.close();
	    }
	catch (IOException e){ return; }
    */
    }
    // *************************************************
    // *************************************************

    public static void main(String[] argv) {

	String instance = argv[1];
	int type = Integer.parseInt(argv[2]);
	int periode = Integer.parseInt(argv[3]);
	Graphe gr = new Graphe(false);

	//System.out.println(" instance = " + instance + " periode = " + periode );

	if ( type == 1 || type == 2 ) {	 
	    gr.ChargerMatriceSymetrique( argv[1], periode ); 
	}
	if ( type == 0 || type == 3 )
	    gr.ChargerMatriceAsymetrique( argv[1], periode);

	gr.typeMat = type;

	GraphPanel tgr2 = new GraphPanel( gr, true );
	

	StringTokenizer chemin  = new StringTokenizer( argv[0], "/");
	StringTokenizer chemin2 = new StringTokenizer( argv[1], "/");
	String repertoire = null;
	String fichier2 = null;

	while (chemin.hasMoreTokens() ) 
	    repertoire = chemin.nextToken();

	while (chemin2.hasMoreTokens() ) 
	    fichier2 = chemin2.nextToken();
	
	fichier2 = fichier2.substring(0, fichier2.length());
	tgr2.frame.setTitle( "Tétralogie VisuGraph : " + fichier2);
	tgr2.frame.setLocation(210, 0);
	String repertoire2 = argv[0].concat("/");
	if ( type == 0 ) {
	    String fichier  = repertoire2.concat(repertoire.concat(".varA"));
	    tgr2.nomslongs.LireNomsLongs(fichier);
	    fichier  = repertoire2.concat(repertoire.concat(".indA"));
	    NomLongs nomslongsbis = new NomLongs();
	    nomslongsbis.LireNomsLongs(fichier );
	    tgr2.nomslongs.data.putAll(nomslongsbis.data);
	} else {
	    String fichier  = repertoire2.concat(repertoire.concat(".indA"));
	    tgr2.nomslongs.LireNomsLongs(fichier );
	}
	
	for ( int i = 0; i < gr.nombreSommets(); i++ ) {
	    Sommet s = gr.getSommet(i);	    
	    s.nomlong = (String)tgr2.nomslongs.data.get( (Object)(s.nom) );	    
	}	
	
	tgr2.Items = new String[gr.nombreSommets()];

	tgr2.NbSommetsVisibles = gr.nombreSommets();

    	for ( int i = 0; i < gr.nombreSommets(); i++ ) {
	    Sommet s = gr.getSommet(i);
	    if ( s.nomlong != null ) 
		tgr2.Items[i] = s.nomlong;  
	    else {
		tgr2.Items[i] = s.nom;  
		s.nomlong     = s.nom;  
	    }
	}	
	tgr2.triRapide( tgr2.Items, 0, gr.nombreSommets() - 1 );	
	tgr2.gr.maximumMetrique();
	gr.TrierAretes();
	tgr2.init(periode);
	
	tgr2.gr.centre =  gr.getSommet(0);
	tgr2.gr.SetCouleursAretes(tgr2.gr.intensite);
	tgr2.frame.addWindowListener( new WindowAdapter() {
	    public void windowClosing(WindowEvent evt) {
		System.exit(0);
	    }
	});
	tgr2.Force = new ForceDirect( gr, 10 );
    }  
}


class MenuItemListener implements ActionListener {
   
    private GraphPanel gp;
    JMenuBar barreMenus;
    JMenu Animation, Labels, Representation, Clustering, Format;
    JMenuItem parametres, fdp, Random, arret, circulaire, cluster, stochastique, 
	MST, mst, metaGraphe, origine, imprimer, quitter, 
	sans, court, longs, pcercle, cercle, histog, classe;
    JMenuItem morph;
    JRadioButtonMenuItem sequentiel, differentiel;

    
    public MenuItemListener(GraphPanel gp) {
	this.gp = gp;
	
	gp.control.box3.addChangeListener(new NouvelleTache());
	gp.control.box4.addChangeListener(new NouvelleTache());
	gp.control.slider5.addChangeListener(new NouvelleTache());

	barreMenus = new JMenuBar();

	Animation = new JMenu("Animation"); 
	Animation.addActionListener(this);     
	Animation.setMnemonic('A');            

	parametres = new JMenuItem("Paramètres");  
	parametres.addActionListener(this);  
	Animation.add(parametres);

	fdp = new JMenuItem("Forces"); // mon FDP  
	fdp.addActionListener(this);  
	Animation.add(fdp);

	Random = new JMenuItem("Aléatoire");
	Random.addActionListener(this);  
	Animation.add(Random);

	arret = new JMenuItem("Arrêter");   // arret de l'animation
	arret.addActionListener(this);  
	Animation.add(arret);

	quitter =  new JMenuItem("Quitter");
	quitter.addActionListener(this);
	Animation.add(quitter);

	barreMenus.add(Animation);

	Representation = new JMenu("Représentation"); //  menu  Representation
	Representation.addActionListener(this); 
	Representation.setMnemonic('R');   

	circulaire = new JMenuItem("Circulaire"); 
	circulaire.addActionListener(this); 
	Representation.add(circulaire);     

	mst = new JMenuItem("Arbre Maximal");
	mst.addActionListener(this);
	mst.addChangeListener(new NouvelleTache());
	Representation.add(mst);

	MST = new JMenuItem("Arbre Minimal");
	MST.addActionListener(this);
	MST.addChangeListener(new NouvelleTache());
	Representation.add(MST);

	metaGraphe = new JMenuItem("Graphe de Clusters");
	metaGraphe.addActionListener(this);  
	metaGraphe.addChangeListener(new NouvelleTache());
	Representation.add(metaGraphe);

	origine = new JMenuItem("Graphe initial");
	origine.addActionListener(this);
	origine.addChangeListener(new NouvelleTache());
	Representation.add(origine);

	morph = new JMenuItem("Morphing");
	morph.addActionListener(this);
	morph.addChangeListener(new NouvelleTache());
	//Representation.add(morph);

	/*sequentiel = new JRadioButtonMenuItem("Sequentiel");
	sequentiel.addActionListener(this);
	sequentiel.addChangeListener(new NouvelleTache());
	morph.add(sequentiel);

	differentiel = new JRadioButtonMenuItem("Differentiel");
	differentiel.addActionListener(this);
	differentiel.addChangeListener(new NouvelleTache());
	morph.add(differentiel);*/

	barreMenus.add(Representation);  

	Clustering = new JMenu("Clustering");
	Clustering.addActionListener(this);     
	Clustering.setMnemonic('C');

	stochastique = new JMenuItem("Stochastique");
	stochastique.addActionListener(this);
	stochastique.addChangeListener( new NouvelleTache() );
	Clustering.add(stochastique);

	barreMenus.add(Clustering);
	
	JMenu menu = new JMenu("Sommets");
	menu.setMnemonic('S');

	FishEyeMenu subMenu = null;
	char label = ' ';
	JMenuItem item;
	for ( int i = 0; i < gp.Items.length; i++ ) {
	    if ( label != Character.toUpperCase(gp.Items[i].charAt(0)) ) {
		label  = Character.toUpperCase(gp.Items[i].charAt(0));
		subMenu = new FishEyeMenu(gp.Items[i].substring(0, 1).toUpperCase());
		menu.add(subMenu);
	    }	   
	    item = new JMenuItem( gp.Items[i] );
	    item.setLocation(menu.getLocation().x + 20, subMenu.getLocation().y );
	    item.addActionListener(this);
	    item.addChangeListener(new NouvelleTache());
	    subMenu.add(item);
	}

	barreMenus.add(menu);
	Labels = new JMenu("Labels");
	Labels.setMnemonic('L');
	barreMenus.add(Labels);
	
	sans = new JMenuItem("Sans");
	sans.addActionListener(this);
	Labels.add(sans); 
	
	court = new JMenuItem("Court");
	court.addActionListener(this);       
	Labels.add(court); 
	
	longs = new JMenuItem("Long");
	longs.addActionListener(this);            
	Labels.add(longs); 
	
	Format = new JMenu("Formats");
	Format.setMnemonic('F');
	barreMenus.add(Format);
	
	pcercle = new JMenuItem("Nuances");
	pcercle.addActionListener(this);
	Format.add(pcercle);
	
	cercle = new JMenuItem("Cercles");
	cercle.addActionListener(this);
	Format.add(cercle);
	
	histog = new JMenuItem("Barres");
	histog.addActionListener(this);
	Format.add(histog);
	
	classe = new JMenuItem("Classes");
	classe.addActionListener(this);
	Format.add(classe);
	
    }

     class NouvelleTache implements ChangeListener {
	public void stateChanged(ChangeEvent e) {   
	    
	    if ( !gp.mst1 && !gp.mst2 && !gp.mcl && !gp.connexe ) {
		if ( gp.control.slider5.getValue() == 0 )
		    gp.etatBarre.setString ("Graphe initial" );
		else 
		    if (! gp.control.box4.isSelected() ) 
			gp.etatBarre.setString ("Graphe d'instance :  "  +
						gp.control.slider5.getValue() );
		    else {
			int precedent = gp.control.slider5.getValue() - 1;
			gp.etatBarre.setString ("Graphe différentiel :  "  +
						gp.control.slider5.getValue() + " - " + 
						precedent );
		    }
	    }
	    if ( gp.mst1 && !gp.mst2 && !gp.mcl && !gp.connexe ) 
		gp.etatBarre.setString ("Arbre de poids maximal");
	    
	    if ( !gp.mst1 &&  gp.mst2 && !gp.mcl && !gp.connexe ) 
		gp.etatBarre.setString ("Arbre de poids minimal");

	    if ( !gp.mst1 && !gp.mst2 && gp.mcl && !gp.connexe ) 
		gp.etatBarre.setString ("Graphe de classe" );

	    if ( ( gp.connexe && !gp.mst1 && !gp.mst2 && !gp.mcl ) ||
		 ( gp.connexe &&  gp.mst1 && !gp.mst2 && !gp.mcl ) ||
		 ( gp.connexe && !gp.mst1 &&  gp.mst2 && !gp.mcl ) ||
		 ( gp.connexe && !gp.mst1 && !gp.mst2 &&  gp.mcl )) {
		if ( gp.individuChoisi != null )
		    gp.etatBarre.setString ("Sous-Graphe de :" + gp.individuChoisi );
		else
		    gp.etatBarre.setString ("Sous-Graphe de :"  );
		
	    }

	    gp.etatBarre.setStringPainted(true);
	    gp.repaint();
	}

    }
    public void actionPerformed(ActionEvent e) {
	
	Object source = e.getSource(); // Extrait l'élément du menu sélectionné
	Dimension d = gp.getSize();
       
	
	if( source == imprimer) gp.imprimer(); 
	else if( source == quitter )  {
	    gp.frame.dispose();
	    System.exit(0); // Quitte le programme
	}
	else if (source == sans ) { // sommets sans labels
	    gp.gr.sans  = true;
	    gp.gr.longs = false; 
	    if ( gp.mst1 && gp.lArbre1 != null ) {
		gp.lArbre1.sans  = gp.gr.sans;
		gp.lArbre1.longs = gp.gr.longs;
	    }
	    if ( gp.mst2 && gp.lArbre2 != null ) {
		gp.lArbre2.sans  = gp.gr.sans;
		gp.lArbre2.longs =gp.gr.longs ;
	    }
	    if ( gp.mcl && gp.mg != null ) {
		gp.mg.sans  = gp.gr.sans;
		gp.mg.longs = gp.gr.longs ;
	    }
	    if ( gp.connexe && gp.cnx != null ) {
		gp.cnx.sans  = gp.gr.sans;
		gp.cnx.longs = gp.gr.longs ;	
	    }   
	    if ( gp.morphing != null ) {
		gp.morphing.sans  = gp.gr.sans;
		gp.morphing.longs = gp.gr.longs ;
	    }
	}
	else if (source == court ) { // sommets avec labels courts
	    gp.gr.sans = false;
	    gp.gr.longs = false;
	   if ( gp.mst1 && gp.lArbre1 != null ) {
		gp.lArbre1.sans  = gp.gr.sans;
		gp.lArbre1.longs = gp.gr.longs;
	    }
	    if ( gp.mst2 && gp.lArbre2 != null ) {
		gp.lArbre2.sans  = gp.gr.sans;
		gp.lArbre2.longs = gp.gr.longs ;
	    }
	    if ( gp.mcl && gp.mg != null ) {
		gp.mg.sans  = gp.gr.sans;
		gp.mg.longs = gp.gr.longs ;
	    }
	    if ( gp.connexe && gp.cnx != null ) {
		gp.cnx.sans  = gp.gr.sans;
		gp.cnx.longs = gp.gr.longs ;	
	    }
	    if ( gp.morphing != null ) {
		gp.morphing.sans  = gp.gr.sans;
		gp.morphing.longs = gp.gr.longs ;
	    }
	}
	else if (source == longs ) { // sommets avec labels longs
	    gp.gr.sans = false;
	    gp.gr.longs = true;

	    if ( gp.lArbre1 != null ) {
		gp.lArbre1.sans  = gp.gr.sans;
		gp.lArbre1.longs = gp.gr.longs;
	    }
	    if ( gp.lArbre2 != null ) {
		gp.lArbre2.sans  = gp.gr.sans;
		gp.lArbre2.longs = gp.gr.longs ;
	    }
	    if ( gp.mg != null ) {
		gp.mg.sans  = gp.gr.sans;
		gp.mg.longs = gp.gr.longs ;
	    }
	    if ( gp.connexe && gp.cnx != null ) {
		gp.cnx.sans  = gp.gr.sans;
		gp.cnx.longs = gp.gr.longs ;	
	    }
	    if ( gp.morphing != null ) {
		gp.morphing.sans  = gp.gr.sans;
		gp.morphing.longs = gp.gr.longs ;
	    }
	}
	// type de dessin 
	else if (source == Random) { // dessin aleatoire
	    gp.random = true;
	    if ( !gp.mcl )
		for (int i = 0 ; i < gp.gr.nombreSommets() ; i++) {
		    Sommet n =  gp.gr.getSommet(i);
		    if (!n.fixe) {
			Point p = gp.gr.nouvellePosition(d.width, d.height);
			n.x = p.x ;
			n.y = p.y;
		    }
		}
	    else 
		for (int i = 0 ; i < gp.mg.nombreSommets() ; i++) {
		    Sommet n =  gp.mg.getSommet(i);
		    if (!n.fixe) {
			Point p = gp.mg.nouvellePosition(d.width, d.height);
			n.x = p.x ;
			n.y = p.y; 
		    }
		}
	} else if (source == fdp) {  // dessin avec animation
	    gp.force3 = true;
	    gp.circulaire = false;
	    
	    if ( !gp.connexe && !gp.mst1 && !gp.mst2) {
		gp.Force = new ForceDirect(gp.gr, 10 );
		
		gp.Force.time = 1.0;
		gp.Force.Temp(10);
	    } else 
		if ( gp.connexe) { 
		    gp.Force = new ForceDirect(gp.cnx, 10 );
		    
		    gp.Force.time = 1.0;
		    gp.Force.Temp(10);
		}
		else 
		    if ( gp.mcl) {
			
			gp.Force = new ForceDirect(gp.mg, 10 );
			
			gp.Force.time = 1.0;
			gp.Force.Temp(10);
		    } 
	    if ( gp.mst1 || gp.mst2) {
		gp.Force = new ForceDirect(gp.mg, 10 );
		
		gp.Force.time = 1.0;
		gp.Force.Temp(10);
	    }
	    gp.start();  
	}
	else if (source == arret) { // arret de l'animation
	    gp.force3 = false; 
	    gp.stop();
	}
	else if ( source == circulaire ) {
	    gp.circulaire = true; 
	    gp.force3 = false;
	    gp.stop();
	    if ( gp.connexe ) 
		gp.circulaire(gp.cnx);
	    else 
		gp.circulaire(gp.gr);
	    if ( gp.mcl ) 
		gp.circulaire(gp.mg);
	    if ( gp.morphing != null ) 
		gp.circulaire(gp.morphing);

	} 
	else if ( source == parametres ) { //affichage de la fenetre des parametres
	    gp.control.fenetre.setVisible(true);
	}
	else if (source == stochastique ) { // clustering stochastique
	    gp.force3 = false;
	    
	    gp.stop();
	    String chemin =  System.getProperty("cheminResult"); 	   
	    String cheminin  =  chemin + "/clusters.out"; 
	    String cheminout =  chemin + "/out.clusters"; 
	    
	    gp.MCL(cheminin);
	    if ( gp.gr.clustering ) {
		System.out.println("Fin de clustering ");
		gp.cluster2 = true;
		gp.mcl = true; 
		gp.lireClustersMCL(cheminout);
		
		gp.initColor();
		gp.mg.sans = gp.gr.sans;
		gp.mg.longs = false;
		gp.mg.cercle  = gp.gr.cercle;
		
		for (int i = 0; i < gp.nbClusters; i++ ) {		
		    for (int j = 0; j < gp.Clusters[i].size(); j++) {
			int ind = ((Integer)(gp.Clusters[i].elementAt(j))).intValue();
			try {
			    Sommet s = gp.gr.getSommet(ind);
			    s.couleurClasse = gp.CouleursClusters[i];
			}catch (ArrayIndexOutOfBoundsException exception) {
			    ;
			}
		    }
		}
		gp.genereClusters(gp.gr);
		if (gp.flag) gp.circulaireClustered(gp.gr);
		gp.flag = false;	    
	    }
	}
	// types de structures
	else if (source == mst) { // arbre recouvrant minimum
	    if (gp.force3 ) gp.force3 = false;
	    gp.mst1 = true;
	    gp.mst2 = false; 
	    gp.mcl = false;
	    if ( !gp.connexe ) {
		gp.ArbreCouvrant(gp.gr);
		gp.lArbre1.cercle = gp.gr.cercle;
	    }
	    else {
		gp.ArbreCouvrant(gp.cnx);
	   	gp.lArbre1.cercle = gp.cnx.cercle;
	    }

	}else if (source == MST) { // arbre recouvrant maximum
	    if (gp.force3 ) gp.force3 = false;
	    gp.mst1 = false;
	    gp.mst2 = true; 
	    gp.mcl = false;
	    
	    if ( !gp.connexe ) {
		gp.ArbreCouvrant2(gp.gr);
		gp.lArbre2.cercle = gp.gr.cercle;
	    }
	    else {
		gp.ArbreCouvrant2(gp.cnx);
		gp.lArbre2.cercle = gp.cnx.cercle;
	    }
	}
	else if (source == origine) { // graphe d'origine
	    gp.mst1 = false;
	    gp.mst2 = false;
	    gp.mcl = false;
	    if (gp.flag ) {
		gp.circulaireClustered(gp.gr);
		gp.flag = false;
	    }
	}
	else if ( source == metaGraphe ) { // graphe de clusters : meta-graphe	     
	    if (gp.force3 ) gp.force3 = false;
	    gp.mst1 = false;
	    gp.mst2 = false;
	    if ( gp.gr.typeMat == 1 ) {
		gp.mcl = true;	
		gp.mg.cercle  = gp.gr.cercle;
	    }
	}else if ( source == morph ) { // graphe de clusters : meta-graphe	     
	    //if (gp.force3 ) gp.force3 = false;
	    gp.mst1 = false;
	    gp.mst2 = false;
	    gp.mcl = false;
	}
	else if ( source == pcercle  ) {
	    gp.gr.cercle = 0;
	    if ( gp.lArbre1 != null ) 
		gp.lArbre1.cercle = gp.gr.cercle;
	    if ( gp.lArbre2 != null ) 
		gp.lArbre2.cercle = gp.gr.cercle;
	    if ( gp.mg != null ) 
		gp.mg.cercle = gp.gr.cercle;
	    if ( gp.connexe  ) 
		gp.cnx.cercle = gp.gr.cercle;
	    if ( gp.morphing != null ) 
		gp.morphing.cercle = gp.gr.cercle;

	} else if ( source == cercle ) {
	    gp.gr.cercle = 1;
	    if ( gp.lArbre1 != null ) 
		gp.lArbre1.cercle  = gp.gr.cercle;
	    if ( gp.lArbre2 != null ) 
		gp.lArbre2.cercle  = gp.gr.cercle;
	    if ( gp.mg != null ) 
		gp.mg.cercle  = gp.gr.cercle;
	    if ( gp.connexe ) 
		gp.cnx.cercle  = gp.gr.cercle;
	    if ( gp.morphing != null ) 
		gp.morphing.cercle = gp.gr.cercle;

	} else if ( source == histog ) {
	    gp.gr.cercle = 2;  
	    if ( gp.lArbre1 != null ) 
		gp.lArbre1.cercle  = gp.gr.cercle;
	    if ( gp.lArbre2 != null ) 
		gp.lArbre2.cercle  = gp.gr.cercle;
	    if ( gp.mg != null ) 
		gp.mg.cercle  = gp.gr.cercle;
	    if ( gp.connexe ) 
		gp.cnx.cercle  = gp.gr.cercle;
	    if ( gp.morphing != null ) 
		gp.morphing.cercle = gp.gr.cercle;

	} else if ( source == classe ) {
	    if ( gp.gr.typeMat == 1 ||  gp.gr.typeMat == 2 )
		gp.gr.cercle = 3; 
	    else gp.gr.cercle = 0;

	    if ( gp.lArbre1 != null )
		gp.lArbre1.cercle  = gp.gr.cercle;
	    if ( gp.lArbre2 != null ) 
		gp.lArbre2.cercle  = gp.gr.cercle;
	    if ( gp.mg != null ) 
		gp.mg.cercle = gp.gr.cercle;
	    if ( gp.connexe ) 
		gp.cnx.cercle = gp.gr.cercle;
	    if ( gp.morphing != null ) 
		gp.morphing.cercle = gp.gr.cercle;
	}
	else { // le cas d'exploration a partir d'un focus.  
	    JMenuItem item = (JMenuItem)e.getSource();
	    gp.individuChoisi = item.getText();
	    Sommet selectionne = null;
	    
	     if ( !gp.control.box3.isSelected()) 
		 gp.control.box3.setSelected(true);
	     
	    int w = (int)(d.width- 20)/2;
	    int h = (int)(d.height-6)/2;
	    boolean trouve = false;
	    gp.cnx = null;
	    gp.cnx = new Graphe(false);
	    gp.cnx.typeGraphe = gp.gr.typeGraphe;
	    gp.cnx.instance = gp.gr.instance;

	    gp.cnx.stress = gp.gr.stress; 
	    gp.cnx.noms   = gp.gr.noms;
	    gp.cnx.cercle = gp.gr.cercle;
	    gp.cnx.longs  = gp.gr.longs;
	    gp.cnx.sans   = gp.gr.sans;
	    gp.cnx.maxMetrique1 = gp.gr.maxMetrique1;
	    gp.cnx.maxMetrique2 = gp.gr.maxMetrique2;
	    gp.cnx.maxArete = gp.gr.maxArete;
	    gp.cnx.typeMat = gp.gr.typeMat;
	    // Identification d'item selectionné dans le graphe d'origine
	    if ( !gp.mst1 || !gp.mst2 && gp.connexe == true) {
		for ( int i = 0; i < gp.gr.nombreSommets() && !trouve; i++) {
		    Sommet s = gp.gr.getSommet(i);
		    s.setCouleurTxt(Color.black);
		    if ( s.fixe ) {
			s.x += 20;
			s.y += 20;
			s.fixe = false;
		    }
		    s.marked = false; 
		    s.niveau = 100;
		    
		    if (( s.nom.compareToIgnoreCase(gp.individuChoisi) == 0 || 
			 s.nomlong.compareToIgnoreCase(gp.individuChoisi) == 0 ) ) {
			
			selectionne = s;
			selectionne.fixe = true;
			selectionne.x = w;
			selectionne.y = h;
			s.x = w;
			s.y = h;
			trouve = true;
			s.setCouleur(Color.black);
			//s.setCouleurTxt(Color.red);
			s.niveau = 0;
			gp.cnx.ajouterSommet(s);
		    }
		}
		// Recherche des voisins de l'item selectionné  
		gp.gr.getVoisins( selectionne, false, gp.cnx.seuil );
		for ( int i = 0; i < selectionne.voisins.size(); i++ ) { 
		    Sommet s = (Sommet)selectionne.voisins.elementAt(i); 
		    gp.cnx.ajouterSommet(s);
		    s.niveau = 1;
		    s.setCouleur(Color.red);
		    s.setCouleurTxt(Color.black);
		    //s.fixe = true;
		    int indice = gp.gr.areteDansGraphe(selectionne, s);  
		    if ( indice != -1 ) {
			Arete a = gp.gr.getArete(indice);
			gp.cnx.ajouterArete(a);
		    }
		}
		for ( int i = 0; i < gp.cnx.nombreSommets(); i++) { 
		    Sommet si = gp.cnx.getSommet(i);
		    for ( int j = 0; j < gp.cnx.nombreSommets(); j++) { 
			Sommet sj = gp.cnx.getSommet(j);
			if ( i != j ) {
			    int indice = gp.gr.areteDansGraphe(si, sj); 
			    if ( indice != -1 ) {
				Arete a = gp.gr.getArete(indice);
				gp.cnx.ajouterArete(a);
			    }
			}
		    }
		}
	    }
	    if ( gp.mst1 && !gp.mst2 && gp.connexe == true ) {
		for ( int i = 0; i < gp.lArbre1.nombreSommets(); i++) {
		    Sommet s = gp.lArbre1.getSommet(i);
		    
		    if ( s.fixe ) {
			s.x += 20;
			s.y += 20;
			s.fixe = false;
		    }
		    if ( s.nom.compareTo(gp.individuChoisi) == 0 ) {	
			selectionne = s;
			selectionne.fixe = true;
			selectionne.x = w;
			selectionne.y = h;
		    }
		}
	    }
	    if ( !gp.mst1 && gp.mst2 && gp.connexe == true ) {
		for ( int i = 0; i < gp.lArbre2.nombreSommets(); i++) {
		    Sommet s = gp.lArbre2.getSommet(i);	    
		    if ( s.fixe ) {
			s.x += 20;
			s.y += 20;
			s.fixe = false;
		    }
		    if ( s.nom.compareTo(gp.individuChoisi) == 0 ) {
			selectionne = s;
			selectionne.fixe = true;
			selectionne.x = w;
			selectionne.y = h;
		    }
		}	
	    }
	    gp.cnx.initDegre();
	    gp.cnx.maximumMetrique();
	    gp.cnx.maximumArete();
	    
	} 
	gp.repaint();
    }
}
/**
 * Permet la manipulation simple de matrices.
 */

import java.io.*;
import java.util.*;
import java.lang.*;

public class Matrice
{
    private double[][] m;    // Tableau a deux dimensions rectangulaire
    public Vector labels;   // liste des labels des lignes
   
    /**
     * Construit la matrice a partir d'un tableau a deux dimensions. Le 
     * tableau doit etre rectangulaire, c'est-a-dire que chacune de ses lignes 
     * doit comporter un meme nombre d'elements. Pour i et j de 0 
     * a m.length-1, m[i].length==m[j].length.
     @param m le tableau a utiliser
     */
    
    Matrice(double[][] m)
    {
	testRectangulaire(m);
	this.m = m;
    }

    /**
     * Construit une matrice a partir de dimensions. Les dimensions doivent 
     * etre positives et non nulles.
     @param M nombre de lignes de la matrice 
     @param N nombre de colonnes de la matrice 
     */

    Matrice(int M, int N)
    {
	if (M <= 0 || N <= 0)
	    throw new BadMatrixDimensionsException("Dimensions must be non-null.");
	m = new double[M][N];
	for (int i = 0; i < m.length; i++)
	    for (int j = 0; j < m[i].length; j++)
		m[i][j] = 0.0;
    }
    /**
     * Construit une matrice a partir d'un fichier texte. Ce fichier est une representation
     * de la matrice d'adjacence d'un graphe.
     */
    Matrice( String nom_fichier) { 
	int M = 0;
	labels = new Vector();
	double[][] mat= new double[M][M];

	try {
	    File file = new File (nom_fichier);
	    Reader rd_result = new FileReader (file);
	   
	    String ligne_doc = null;
	    LineNumberReader line = new LineNumberReader(rd_result);
	    
	    while ( (ligne_doc = line.readLine()) != null )
		M++;
	    M--;

	    mat = new double[M][M];
	    // lecture de fichier ligne par ligne
	    ligne_doc = line.readLine();
	    
	    int l = 0;
	    while ( ligne_doc != null && l < mat.length ) {
		l++;
		int j = 0;
		int k = line.getLineNumber() - 1;
		StringTokenizer lab = new StringTokenizer(ligne_doc);
		String s = lab.nextToken();
		labels.addElement(s);

		while( lab.hasMoreTokens() && j < mat[k].length  ) {

		    // chargement de la ligne dans tab
		    String str = lab.nextToken();
		    try {
			double a = Integer.parseInt(str);
			mat[k][j++] = a;	
		    } 
		    catch(NumberFormatException ex) {
			System.out.println ("NumberFormatException"); 
		    }
		}
		ligne_doc = line.readLine();	
	    }
	    
	    line.close();
	} 
	catch( IOException e2 ) {
	    System.err.println(e2); System.exit(1); 
	    
	}
	catch (NullPointerException e3  ) {
	    System.out.println("\nNullPointerException : " + e3 );
	}

	this.m = mat;
    }
    /**
     * Construit une matrice a partir d'un fichier texte. Ce fichier est une representation
     * de la matrice d'incidence d'un graphe.
     */
    Matrice( String nom_fichier, int M, int N) { 
	
	double[][] mat = new double[M][N];
	
	labels  = new Vector();  // labels des sommets en lignes

	try {
	    File file = new File (nom_fichier);
	    Reader rd_result = new FileReader (file);
	  
	    String ligne_doc = null;
	    LineNumberReader line = new LineNumberReader(rd_result);
	    
	    // lecture des labels des sommets en colonnes
	    ligne_doc = line.readLine();
	    int i = 0;
	    StringTokenizer labc = new StringTokenizer(ligne_doc);
	    while ( i < N ) {
		String s = labc.nextToken();
		labels.addElement(s);
		i++;
	    }
	    int l = 0;
	    ligne_doc = line.readLine();
	    // lecture des labels des sommets en lignes
	    while ( ligne_doc != null && l < mat.length ) {
		l++;
		int j = 0;
		int k = line.getLineNumber() - 2;
		StringTokenizer lab = new StringTokenizer(ligne_doc);
		String s = lab.nextToken();
	
		labels.addElement(s);
		
		while( lab.hasMoreTokens() && j < mat[k].length  ) {

		    // chargement de la ligne dans tab
		    String str = lab.nextToken();
		    try {
			double a = Integer.parseInt(str);
			mat[k][j++] = a;	
		    } 
		    catch(NumberFormatException ex) {
			System.out.println ("NumberFormatException"); 
		    }
		}
		ligne_doc = line.readLine();	
	    }
	 
	    line.close();
	} 
	catch( IOException e2 ) {
	    System.err.println(e2); System.exit(1); 
	    
	}
	catch (NullPointerException e3  ) {
	    System.out.println("\nNullPointerException : " + e3 );
	}
	
	
	double[][] Total = new double[M+N][M+N];
	
	for ( int i = 0; i < N; i++ ) 
	    for (int j = 0; j < N; j++ ) 
		Total[i][j] =  0.0;

	for ( int i = N; i < M+N; i++) 
	    for (int j = N; j < M+N; j++ ) 
		Total[i][j] = 0.0;

	for ( int i = N; i < M+N; i++) 
	    for (int j = 0; j < N; j++) 
		Total[i][j] = mat[i-N][j];

	for ( int i = 0; i < N; i++) 
	    for (int j = N; j < M+N; j++ ) 
		Total[i][j] = mat[j-N][i];

	
	this.m = Total;
    }
    
    /*
     * Construit une matrice a partir d'une autre, en copiant les 
     * données de l'autre objet.
     */
    Matrice(Matrice mat)
    {
	this(mat.getM(), mat.getN());
	for (int i = 0; i < m.length; i++)
	    for (int j = 0; j < m[0].length; j++)
		set(i, j , mat.get(i, j));
    }
    
    /**
     * Teste si un tableau a deux dimensions est rectangulaire. 
     * Si le tableau n'est pas rectangulaire, une exception 
     * est lancee.
     @param m le tableau a tester
     @exception NotRectangularArrayException
     */
    private void testRectangulaire(double[][] m)
    {
	int M = m.length;
	if (M == 0)
	    throw new BadMatrixDimensionsException("Matrice Nulle.");
	else if (M == 1)
	    return;  // une ligne, matrice rectangulaire.
	int N = m[0].length;
	for (int i = 1; i < M; i++)
	    {
		if (m[i].length != N)
		    throw new NotRectangularArrayException("The " + i + "th row has a different length.");
	    }
    }
   /* 
      Le calcul de la fermeture transitive d'un graphe représenté par une matrice d'adjacence se 
      fait en répétant le produit de matrices effectué pour calculer le nombres de chemins ( en 
      changeant le + par un | et le * par un & ) jusqu'à obtenir une matrice dont la valeur ne 
      change plus.
   */
    
    public double get(int i, int j) { return m[i][j]; }
    public void set(int i, int j, double v) { m[i][j] = v; }
    public int getM() { return m.length; }
    public int getN() { return m[0].length; }
    public double[][] getMatrice() {return m;}
    /**
     * Retourne la matrice identite de MxM.
     @param M dimension de la matrice identite
     @return matrice identite resultante
     */
    public static Matrice identite(int M)
    {
	Matrice mat = new Matrice(M, M);
	for (int i = 0; i < M; i++)
	    mat.set(i,i,1.0);
	return mat;
    }

    /**
     * Transpose la matrice, retournant un nouvel objet Matrice resultat.
     @return resultat de la transposee
     */
    public Matrice transpose(Matrice matrice)
    {
	Matrice mat = new Matrice(matrice.m[0].length, matrice.m.length);
	for (int i = 0; i < matrice.m.length; i++)
	    for (int j = 0; j < matrice.m[0].length; j++)
		mat.set(j,i, matrice.get(i,j));
	return mat;
    }

    /**
     * Produit de deux matrices, retournant un nouvel objet Matrice resultat.
     @return resultat de la produit
    */
    public Matrice produit( Matrice matrice1, Matrice matrice2 )
    {
	Matrice produit = new Matrice(matrice1.m.length, matrice1.m.length);
	for (int i = 0; i < matrice1.m.length; i++)
	    for (int j = 0; j < matrice2.m.length; j++) {
		for (int k = 0; k < matrice2.m.length; k++) 
		    produit.m[i][j] += matrice1.m[i][k]*matrice2.m[i][k];
	    }
	return produit;

    }
    /**
     * Convertit la matrice en une chaine affichable
     */
    public String toString()
    {
	String str = "Matrice: [";
	for (int i = 0; i < m.length; i++)
	    {
		if (i > 0)
		    str += " ";
		str += "[";
		for (int j = 0; j < m[0].length; j++)
		    {
			if (j > 0)
			    str += " ";
			str += m[i][j];
		    }
		str += "]";
	    }
	str += "]";
	return str;
    }

    /**
     * Verifie si deux matrices sont egales en testant chaque element.
     */
    public boolean equals(Matrice mat)
    {
	if (getM() != mat.getM() || getN() != mat.getN())
	    return false;
	for (int i = 0; i < m.length; i++)
	    for (int j = 0; j < m[0].length; j++)
		if (m[i][j] != mat.get(i,j))
		    return false;
	return true;
    }
}

class NotRectangularArrayException extends RuntimeException
{
    NotRectangularArrayException(String msg)
    {
	super(msg);
    }
}

class BadMatrixDimensionsException extends RuntimeException
{
    BadMatrixDimensionsException(String msg)
    {
	super(msg);
    }
}
import java.util.*;

public class metaNoeud extends Sommet {
    //    public String label =new String();
    public Vector sommets  = new Vector() ;
    public Vector aretes   = new Vector();

    metaNoeud(String lab, int x, int y) {
	super(x, y, lab );
    }

    
}
class Morphing extends  Graphe {

    int type; // graphe relatif a une instance (type=0) graphe differentiel (type=1)
    Morphing(boolean oriented){
	super(oriented);
	this.typeMat = 0;
	this.type = 0;
    }
}
import java.io.*;
import java.util.*;
import java.lang.*;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.Iterator;

class NomLongs extends HashMap{
    public Map data;

    public NomLongs() {
	data = new HashMap();
    }

    public void ajouterEntree(String nomcourt, String  nomlong) {
	if ( data.containsKey( nomcourt ) ) {
	    // le sommet est déjà présent
	    //return false;
	}
	else {
	    // le sommet  n'est pas présent
	    data.put( nomcourt,  nomlong);
	    //return true;
	}
    }
    public void LireNomsLongs(String nom_fichier) {
	
	try {
	    
	    File file = new File (nom_fichier);
	    Reader rd_result = new FileReader (file);
	    
	    String ligne_doc = null;
	    LineNumberReader line = new LineNumberReader(rd_result);
	    
	    // lecture des 2 lignes du fichier
	    ligne_doc = line.readLine();
	    ligne_doc = line.readLine();
	    ligne_doc = line.readLine();
	    int l = 0;
	   
	    while ( ligne_doc != null ) {
		boolean fini = false;
		StringTokenizer lab = new StringTokenizer(ligne_doc, " " );
		int nb = lab.countTokens();
		
		while ( lab.hasMoreTokens() && !fini) {
		   
		    String nomcourt = lab.nextToken();
		    String nomlong  = lab.nextToken();
		    int i = 1;
		    if ( nb > 3 ) {
			while ( lab.hasMoreTokens() && i < nb-2 ) {
			    String morceau = lab.nextToken();
			    nomlong = nomlong.concat(" ");
			    nomlong = nomlong.concat(morceau);	
			    i++;
			}
		    }
		    //System.out.println("nomcourt " + nomcourt + "nomlong " + nomlong);
		    ajouterEntree( nomcourt, nomlong);
		    fini = true;
		}
		ligne_doc = line.readLine();
		
	    }
	    line.close();
	} 
	catch ( IOException e2 ) {
	    System.err.println("\n Désolé, vous ne disposez pas de noms longs \n" ); 
	    //System.exit(1);    
	}
	catch (NullPointerException e3  ) {
	    System.err.println("\n Désolé, vous ne disposez pas de noms longs\n" );
	} 
	
    }
}
import java.awt.*;
import java.util.*;

/**
 * La classe Sommet represente un sommet dans un graphe. Elle comporte 
 * ce qu'il faut pour positionner et afficher le sommet sur le plan,
 * avec ou sans etiquette de sommet. Les sommets sont representes 
 * dans le graphe par des cercles de rayon RAYON, une constante.
 */
public class Sommet {
    public int x; 
    public int y;

    public int x0; 
    public int y0;

    public Color couleur;                        // couleur en fonction de la metrique
    public Color couleurClasse = Color.blue;     // couleur apres clustering
    public Color couleurTranst = Color.white;    // couleur dans la SR obtenue par transitivité
    public static  Color couleurTexte = Color.white;
    public Color [] CouleurTab = {Color.red, 
				  Color.blue, 
				  Color.magenta, 
				  Color.orange, 
				  Color.green, 
				  Color.white};

    public Color [] CouleurTab2 = {Color.red.darker(), 
				   Color.blue.darker(), 
				   Color.magenta.darker(),
				   Color.orange.darker(), 
				   Color.green.darker(), 
				   Color.gray};

    ControlWindow control = null;
    public String nom;     // nom court : peut etre null si pas d'etiquette
    public String nomlong; // nom long  : peut etre null si pas d'etiquette
    public static final int RAYON = 5;
    public static int larg = 20;
    public static int haut = 10;
    public int classe;
    public int type;

    private boolean visible = true;
    private int degre = 0;
    public boolean fixe = false;
    
    public Vector voisins;

    public int num_cluster = 0;
    public double metrique;
    public double Metrique[];
    public int niveau = 100;

    // pour les effets d'attraction/repulsion 
    public double dx, dy;

    // pour figer la periode (le nombre d'instances)
    public int per;
    
    public final void forced( Sommet other, double factor ) {
	dx += (x - other.x) * factor;
	dy += (y - other.y) * factor;
    }
    public final void scaleDelta( double factor ) {
	dx = dx * factor;
	dy = dy * factor;	
    }
    public final void stabilize() {
	dx = dy = 0.0;
    }
    public final double deltaForce() {
	return Math.sqrt( dx*dx + dy*dy );
    }
    public final void moveDelta( double factor ) {
	x += dx * factor;
	y += dy * factor;
    }
   
    protected boolean marked = false;
    protected final void mark() { marked = true;}
    protected final void unmark() {marked = false;}
    protected final boolean marked() {return marked;}
  
    /**
       Construit un objet Sommet. La couleur est noire et il n'y a pas 
       d'etiquette de sommet.
       @param x abcisse du sommet
       @param y ordonnee du sommet
     */
    Sommet(int x, int y) {
	this.x = x;
	this.y = y;
	couleur = Color.red;
	nom = null;
	Metrique = new double[10];
    }

    /*
       Construit un objet Sommet. Il n'y a pas d'etiquette de sommet.
       @param x abcisse du sommet
       @param y ordonnee du sommet
       @param couleur couleur du sommet
     */
    Sommet(int x, int y, Color couleur)
    {
	this(x,y);
	if (couleur == null)
	    this.couleur = Color.white;
	else
	    this.couleur = couleur;	
    }

    /**
       Construit un objet Sommet. La couleur est par defaut noire.
       @param x abcisse du sommet
       @param y ordonnee du sommet
       @param nom etiquette du sommet
     */
    Sommet(int x, int y, String nom) {
	this(x,y);
	this.nom = nom;
    }

    /**
       Construit un objet Sommet.
       @param x abcisse du sommet
       @param y ordonnee du sommet
       @param couleur couleur du sommet
       @param nom etiquette du sommet
     */
    Sommet(int x, int y, Color couleur, String nom) {
	this(x, y, couleur);
	this.nom = nom;
    }

    public int getX() { return x; }
    public int getY() { return y; }
    
    public Color getCouleur() { return couleur; }
    public String getNom() { return nom; }
    public void setCouleur(Color couleur) { this.couleur = couleur; }
    public void setCouleurTxt(Color couleur) { this.couleurTexte = couleur; }
    public void setInvisible() { this.visible = false; }
    public void setVisible() { this.visible = true; }
    public boolean getVisible() {  return this.visible;  }
   
    public void setDegre(int degre) { this.degre = degre; }
    public int getDegre() {  return this.degre;  }

    /**
       Convertit l'objet Sommet en chaine affichable.
       @return un objet String contenant une chaine decrivant l'objet Sommet
     */
    public String toString()
    {
	String str = "Sommet: (centre en (" + x + "," + y + "), de couleur " + couleur;
	str += nom == null ? " ne portant pas d'etiquette)" : 
	    (" avec " + nom + " comme etiquette)");
	return str;
    }

    /**
       Affiche le sommet sur un contexte graphique Java, en respectant 
       les coordonnees du sommet, sa couleur et l'etiquette. 

       Cette methode ne connaissant pas la taille de la zone d'affichage, 
       aucune verification n'est effectuee pour savoir si toutes les informations 
       entrent sur la zone ou ecrasent une etiquette d'un autre sommet.
       @param g le contexte d'affichage Java a utiliser.
       Cette fonction permet de tracer les histogrammes. Pour ce faire, periode correspond à l'instance de morphing, max correspond au maxmétrique
     */
    public synchronized void afficherInstances(Graphics g,
					       boolean Etiquette,
					       boolean Longs,
					       double max,
					       int periode, boolean clustering ) {
	per=periode;
	Color old = g.getColor();
	double quantite = 0.0, cl = 0.0;
	Graphics2D g2 = (Graphics2D)g;

	if ( this.getVisible() ) {
	    // instances sous forme de barres
	  //  for ( int i = 1; i <= periode ; i++ )
	    for ( int i = 1; i <= periode ; i++ ) {
		quantite = 20*Metrique[i]/Metrique[periode+1] ;
		if ( type == 1 && !clustering )
		    g2.setColor( Color.red );
		if ( type == 1 &&  clustering )
		    g.setColor(couleurClasse);
		if ( type == 0 )
		    g2.setColor( Color.green );

		if ( quantite == 0.0 ) {
		    g2.setColor( Color.white );
		    g.drawLine( x-5 + 5*(i-1), y, x-5 + 5*i , y );
		} else {
		    if (Math.round(quantite) != 0 )
			g.fill3DRect( x-5 + 5*(i-1), y - 2*(int)Math.round(quantite),
				      5 , 2*(int)Math.round(quantite), true );
		    else
			g.fill3DRect( x-5 + 5*(i-1), y - 1,
				      5 , 1, true );
		}
	    }
	    if ( !Etiquette ) { // avec ou sans etiquette ?
		String Nom = ( Longs && nomlong != null )?nomlong:nom;
		g.setColor(couleurTexte);
		g.drawString( Nom, x+5 , y + 2*Sommet.RAYON );
	    }
	}
	g.setColor(old); // permet de ne pas alterer l'etat du contexte tel qu'il est recu
    }
    public synchronized void afficher( Graphics g,
				       boolean Etiquette, 
				       double max,
				       boolean Longs, 
				       int forme, 
				       boolean clustering, int rang, int param) {
	Color old = g.getColor();
	double quantite = 0.0, cl = 0.0;
 	// on récupère le nombre d'instances de notre morphing
	int periode=per;
	Graphics2D g2 = (Graphics2D)g;

	if ( this.getVisible() ) {
	    if ( max != 0.0 )
		cl = metrique/max;
	    //System.out.println(nom + " : " + metrique + " : " + max );
	    if ( forme == 0 ) {  // sommet sous forme circulaire avec nuances de couleurs
		g.setColor(couleur);
		g.fillOval(x - Sommet.RAYON, y - Sommet.RAYON, 
			   2*Sommet.RAYON, 2*Sommet.RAYON);
	    }
	    else
		// sommet sous forme de cercle dont la taille depend de sa metrique
		if ( forme  == 1) { 
		    if ( type == 1 && !clustering )
			g.setColor(Color.red);
		    if ( type == 1 &&  clustering )
			g.setColor(couleurClasse); 
		    if ( type == 0 )
			g.setColor(Color.green);
       		    
		    quantite = 10*Math.sqrt(cl);
		    if ( quantite < 1.0 ) // c.a.d cl < 0.1
			quantite = 1.0;

		    g.fillOval( (int)(x - quantite-1), (int)(y - quantite-1),
				2*Math.round((float)quantite) +1 , 2*Math.round((float)quantite) +1);   
		} else
		    // sommet sous forme de barre

	if ( this.getVisible() ) {
	// instances sous forme de barres
 		if (param==1){
			for ( int i = 1; i <= periode ; i++ ) {
				quantite = 20*Metrique[i]/Metrique[periode+1] ;
				if ( type == 1 && !clustering ){
				g2.setColor( Color.red );
				// la barre de l'histogramme correspondant à la deuxième instance sera bleue
				if (i==2)
				g2.setColor(Color.blue);
				// la barre de l'histogramme correspondant à la deuxième instance sera noire
				if (i==3)
				g2.setColor(Color.white);
				// la barre de l'histogramme correspondant à la deuxième instance sera orange
				if(i==4)
				g2.setColor(Color.orange);
				if(i==5)
				g2.setColor(Color.magenta);
				if(i==6)
				g2.setColor(Color.cyan);
				if(i==7)
				g2.setColor(Color.yellow);
				if(i==8)
				g2.setColor(Color.green);
				if(i==9)
				g2.setColor(Color.orange);
				if ( type == 1 &&  clustering )
				g.setColor(couleurClasse);
				if ( type == 0 )
				g2.setColor( Color.green );
				}
				if ( quantite == 0.0 ) {
				g2.setColor( Color.white );
				g.drawLine( x-5 + 5*(i-1), y, x-5 + 5*i , y );
				} else {
				if (Math.round(quantite) != 0 )
					g.fill3DRect( x-5 + 5*(i-1), y - 2*(int)Math.round(quantite),
						5 , 2*(int)Math.round(quantite), true );
				else
					g.fill3DRect( x-5 + 5*(i-1), y - 1,
						5 , 1, true );
				}
			}
		}
		if (param==2){
			for ( int i = 1; i <= periode ; i++ ) {
				quantite = 20*Metrique[i]/Metrique[periode+1] ;
				if ( type == 1 && !clustering ){
					g2.setColor( Color.red );
					// la barre de l'histogramme correspondant à la première instance sera bleue
					if (i==1 && i==rang)
					g2.setColor(Color.green);
					// la barre de l'histogramme correspondant à la deuxième instance sera bleue
					if (i==2 && i==rang)
					g2.setColor(Color.green);
					// la barre de l'histogramme correspondant à la troisième instance sera noire
					if (i==3 && i==rang)
					g2.setColor(Color.green);
					// la barre de l'histogramme correspondant à la quatrième instance sera orange
					if(i==4 && i==rang)
					g2.setColor(Color.green);
					if(i==5 && i==rang)
					g2.setColor(Color.green);
					if(i==6 && i==rang)
					g2.setColor(Color.green);
					if(i==7 && i==rang)
					g2.setColor(Color.green);
					if(i==8 && i==rang)
					g2.setColor(Color.green);
					if(i==9 && i==rang)
					g2.setColor(Color.green);
				}
				if ( type == 1 &&  clustering )
				g.setColor(couleurClasse);
				if ( type == 0 )
				g2.setColor( Color.green );
				if ( quantite == 0.0 ) {
					g2.setColor( Color.white );
					g.drawLine( x-5 + 5*(i-1), y, x-5 + 5*i , y );
				} else {
				if (Math.round(quantite) != 0 )
				g.fill3DRect( x-5 + 5*(i-1), y - 2*(int)Math.round(quantite),
					5 , 2*(int)Math.round(quantite), true );
				else
				g.fill3DRect( x-5 + 5*(i-1), y - 1,
					5 , 1, true );
				}
			}
		}
		if (param==3){
			quantite = 20*Metrique[rang]/Metrique[periode+1];
			g2.setColor( Color.green );
  			if ( type == 1 &&  clustering )
			g.setColor(couleurClasse);
			if ( type == 0 )
			g2.setColor( Color.green );
			 {
				g2.setColor( Color.white );
				g.drawLine( x , y, x+5 , y );
				g2.setColor( Color.green );
				g.fill3DRect( x-5 + 5, y - 2*(int)Math.round(quantite),
					5 , 2*(int)Math.round(quantite), true );
   			 }
		}


		if ( forme  == 3 ) {
		g.setColor(couleurClasse);
		g.fillOval( x - Sommet.RAYON, y - Sommet.RAYON,
				2*Sommet.RAYON, 2*Sommet.RAYON );
		}

		if ( !Etiquette ) { // avec ou sans etiquette ?
			String Nom = ( Longs && nomlong != null )?nomlong:nom;
			g.setColor(couleurTexte);
			g.drawString( Nom, x+5 , y + 2*Sommet.RAYON );
		}
	}
	g.setColor(old); // permet de ne pas alterer l'etat du contexte tel qu'il est recu
      }
    }


    /**
       Deplace le sommet en changeant ses coordonnees.
       @param newX nouvelle abcisse
       @param newY nouvelle ordonnee
       @param w largeur de la fenetre
       @param h hauteur de la fenetre
     */
    public synchronized void deplacer(int newX, int newY, int w, int h)
    {
	
	if ( newX < 0 &&  newY < 0 ) {
	    x = 10; y = 10; }
	
	else 
	    if ( newX < 0 &&  newY > h-6 ) {
	    x = 10; y = h-60; }
	
	    else 
		if ( newX > w &&  newY > h-6 ) { 
		x = w-10;  y = h-6; }
	
		else if ( newX > w &&  newY < 0 ) {
		x = w-10;  y = 10; }
	
		else if ( newX > 0 && newX < w  && newY < 0 ) { 
		x = newX ; y = 10; }
	
		else if ( newX <= 0 &&  newY > 0 && newY < h ) { 
		x = 10; y = newY;  }
	
		else if  ( newX > 0 &&  newX < w && newY > h-6 ) { 
		x = newX; y = h-6; }
	
		else if  ( newX > w && newY < h ) { 
		x = w-10; y = newY ; }
		else { 
		    x = newX; y = newY ; }
    }
    /**
       Change la couleur du sommet.
       @param newColor nouvelle couleur
     */
    public synchronized void colorer(Color newColor)
    {
	couleur = newColor;
    }

    /**
       Change l'etiquette du sommet.
       @param newName nouvelle etiquette
     */
    public synchronized void renommer(String newName)
    {
	nom = newName;
    }

    /**
       Deux sommets sont egaux si et seulement si leurs coordonnes sont 
       identiques.
     */
    public boolean equals(Sommet autre)
    {
	return  x == autre.x && y == autre.y && nom == autre.nom;
    }
}


